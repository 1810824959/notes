---
<h1>11.1</h1>
1.设计一个任务调度框架
<ul>1.想法</ul>

	整一个主从结构的东西，中间用mq串联，主节点负责调度，子节点都相同，负责执行任务。主节点维护一个类LRU的东西，每次进来就把任务发到，已经在做的，优先级最低的节点上去，不满足的或者被打断暂停的，就存进缓存里

	结合单点故障，通信可靠行，日志记录等

2.设计一个分布式kv
<ul>1.注意点</ul>

	1.数据存储
	2.水平增删节点
	3.支持快照
	4.容错容灾，比如断电等
	5.单点故障
	6.并发查询的压力/安全

<ul>2.解决</ul>
	
	###数据存储
	按照hash存储到对应的节点上，极端一点，一份数据弄三个备份。也可以设计数据结构，像hadoop一样，逻辑地址对应实际地址

	###水平增删节点
	可以使用一致性hash算法

	###支持快照/断电容灾
	可以像redis的RDB一样，每一行更新操作执行，都写进binog里，断电或者快照，都可以通过binlog恢复

	###单点故障
	可以让每一台节点，都实际上是一个zookeeper集群，那么集群中数据备份有很多，既解决了数据备份，又解决了单点故障，还有数据一致性

	###并发查询的压力
	暂时想不到
	
	###并发安全
	分布式锁，以节点作为粒度

<ul>3.新的思路</ul>

	像hadoop一样，对数据进行分片，每一片在所有node上都有备份，对外就是一个整体的kv系统

	###新的问题
	数据一致性，对外的master节点，数据分片的映射
	
<ul>4.参考</ul>

	搜索关键字:分布式kv
	链接：
	http://blog.itpub.net/31559357/viewspace-2218357/
	https://laohanlinux.github.io/2016/04/25/%E4%BD%BF%E7%94%A8raft%E7%AE%97%E6%B3%95%E5%BF%AB%E7%86%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84key-value%E7%B3%BB%E7%BB%9F/


---
<h1>11.2</h1>

1.做题
<ul>1.力扣859. 亲密字符串</ul>
	
	两个字符串，如果通过交换一个字符就可以一样，就是亲密字符串

	###解答
	注意，是要交换一次，所以首先长度不一样肯定不是
	分为两种情况：1.两个字符串一样，如果是ab和ab，肯定不是，所以需要交换是相同的字符。  2.两个字符串不一样。就遍历，记录两个不一样的点，如果一个不同，三个不同，都是错的，并且前提是两个不同的，还要互相相等。


<ul>2.力扣665. 非递减数列，一串数组，判断只改变一个数字，能不能变成一个非递减数列</ul>

	###第一种解法
	只能改一次，那我遇到不符合就改一次，然后看是不是就行了。假设遇到 nums[i]>nums[i+1]，先让前面的等于后面的，看是不是，再让后面的等于前面的，再看是不是，最坏遍历三遍

	###第二种解法
	不停地缩减数组，如果a<b<c排下来，那么a是不可能需要更改的，就直接把a删掉就好，从后面来也是一样。看剩下的长度即可

	###单调栈失败
	3423  了解下？
	


---
<h1>11.3</h1>

1.记一次印象深刻的面试
<ul>1.过程</ul>

	上来先自我介绍，然后说了下

	1.tcp/ip协议的组成
	2.协程
	3.多线程和多进程/他们的用处和场景
	4.项目的设计，团队协作，测试比重
	5.四次挥手的time_wait
	6.三次握手中，第三次，服务端没收到/服务端无法接受
	7.链路层的协议
	8.mq消息的时效性
	9.B+树
	10.热点消息的数据库更新
	11.缓存一致性/redis具体怎么做缓存/memecache怎么读/差别？
	12.后台的同时处理并发请求的策略/select多路复用
	13.那两道题，剑指offer


---
<h1>11.4</h1>
1.查一查昨天的缺陷
<ul>1.TCP/IP的分层</ul>

	###osi分层
	应用层(表示，会话),传输层，网络层，链路层，物理层

	###tcp/ip分层
	其实这个分起来意义不大
	应用层:好说，就是http，ftp等使用了tcp/ip协议的应用层协议
	传输层：TCP和UDP
	网络层：其实就是ip协议，把数据封装成ip报文，进行通信
	网络接口层：物理帧的传输，有arp和rarp

	
<ul>2.热点消息的数据库策略</ul>

	1.前端抗下许多流量，防止恶意提交，后端可以用token
	2.有选择性的失败，牺牲一部分用户体验
	3.设置缓存，都在缓存里操作，同时消息队列异步更新到数据库
	4.用mycat中间件等，分库，甚至分表，弄在多个数据库中，弄成集群，减少单个压力


<ul>3.再重申一下，多线程多进程</ul>

	1.进程的占用内存更大，切换更复杂，线程占用内存小，切换容易，所以适用于IO密集型，因为IO密集型进场有IO切换
	2.线程共享地址空间，共享进程数据，进程是独立的
	3.进程创建销毁/切换都花销大，线程都消耗小
	4.进程之间不会影响，而线程，一个线程崩溃，进程就会崩溃

<ul>4.三次握手和四次挥手补充</ul>

	#三次握手
	三次握手的最后一次如果丢失了
	服务端：会觉得自己发丢了，就会重传
	客户端：会毫无反应，因为发了ACK之后就是建立状态，这时候发送数据，而服务端是半连接状态，就会返回RST，关闭连接

	#四次挥手
	四次挥手最后一次，会等待2MSL的时间，也就是两倍传输时间。为啥呢，一是为了防止这个ACK包丢了，但自己已经关了就不好了，二是为了让这段时间产生的所有数据都弄完，都失效，免得被下次的使用了
	

---
<h1>11.5</h1>
1.做题
<ul>1.两数之和，两数之差</ul>

	###和
	很多版本都可以写，hash表，双指针，这里用双指针
	先对数组排序，设置头尾指针，和比K大，尾指针前移，比K小，头指针后移

	###差
	差不多，先排序，一个指针指向头，一个指第二个，后面按个是被减数，因为更大，减一减，差小了，被减数后移，差大了，减数后移，条件是while(right<length)



<>
明天
1.上课，桥通，ppt
2.学姐报销
3.字节面试准备
4.smartx回顾复习
5.税友毁约
6.
分库分表？
7.下周三下午电话面试达达

---
<h1>11.9</h1>
1.虚拟内存
<ul>综述</ul>

	总的来说，就是实际物理内存的逻辑映射

	1.物理内存不连续，有碎片，但是虚拟内存可以是连续的，方便程序使用
	2.通过页式存储，可以在小内存上运行大程序(回顾下段页式)
	3.并且不直接向外暴露物理地址，防止被破坏


2.分库分表
<ul>1.垂直切分</ul>

	###针对库级别
	很多的表关联性不大，就像是微服务里面，每一个模块的表，分散在不同的数据库中，甚至不同的实例

	###针对同一张表
	就是根据列来切分，比如表中的一行记录，其中有很多字段的使用率不高，就可以拆出来，变成一张新的表
	
<ul>2.水平切分</ul>

	基本可以理解成，单表的数据量太大，进行拆分

	1.范围拆分
	也就是1~1000比如放在A，10000~20000放在B，这样切分，就可以实现，分表下的排序，但是如果根据x字段切分，又根据y字段排序，可能就要先内排序，再归并排序。不过天然的排序，还是很简单的，加节点也很简单

	2.hash切分
	根据hash来进行切分，排序也是用内排序加外排序，而且这个也解决了拓展性，可以考虑用一致性hash来做

	2.冷热拆分
	不常用的放一头，常用的放另一套

<ul>2.分库分表带来的问题</ul>

	1.分布式事务
	一个操作，可能涉及多个数据库，这样就有分布式的事务问题，还有数据一致性问题，这个涉及两段式提交，或者paxos等等

	2.跨节点的join问题
	查询的东西可能跨了节点，就很麻烦
		1.全局表：其实不是全局的意思，就是说一些常用的，甚至是不怎么被修改的，就每个数据库都备份一个
		2.代码层，直接查两次，拼在一起
		3.使用排序，max等等操作时，先内部来一遍，再外部归并

<ul></ul>


并发更新同一条数据，mvcc和行级锁



<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>