<h1>7.1</h1>
**1.短网址原理**
<ul>1.定义：类似于微博的那种 https://t.vn/xxxxxxxxxxx</ul>
<ul>2.流程：</ul>

	1.浏览器输入https://t.vn/xxxxxx
	2.dns获取ip地址
	3.向ip地址请求，服务器收到 路径xxxxx，进行查询，对应到相应的长网址
	4.用301的方式重定向

<ul>3.算法</ul>

	###要求
	1.每个长网址对应的短网址，要独一无二
	2.短网址要短
	3.不能是随机的，一个长的只能对应一个短的，相同的长网址进来也能是同一个短网址

	###自增序列算法（永不重复算法）
	利用mysql的id自增来实现，可以保证每个都重复
	并把id值，通过进制转换，变成短字符串，比如36进制 [0-9a-z]，也可以更多 [a-zA-Z0-9] 等等，总之1亿在36进制也就6位而已

	###注意点
	1.长链接申请创建时，先查查有没有，这样就解决了相同的问题，但是长字段查起来有太慢，可以对其做hash
	2.模拟哈希索引

	   新建一列用于存储该字符列的hash值（哈希函数不要使用SHA1(),MD5(),因为会产生很长的字符串，浪费空间，比较也慢，最好是返回整数的hash函数），在该列建立索引，查询时必须在where子句中包含常量值，以避免hash冲突
	
	      例如： SELECT  id FROM url
			    WHERE url_hash = hash('www.blog.csdn.net')
	            AND url = 'www.blog.csdn.net'

<ul>4.自定义短码的处理</ul>

	###自定义出现的问题
	用户自定义了一个，占了一个id的位子，那么这个id就被浪费了
	且如果由其他id生成的短码，已经被自定义过了呢

	###解决
	id生成的，发现被自定义过了，就把这个自定义的行对应的id拿过来，反正这个id空着的，用这个id去生成，再被占用就继续，反正位子多
<ul>链接：https://www.jianshu.com/p/43eea66a2235</ul>



**2.杂**
<ul>hash的引用场景</ul>
<ul>更加细化的去重，比如同一域名下的很多网址，全部拿来去重很没效率</ul>
<ul>生成唯一id</ul>
<ul>SHA1(),MD5()??返回整数的hash函数？</ul>
<ul>手写多线程</ul>
<ul>互娱和雷火都开始了，准备投，还有阿里</ul>

3.TopK问题
<ul>1.问题描述：从一堆数中找出最大或者最小的 K 个数：相应的，数据量会非常大，先排序再找，不现实</ul>
<ul>2.思路：用堆来做，在一开始，先创建大小为K的堆，对其进行初始化，如果是最大堆，顶上就是最大值，这时候遍历集合，和最大值比较，比最大值小就替换，重新调整，这样遍历完堆里就是最小的K个值</ul>
<ul>3.Java实现</ul>

	public static int[] topK(int [] nums , int k){
        if (k>=nums.length){return nums;}
        int[] res = new int[k];
        for (int i=0;i<k;i++){   //创建一个堆
            res[i]=nums[i];
        }
        for (int j = (k-1)/2 ; j>=0 ; j--){   //初始化这个堆
            shift(res,j);
        }
        for(int item : nums){
            if (item<res[0]){
                res[0]=item;
                shift(res,0);
            }
        }
        return res;
    }

    public static void shift(int [] nums , int index){
        int i = index;
        int j = 2*i+1;
        while (j<nums.length){
            if (j+1 < nums.length && nums[j+1]>nums[j]){
                j++;
            }
            if (nums[i]<nums[j]){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i = j;
                j = 2*i+1;
            }else {
                break;
            }
        }
    }


<h1>7.3</h1>

1.算法练习
<ul>见 算法.md</ul>

2.杂
<ul>1.ArrayBlockingQueue 这里的公平锁，本质上，就是重入锁的公平锁，就是在释放锁的时候，下一个拿到的是不是符合公平原则</ul>


<h1>7.5</h1>

1.算法练习
<ul>见 算法.md</ul>

2.杂
<ul>1.BFS就是广度优先遍历，一般使用队列来实现，DFS就是深度优先遍历，如果用数据结构写，就是栈，如果不是，一般就是回溯法</ul>
<ul>2.最短路径算法</ul>

	1.之前BFS用队列来做，是因为每个点之间的距离权重是一样的，此时加了权重，为保证最小所以需要用优先级队列，最小的在前
	2.狄杰斯特拉算法：主要是维护两个东西：1.从起点到终点的中间每个点的距离   2.每个点最短路径中的，上一个点  3.还有一个辅助的数组，表示哪些已经被搜索过了

	###大致思想
	首先从起点开始，写下起点到它能到的所有点的距离，到不了的就无穷大，把这个起点放进seen里面，表示已经搜索过了。

	下一步，从其余点中找出距离最小的点（注意，这个cost队列，存的都是到原点的距离），把最小的点作为起点，重复一遍，新距离是起点到该点的最短距离+到下一个点的距离，如果够小，就更新

	直到所有的都结束，都放进了seen为止

<h1>7.7</h1>

**1.倒排索引**
<ul>1.定义：顾名思义，和正向索引不同，是用value来索引key</ul>
<ul>2.应用场景：搜索引擎，Mysql全文索引等等</ul>
<ul>3.具体：</ul>

	比如，百度搜索“华为”，我要去找每一个网页，看看里面有没有华为两个字，找出来之后还要进行打分，给他排序，肯定是不行的，所以事先维护一个由“华为”字符做key，value是哪些文档含有它

	需要一个单词列表，每一项是包含的文档，再细致一点，可能还把频率，等等加进去

	单词列表的查询，可以像hashmap一样用数组加链表，也可以直接用树，还有在建立倒排索引之前，要先对文档进行分词，把单词找出来

	查询一个组合的字符，就对应他们的交集

**2.MySQL读写分离和主从复制**
<ul>1.关系</ul>

	主从复制是读写分离的前提

	有时候数据库压力很大，就可以考虑读写分离，一个数据库负责写，一个负责读，就可以提升一倍性能，但是为了保证来奶哥哥数据库数据要一样，就必须用主从复制

	
<ul>2.主从复制</ul>

	1.主库要开启binlog的日志功能
	2.不同库的id要不一样
	3.保证连通

	主库做的每个操作，每个sql语句，都记录在binlog的二进制文件里，每当一个从库连接进来，主库就会新开一个线程，传到从库，从库这时候有两个线程，一个接受二进制并存到relay.log，还有一个，去串行执行语句

	###主库宕机？怎么保证数据不丢失？
	采用半同步复制，写进binlog的同时，本来是异步复制，不用管从库，但是现在不行，必须确保有一个从库接收到了，才会显示commit成功，保证了不管主库宕不宕机，总是有一份数据是完整的

	之所以是叫半同步，是因为当等待时间超过一定设置值，主库就不管他了，退化成异步复制

	###从库是一条一条来的，太慢数据延迟咋办
	有一个并行复制，是从库的relay进行并行，5.7版本新增，主库怎么并行执行，从库就怎么并行
<ul>3.读写分离</ul>

	一台服务器负责insert,update操作，另一台负责select，前提是两者之间数据同步

	1.代码上实现，插入更新操作发到写服务器，查询操作发到读服务器。
	2.通过数据库中间件（mycat,阿里的Cobar）

**3.mysql分区分表**
<ul>1.水平拆分：比如按年查询的，就把今年的分出来，因为被查的几率大嘛</ul>
<ul>2.垂直拆分，一个表的字段，可以拆成多个表，在查的时候，单独去查，代码层拼起来就好</ul>
<ul>3.垂直拆分可能会有分布式事务的问题，就按照分布式锁来</ul>


<h1>7.8</h1>

1.分布式ID生成器
<ul>1.要求：</ul>

	1.肯定要不一样啊
	2.最好是递增，方便查询
	3.高可用，单点挂了可不行
	4.ID要短一点，方便存，占用空间不能太大
	5.批量生成

<ul>2.生成方式</ul>
	
	##snowflake
	一个id有64bit
	首先第1bit空着，为0
	2——41bit是当前的时间戳到某个时间的毫秒
	后面的10bit是机器id，这样就是2的10次，可以有1024台机器
	最后12bit，就是代表，该机器当前单位时间内（毫秒），能生成的数量，这里是4096，那样一秒就是4096000，QPS很大了

	实际上，上面的东西可以进行调整

	###其他方法
	1.用mysql主键，但是单机版的可能不太行，主从的话，还要考虑主从复制
	2.UUID，这样就不保证递增（随机）
	3.直接根据当前时间来，这样就不能批量了
<ul>3.链接：https://www.jianshu.com/p/2e57acbe4a19，下方的refer也很好</ul>


<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>