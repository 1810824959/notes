<h1>2.1</h1>
- 面试问题回顾解答<br>
-
**1.索引的正确使用**
<ul>1.在经常需要查找的列上使用索引</ul>
<ul>2.在经常对外做连接的列上索引，这些键大多是外键</ul>
<ul>3.对需要排序的列索引</ul>
<ul>4.对经常用where 的列做索引</ul>
<ul></ul>
<ul></ul>

**2.不该用索引的时候**
<ul>1.很少用到的列</ul>
<ul>2.数据量很少，比如只有几万条</ul>
<ul>3.值的类型很单一，是枚举类型的，比如性别，只有男女</ul>
<ul>4.经常修改更新的列也不要做，影响性能</ul>

**3.索引注意事项**
<ul>1.Mysql中Like查询 keyword%，走索引 %keyword%，不走索引</ul>
<ul>2..索引多了的表，不建议物理删除数据，最好逻辑删除</ul>
<ul>3.索引不会包含含有NULL值的列，复合索引只要有一列含有NULL值,那么这一列对于此符合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL</ul>
<ul>4.MySQL查询只是用一个索引，如果where字句中使用了索引的话，那么order by中的列是不会使用索引的</ul>

**4.查询优化**
<ul>很好的总结：https://dbaplus.cn/news-155-1531-1.html</ul>

<ul>https://blog.csdn.net/hjy132/article/details/78220186</ul>

**5.python的属性**
<ul>https://blog.csdn.net/sjyttkl/article/details/80653035</ul>



<h1>2.2</h1>
- 剑指offer OJ<br>
-
**1.OJ的一些窍门**
<ul>1.接受题目输入用例的时候，直接用input就好了，不需要一定是sys.stdin，输出就用print，同时，接受的时候最好用while True</ul>
<ul>2.有时候期待的是true，其实不是指True，直接用"true"字符串就可以</ul>
<ul>3.有时候题目要求输出[1.2.3]，不一定就是要你真的弄一个出来，有可能是树啊，链表什么的，只会给你一个头或者根节点</ul>
<ul></ul>
**1.有序二维数组**
<ul>1.以前也做过，但是用到了numpy，那时候用到了列表的切片，但其实可以用while，设置横纵坐标i,j，i++,i--就可以</ul>


<h1>2.3</h1>
- 剑指offer OJ<br>
-
**1.重建二叉树**
<ul>1.先序，中序什么的，都是以根节点为基准，先序就是根左右，有先序，后序，中序，宽度优先遍历</ul>
<ul>2.题目给出前序和中序，前序的第一个，就是根节点，在中序中找到根节点，左边就是左子树，右边就是右子树</ul>
<ul>3.该题用了递归，参数是一个先序，一个中序，判断条件是先序的长度，为0就是上次的的根节点在中序中是第一个，所以到了这一轮，传进来的先序为空，说明左子树没了，当长度为1说明，该节点就是了，下面没了，右边是一样得到步骤</ul>

**2.用两个栈实现一个队列**
<ul>1.栈是先进后出，一个压入的动作，队列是先进先出，排队的动作</ul>
<ul>2.大致思想是这样的，a,b,c的顺序进栈，出来是c,b,a，如果把一个栈的元素灌进另一个栈，出来就会反向又反向，回到了最开始顺序，就通过两个栈，完成了先进先出的队列，，，插入始终在stack1，有pop就灌到stack2,每次pop都检测stack2是否为空</ul>

**3.用两个队列实现一个栈**
<ul>1.大致思路，两个队列，插入的时候插入其中一个，要弹出的时候，依次从前头弹出，并存到另一个队列，当弹出到长度为1的时候，就是队列尾的元素，，继续亦然，反复删除队列头的并存到另一个为空的列表</ul>

<h1>2.4除夕夜</h1>

**1.快排python实现**
<ul>1.https://www.cnblogs.com/feichangnice/p/5334195.html</ul>
<ul>2.思路很简单，用最后一个作为基准，j遍历前面的，遇到比基准小的，就移到前面去，把i=-1作为小元素的起始，每次用的时候+1，就是从0开始了</ul>

<h1>2.5</h1>

**1.快排复杂度推导**
<ul>1.时间复杂度的计算，其实没有想像中的公式之类的，就是单纯的看执行次数，并相加，而一次操作的概念，打个比方就是for 循环里头的代码，就是一次操作</ul>
<ul>2.快排最好的情况，就是每次分好之后，基准都移到最中间，直接理解就是，一次全部的循环，然后做二分，所以是N 和 logN 所以是N*logN，自己推导就是，设一轮快排是 T(N) 次，那么经过一轮之后，T(n)≤ 2T(n/2)+n，而T(1)=0，从N二分到1，是log2N次，计算即可</ul>
<ul>3.最坏的情况，就是有序的序列，每次都是分成了 1 和 N-1 ，这样 N + N-1 + N-2 ...+1，求和之后是N的平方级别</ul>
<ul>4.https://blog.csdn.net/u010429424/article/details/78068825</ul>

**2.O(N)的稳定排序**
<ul>1.书中提供了一种复杂度O(N)的算法，条件是需要排序的数范围不是很大，而且多使用了一个数组</ul>
<ul>2.首先，创建一个长度为范围的数组，都置零，对需排序的进行遍历，遇到一个，就相应的在该下标的地方+1，弄完之后得到一个范围长度的数组，里面是每个元素出现的次数，这样就已经排好序了，通过它重建序列就好</ul>

**3.二分法彻底弄清**
<ul>1.不难的，只是下标的选择，当每次下标移动时，如果不带有+1或-1，直接用mid取代，最终的结果就是下标会停留在两个相邻元素，如果你用while left < right就永远不能跳出了，所以一般会在一种情况选取mid的旁边一位，而取mid这个整除2，在奇数时会向小取，所以在后半段+1才不会漏下，不然会漏下</ul>
<ul>2.没有+1或-1，只能取到相邻，有了后半段+1，可以到下标相同，但是 left < right就会跳出，如果刚好最后一个就是，就不能比较了，所以改成left <= right</ul>
<ul>3.总结下，right=len-1，条件是left <= right ，后半段+1，另外可以调整，比如选right=len,条件就是left < right</ul>
<ul>4.疑问：如果有重复元素咋办</ul>

**4.旋转数组中查找最小值**
<ul>1.也是用二分法，不过没有+1或-1，这样取到两个相邻的，left是上半段最后一个，right是下半段第一个，如果遇到重复的元素，这里不需要查找，所以right-=1，因为这里用了个技巧，只跟right对比</ul>

**5.留的东西**
<ul>1.二分法的重复问题，和4的部分还没明白</ul>
<ul>2.python 中 //2 和 >>1 都是对2整除？？？</ul>
<ul>3.谷歌的今日收藏夹</ul>


<h1>2.6</h1>

**1.斐波那契数列**
<ul>1.原理，第0项是0，第一项是1，后面第n 项是 f(n-1)+f(n-2)</ul>
	def Fibonacci(n):
        if n == 0:
            return 0 
        if n == 1:
            return 1
        return Fibonacci(n-1)+Fibonacci(n-2)
<ul>2.上面代码是最简单的递归，但是有问题，比如f(9)=f(8)+f(7),f(8)=f(7)+f(6)，这样两个，需要算两遍f(7)会有重复计算，效率很低，复杂度是o(2^n)</ul>
<ul>3.现在改变思路，变成o(n)的复杂度，我们从0开始往上去算，这样每一项都只算一次，而且并没有用到递归</ul>
    def Fibonacci(n):
        if n == 0:
            return 0
        if n == 1:
            return 1
        num1,num2 = 1,0
        for i in range(2,n+1):
            sum = num1+num2
            num2 = num1
            num1 = sum
        return sum
<ul>4.这样每输入一个N ，都要重新算一遍，还可以用动态规划，不过那是后面的事情了</ul>

**2.青蛙跳台阶问题**
<ul>1.问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</ul>
<ul>2.这个问题，可以归结为一种斐波那契的应用，设n阶台阶的跳法有 f(n),青蛙在踏出第一步的时候，有两种情况，跳一级，和跳两级，当跳一级时，还剩下n-1级台阶那么此时共剩下 f(n-1)种跳法，当跳二级，还剩下 f(n-2)种，那么可以总结 f(n)=f(n-1)+f(n-2)，最后改造上面的代码即可</ul>

**3.青蛙跳台阶变种**
<ul>1.问题改变：由原来一次性1级或2级，变成任意的n级，每次可以跳n级</ul>
<ul>2.正确思路：和上面一样，第一次跳1级，后面有f(n-1)，跳2级，有f(n-2)，，，，，跳n-1级，有f(1)=1，跳n级，有f(0)=1，也就是f(n)=f(n-1)+f(n-2)....+f(1)+f(0)，，，更加巧的是，刚好是2的n-1次</ul>


<h1>2.7</h1>

**1.位运算**
<ul>1.位运算大概是 与，或，异或，移位，而移位较为麻烦，左移时，右边一律补0，右移时，左边补相应符号位，正就补0，负就补1</ul>
<ul>2. >> 是右移，>>1 效果上等于除以2 ，但是效率速度上比除以要快</ul>

**2.找出二进制数中 1 的个数**
<ul>1.在不使用字符串的前提下，这个问题需要用位运算</ul>
<ul>2.正常思路：利用与运算，将N 和 1 进行与，因为1 除了最后一位，都是0，所以结果如果是1，那么N 的最低位为1，结果为0，最低位就是0，以此类推，将1 左移一位，得到 0010 这样的数，如果结果为2，则该位是1</ul>
	就是N 和 1与，结果 =1 ，最后位就是1
	 1左移，重复
<ul>3.更好的思路，将N 减去 1 ，就可以令最靠后的一个1变成0，它后面的0都变成1，这样的话 ，N*(N-1)就会变成，将N 的最后一个1变成0，前面的不变的效果</ul>
	N & (N-1) 会消去最后一个1

**3.小细节**
<ul>1.反码补码等又忘记了</ul>
<ul>2.做 & 的时候，直接用10进制也可以，不用很麻烦变成二进制</ul>
<ul>3.二进制一般弄到range(0,32)</ul>
<ul>4.N & (N-1) 会消去最后一个1</ul>
<ul>5.python bin(1)=0x1 ，长度为3</ul>

**4.位运算的例子**
<ul>1.判断一个数是不是2的整数次？？2的整数次，就是说，2进制数中只有一个1，这样的话，使用N*(N-1),就会变成0</ul>
<ul>2.有m和n，问要改变多少个二进制位，才能让mn相等？？？？先求异或，不一样就是1，然后统计1的个数</ul>


<h1>2.8</h1>

**1.自己实现pow函数，不使用库函数**
<ul>1.正常思路：需要多少次，就乘多少次，不用考虑底数，为0始终为零，只需要幂，幂=0，结果=1，幂<0，先对幂取绝对数，return 1/result</ul>
<ul>2.更完美思路：比如，2的4次，是两个2的2次，像这样拆分result = pow(base,x>>1)，递归调用即可</ul>
	  def Power(self, base, exponent):
        if exponent == 0:
            return 1
        if exponent == 1:
            return base
        if exponent == -1:
            return 1/base
        result = self.Power(base,exponent>>1)
        result *= result
        if exponent& 1 == 1:
            result = result*base
        return result

**2.做题心得**
<ul>1.递归的代码量比较简单，一层一层下来，分析好最底下一些情况即可，，最关键就是最下面的情况</ul>

**3.将数组奇数在前，偶数在后**
<ul>1.思路：使用辅助内存，遍历原数组，分别存在两个另外的数组，最后整合，复杂度N</ul>

**4.链表中倒数第K个结点**
<ul>1.正常思路：先遍历一遍，得到长度，再遍历第二遍，找到倒数第K个，总的是遍历两遍</ul>
<ul>2.更好的思路：设置两个指针，都从头结点开始，假设有N个结点，就需要从头结点，走N-1步，那么倒数第K个，记住是倒数，离最后一个就是K-1步，那么只要一个先从头开始，另一个落后K-1步，前面那个到了最后，后面的刚好距离最后一个K-1步，刚好是倒数第K个</ul>
    def FindKthToTail(self, head, k):
        if head==None or k==0:
            return
        head1=head
        num = 0
        while head.next:
            head = head.next
            num+=1
            if num>k-1:
                head1=head1.next
        if k>num+1:
            return 
        return head1


<h1>2.9</h1>

**1.小细节**
<ul>1.链表之类，二叉树之类考虑如下细节</ul>
<ul>2.头结点是否为空，参数K是否为0，参数K是否大于链表长度等</ul>

**2.反转链表**
<ul>1.先想象一下，中间一个元素的行为，首先复制一份他的next ，让他自己指向pre,就实现了掉头，然后pre，cur指针向后移动</ul>
<ul>2.特殊情况，第一个时，pre置为空</ul>
    def ReverseList(self, pHead):
        pPre = None
        pNode = pHead
        pRervseHead = None
        while pNode:
            if pNode.next==None:
                pRervseHead = pNode
            pNext =  pNode.next  # 复制next
            pNode.next = pPre   # 掉头
            pPre = pNode  # pre后移
            pNode = pNext  # cur后移
        return pRervseHead
<ul>3.像这个问题，就要考虑，输入为空?只输入一个元
素？</ul>

**3.合并两个有序链表**
<ul>1.比较麻烦的思想：分别遍历两个链表，取出来存在一个列表里，排序之后再组成一个新链表</ul>
<ul>2.正常思路：每次取两个链表的第一个比较，小的放在新链表，然后继续比较，有两种实现，一种是递归，一种是按照逻辑硬来</ul>
    def Merge(self, pHead1, pHead2):
        if pHead1==None:
            return pHead2
        if pHead2==None:
            return pHead1
        pHead = None
        if pHead1.val < pHead2.val:
            pHead = pHead1
            pHead.next = self.Merge(pHead1.next,pHead2)
        else:
            pHead = pHead2
            pHead.next = self.Merge(pHead1,pHead2.next)
        return pHead

	def Merge(self, pHead1, pHead2):
        head = ListNode(90)
        p = head
        while pHead1 and pHead2:
            if pHead1.val<=pHead2.val:
                head.next = pHead1
                pHead1 = pHead1.next
            else:
                head.next = pHead2
                pHead2 = pHead2.next
            head = head.next
        if pHead1:
            head.next = pHead1
        if pHead2:
            head.next = pHead2
        return p.next
<ul>3.第二种硬来实现，为什么用else而不是pHead1.val>pHead2.val，因为在处理过上一个分支之后，pHead1的指针已经变了，如果是最后一个，就变成None了</ul>
<ul>4.注意点：1.输入的链表为空，或者有一个为空  2.一个链表比另一个长  3.两个值相同，取其中一种情况，继续比对即可，不用特殊处理</ul>

<h1>2.10</h1>

**1.找出树的子结构**
<ul>题目描述：驶入两个树的头结点，判断B树是否是A树的子结构</ul>
<ul>题解：遍历树结构，一般用递归来做，写一个函数处理cur结点，然后向左右递归，传入左右子树，，，，在这个题目中，首先处理寻找和子树根一样的结点，找到就判断该节点书否有子树结构，没有就向左，再没有就向右</ul>
<ul>特殊状况：传入的是空树，那就是没有</ul>
    def HasSubtree(self, pRoot1, pRoot2):
        result = False
        if pRoot1!=None and pRoot2!=None:
            if pRoot1.val==pRoot2.val:
                result  = self.judge(pRoot1, pRoot2)
            if result==False:
                result = self.HasSubtree(pRoot1.left, pRoot2.left)
            if result==False:
                result = self.HasSubtree(pRoot1.right, pRoot2.right)
        return result

    def judge(self,pRoot1, pRoot2):
        if pRoot1 == None:
            if pRoot2==None:
                return True
            return False
        if pRoot2 == None:
            return True
        if pRoot1.val == pRoot2.val:
            return self.judge(pRoot1.left,pRoot2.left) and self.judge(pRoot1.right,pRoot2.right)
        if pRoot1.val != pRoot2.val:
            return False
<ul>代码逻辑：总体是判断cur结点能不能找到子树结构，不行就向左递归，根节点左子树不行，就右子树，，，细节上，A树完了，B也完了，那就正好，B还没完，那就是不行，，A还没完，B提早完了，那也是正好，judge函数，只有在cur相同，才会继续</ul>

<h1>2.11（生日）</h1>

**1.二叉树镜像**
<ul>题解：二叉树镜像，就是把所有的左右子树都互换，那么使用递归来遍历，参数就是当前结点，不为空就互换左右，并向左向右递归，空就停，非常简单 </ul>
    def Mirror(self, root):
        if root!=None:
            root.left,root.right = root.right,root.left
            self.Mirror(root.left)
            self.Mirror(root.right)
        return root

**2.顺时针打印矩阵**
<ul>题目描述：输入一个M*N矩阵，从左上开始顺时针打印出来</ul>
<ul>难点：该题没有什么算法，数据结构之类的，就是单纯的遍历，怎么让一行的遍历完之后，变到向下遍历一列，最后循环一圈</ul>
<ul>思路：写一个参数是一圈起点，然后遍历一圈的函数，main函数负责把所有的起点传进去，，，在函数中，考虑传进去的下标越界，然后做四次while循环，来遍历，遍历过的点置为None</ul>
<ul></ul>

**3.细节**
<ul>1.python里前面很多个if ,最后只有一个else，这样只跟随最近的一个if</ul>
<ul>2.在处理列表的时候，经常会有越界，假设if 条件中有两个条件，用or ，第二个是报错的，但是如果第一个满足，第二个就不会去看</ul>
<ul>3.不仅仅是None，列表[]也可以用 if list: 判断是否为空</ul>

**4.实现栈的min函数，要求O(1)复杂度**
<ul>难点：既然本质上是个栈，那么push，pop必须有，min复杂度为1，那么不能遍历之类的</ul>
<ul>错误思路：在实现栈的同时，用一个变量来存放最小元素。但是这样，只有进栈是没错的，但是一旦出栈时，最小那个元素出去了，最小元素就要变了，很难去找下一个最小元素，所以不行</ul>
<ul>正确思路：设置一个辅助栈，主栈在压入，辅助栈也压入。主栈出去，辅助也出去。具体实现：主栈压一个元素，辅助栈会比较该元素和辅助栈顶的大小，如果是最小，就同样压入这个，如果还是辅助栈上的更小一些，那么再重复压入一次，这样一来，辅助栈上就是递减的，可以同时跟着主栈进出</ul>


<h1>2.12</h1>

**1.判断是否为弹出序列**
<ul>题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</ul>
<ul>错误思路：问题看起来很复杂，就是给两个序列，后者有没有可能是前者的栈弹出序列，起初我陷入了误区，想要穷举出所有的可能，再进行匹配，，肯定是不对的</ul>
<ul>正确思路：压入和弹出都不是一次性全部的，首先慢慢压入，遇到弹出序列的第一个，则弹出，然后查看下一轮的是不是也符合弹出序列，否则就继续压，直到符合弹出序列为止，可以这样判断，压入序列用完了，如果栈中的元素还没有被弹出序列消耗完，说明不符合</ul>
    def IsPopOrder(self, pushV,用递归来做  popV):
        if not pushV or  len(pushV)!=len(popV):
            return False
        stack=[]
        for i in pushV:
            stack.append(i)
            while len(stack) and stack[-1]==popV[0]:
                stack.pop()
                popV.pop(0)
        if len(stack):
            return False
        return True

**2.广度遍历，从上到下打印二叉树**
<ul>我的拙劣思路：大致思路借鉴了那个用数组排序的原理，弄一个数组，里面第0个是根的值，第1个是下一层的值，遍历完二叉树，这个数组也填满了，最后解压出来就好了，具体实现，递归一个cur结点的函数，然后向左向右递归，每一层都带一个象征层数的值，用来存到大数组里面，，缺点也很明显，效率低，而且存储的数组长度不确定</ul>
    def __init__(self):
        self.result = [[] for i in range(100)]

    def PrintFromTopToBottom(self, root):
        self.foo(root,0)
        res =[]
        for i in self.result:
            for j in i:
                res.append(j)
        return res

    def foo(self,node,flag):
        if node:
            self.result[flag].append(node.val)
            self.foo(node.left,flag+1)
            self.foo(node.right,flag+1)
        else:
            return
<ul>正确思路：用一个列表，从根节点开始，把左右结点放进去，然后while 列表不为空：就pop出第一个，取左右放在最后，这样一弄，也是按顺序的下来</ul>
    def PrintFromTopToBottom(self, root):
        res=[]
        if not root:
            return []
        temp=[root]
        while len(temp):
            item=temp.pop(0)
            res.append(item.val)
            if item.left:
                temp.append(item.left)
            if item.right:
                temp.append(item.right)
        return res

**3.判断是否为二叉搜索树的后序遍历序列**
<ul>难点：首先是二叉搜索树的概念，二叉搜索树又叫二叉查找树，不仅是单个结点，而是整个左子树的结点都小于根节点，右边也是</ul>
<ul>思路：根据题目，是后序，也就是左右根，那么可以想到，整个序列分为了三段，第一段都比根小，第二段都比根大，第三段就是根，由于是二叉树，那么想到可以用递归做，分别向左向右递归，在一轮中，小于根的最后一个，那就是下一轮的左根，后面都要符合大于根，现在来考虑最底层情况，最差就是参数结点为空，那么说明上一轮就是叶子节点，return true ，还有一种是有一个，那么不管左右，都在根前，也是true </ul>
<ul>注意点：思路中描述好了，最底层条件，还有递归方式，但是要注意，递归中为空时返回true ，但是最最开始的根为空，是要为false，所以做成函数就好</ul>
    def VerifySquenceOfBST(self, sequence):
        if sequence:
            return self.foo(sequence)
        else:
            return False

    def foo(self,sequence):
        length = len(sequence)
        if length == 0:
            return True
        if length == 1:
            return True
        root = sequence[-1]
        left = 0
        while sequence[left] < root:
                left += 1
        for j in range(left, length-1):
            if sequence[j] < root:
                return False
        return self.foo(sequence[:left]) and self.foo(sequence[left:length-1])

<h1>2.13</h1>

**1.网易面试拾遗**
<ul>1.orm怎么实现复杂查询，in and or ?</ul>
<ul>2.常用的linux命令，比如PS命令参数</ul>
<ul>3.man 和 -help的差别，man有哪些命令是不能看到的</ul>
<ul>4.cd 为什么要作为系统自带命令，而不需要用户自己安装</ul>
<ul>5.进程间通信方式</ul>
<ul>6.信号量的方式：同步，互斥</ul>
<ul>7.远程的进程通信用什么方式？只能用socket</ul>
<ul>8.解释一下socket协议？？socket最终的底层协议？</ul>
<ul>9.socket是哪一层的？应用层协议有哪些</ul>
<ul>10.算法稳定性，哪些排序算法是稳定的？哪些又是不稳定的</ul>
<ul>11.python编码类型？</ul>

**2.找出二叉树中，和为N的所有路径**
<ul>该题目原本是希望得到一整条路径，也就是直到叶节点的，但是我理解错了，以为只要连着的就可以，不用到叶节点</ul>
<ul>正确思路（到叶节点）：两个列表，一个是存return 的，一个是保存经过的节点，大体上一个二叉树的递归，底层条件是没有左右子树了，而且路径之和符合要求，就添加，否则不做事。重点考虑，当一个节点搜索完，返回时，怎么Pop 该节点</ul>
<ul>注意点：函数传进去递归的参数，是一种引用，如果有必要，需要用copy.copy浅复制一下</ul>

**3.找出字符串的所有排列**
<ul>题解：看起来很难，但是有一个很好的思路，一个字符串，可以看成两部分，第一个字符和后面所有的字符，将第一个字符和后面所有的分别交换一次，就是递归了一次，然后对后面的作为整体的，进行递归，最底层就是只有一个的时候。总结：将第一个和后面每个元素交换，然后递归N-1个</ul>
<ul>注意点：重复的可以用set去重，最后可能还需要sorted一下</ul>
 	def Permutation(self, ss):
        if ss:
            resList=[]
            self.foo(ss,resList,0)
            return sorted(resList)
        else:
            return []
    def foo(self,string,resList,index):
        if index==len(string)-1:
            if string not in resList:
                resList.append(string)
            return
        for i in range(index,len(string)):
            if i>index:
                new_str = string[0:index]+string[i]+string[index+1:i]+string[index]+string[i+1:]
            else:
                new_str=string
            self.foo(new_str,resList,index+1)


**4.python 知识补遗**
<ul>1.= 这种赋值操作，会把引用一样传过来</ul>
<ul>2.重新复习一下，类似引用传递的东西，如果不想要那种引用传递的效果</ul>
<ul>3.=？深浅复制？copy.copy和copy.deepcopy?</ul>

**5.深拷贝和浅拷贝**
<ul>首先，拷贝这个概念我一直弄错了，拷贝代表着，这是一份新的数据，是独立的，包括内存</ul>
<ul> = 号：复制操作，是一种共享，内存和数据都是一样的</ul>
<ul>copy.copy 或者 x.copy()： 这是浅拷贝，比如列表有多维，多层，浅拷贝只能做到第一层是独立的，更深入的还是共享，原数据更改，它也会跟着改</ul>
<ul>deepcopy:这个是深拷贝，代表着，这就是一份独立的，不共享内存的数据</ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


