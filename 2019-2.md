<h1>2.1</h1>
- 面试问题回顾解答<br>
-
**1.索引的正确使用**
<ul>1.在经常需要查找的列上使用索引</ul>
<ul>2.在经常对外做连接的列上索引，这些键大多是外键</ul>
<ul>3.对需要排序的列索引</ul>
<ul>4.对经常用where 的列做索引</ul>
<ul></ul>
<ul></ul>

**2.不该用索引的时候**
<ul>1.很少用到的列</ul>
<ul>2.数据量很少，比如只有几万条</ul>
<ul>3.值的类型很单一，是枚举类型的，比如性别，只有男女</ul>
<ul>4.经常修改更新的列也不要做，影响性能</ul>

**3.索引注意事项**
<ul>1.Mysql中Like查询 keyword%，走索引 %keyword%，不走索引</ul>
<ul>2..索引多了的表，不建议物理删除数据，最好逻辑删除</ul>
<ul>3.索引不会包含含有NULL值的列，复合索引只要有一列含有NULL值,那么这一列对于此符合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL</ul>
<ul>4.MySQL查询只是用一个索引，如果where字句中使用了索引的话，那么order by中的列是不会使用索引的</ul>

**4.查询优化**
<ul>很好的总结：https://dbaplus.cn/news-155-1531-1.html</ul>

<ul>https://blog.csdn.net/hjy132/article/details/78220186</ul>

**5.python的属性**
<ul>https://blog.csdn.net/sjyttkl/article/details/80653035</ul>



<h1>2.2</h1>
- 剑指offer OJ<br>
-
**1.OJ的一些窍门**
<ul>1.接受题目输入用例的时候，直接用input就好了，不需要一定是sys.stdin，输出就用print，同时，接受的时候最好用while True</ul>
<ul>2.有时候期待的是true，其实不是指True，直接用"true"字符串就可以</ul>
<ul>3.有时候题目要求输出[1.2.3]，不一定就是要你真的弄一个出来，有可能是树啊，链表什么的，只会给你一个头或者根节点</ul>
<ul></ul>
**1.有序二维数组**
<ul>1.以前也做过，但是用到了numpy，那时候用到了列表的切片，但其实可以用while，设置横纵坐标i,j，i++,i--就可以</ul>


<h1>2.3</h1>
- 剑指offer OJ<br>
-
**1.重建二叉树**
<ul>1.先序，中序什么的，都是以根节点为基准，先序就是根左右，有先序，后序，中序，宽度优先遍历</ul>
<ul>2.题目给出前序和中序，前序的第一个，就是根节点，在中序中找到根节点，左边就是左子树，右边就是右子树</ul>
<ul>3.该题用了递归，参数是一个先序，一个中序，判断条件是先序的长度，为0就是上次的的根节点在中序中是第一个，所以到了这一轮，传进来的先序为空，说明左子树没了，当长度为1说明，该节点就是了，下面没了，右边是一样得到步骤</ul>

**2.用两个栈实现一个队列**
<ul>1.栈是先进后出，一个压入的动作，队列是先进先出，排队的动作</ul>
<ul>2.大致思想是这样的，a,b,c的顺序进栈，出来是c,b,a，如果把一个栈的元素灌进另一个栈，出来就会反向又反向，回到了最开始顺序，就通过两个栈，完成了先进先出的队列，，，插入始终在stack1，有pop就灌到stack2,每次pop都检测stack2是否为空</ul>

**3.用两个队列实现一个栈**
<ul>1.大致思路，两个队列，插入的时候插入其中一个，要弹出的时候，依次从前头弹出，并存到另一个队列，当弹出到长度为1的时候，就是队列尾的元素，，继续亦然，反复删除队列头的并存到另一个为空的列表</ul>

<h1>2.4除夕夜</h1>

**1.快排python实现**
<ul>1.https://www.cnblogs.com/feichangnice/p/5334195.html</ul>
<ul>2.思路很简单，用最后一个作为基准，j遍历前面的，遇到比基准小的，就移到前面去，把i=-1作为小元素的起始，每次用的时候+1，就是从0开始了</ul>

<h1>2.5</h1>

**1.快排复杂度推导**
<ul>1.时间复杂度的计算，其实没有想像中的公式之类的，就是单纯的看执行次数，并相加，而一次操作的概念，打个比方就是for 循环里头的代码，就是一次操作</ul>
<ul>2.快排最好的情况，就是每次分好之后，基准都移到最中间，直接理解就是，一次全部的循环，然后做二分，所以是N 和 logN 所以是N*logN，自己推导就是，设一轮快排是 T(N) 次，那么经过一轮之后，T(n)≤ 2T(n/2)+n，而T(1)=0，从N二分到1，是log2N次，计算即可</ul>
<ul>3.最坏的情况，就是有序的序列，每次都是分成了 1 和 N-1 ，这样 N + N-1 + N-2 ...+1，求和之后是N的平方级别</ul>
<ul>4.https://blog.csdn.net/u010429424/article/details/78068825</ul>

**2.O(N)的稳定排序**
<ul>1.书中提供了一种复杂度O(N)的算法，条件是需要排序的数范围不是很大，而且多使用了一个数组</ul>
<ul>2.首先，创建一个长度为范围的数组，都置零，对需排序的进行遍历，遇到一个，就相应的在该下标的地方+1，弄完之后得到一个范围长度的数组，里面是每个元素出现的次数，这样就已经排好序了，通过它重建序列就好</ul>

**3.二分法彻底弄清**
<ul>1.不难的，只是下标的选择，当每次下标移动时，如果不带有+1或-1，直接用mid取代，最终的结果就是下标会停留在两个相邻元素，如果你用while left < right就永远不能跳出了，所以一般会在一种情况选取mid的旁边一位，而取mid这个整除2，在奇数时会向小取，所以在后半段+1才不会漏下，不然会漏下</ul>
<ul>2.没有+1或-1，只能取到相邻，有了后半段+1，可以到下标相同，但是 left < right就会跳出，如果刚好最后一个就是，就不能比较了，所以改成left <= right</ul>
<ul>3.总结下，right=len-1，条件是left <= right ，后半段+1，另外可以调整，比如选right=len,条件就是left < right</ul>
<ul>4.疑问：如果有重复元素咋办</ul>

4.旋转数组中查找最小值
<ul>1.也是用二分法，不过没有+1或-1，这样取到两个相邻的，left是上半段最后一个，right是下半段第一个，如果遇到重复的元素，这里不需要查找，所以right-=1，因为这里用了个技巧，只跟right对比</ul>

5.留的东西
<ul>1.二分法的重复问题，和4的部分还没明白</ul>
<ul>2.python 中 //2 和 >>1 都是对2整除？？？</ul>
<ul>3.谷歌的今日收藏夹</ul>


<h1>2.6</h1>

**1.斐波那契数列**
<ul>1.原理，第0项是0，第一项是1，后面第n 项是 f(n-1)+f(n-2)</ul>
	def Fibonacci(n):
        if n == 0:
            return 0 
        if n == 1:
            return 1
        return Fibonacci(n-1)+Fibonacci(n-2)
<ul>2.上面代码是最简单的递归，但是有问题，比如f(9)=f(8)+f(7),f(8)=f(7)+f(6)，这样两个，需要算两遍f(7)会有重复计算，效率很低，复杂度是o(2^n)</ul>
<ul>3.现在改变思路，变成o(n)的复杂度，我们从0开始往上去算，这样每一项都只算一次，而且并没有用到递归</ul>
    def Fibonacci(n):
        if n == 0:
            return 0
        if n == 1:
            return 1
        num1,num2 = 1,0
        for i in range(2,n+1):
            sum = num1+num2
            num2 = num1
            num1 = sum
        return sum
<ul>4.这样每输入一个N ，都要重新算一遍，还可以用动态规划，不过那是后面的事情了</ul>

**2.青蛙跳台阶问题**
<ul>1.问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</ul>
<ul>2.这个问题，可以归结为一种斐波那契的应用，设n阶台阶的跳法有 f(n),青蛙在踏出第一步的时候，有两种情况，跳一级，和跳两级，当跳一级时，还剩下n-1级台阶那么此时共剩下 f(n-1)种跳法，当跳二级，还剩下 f(n-2)种，那么可以总结 f(n)=f(n-1)+f(n-2)，最后改造上面的代码即可</ul>

**3.青蛙跳台阶变种**
<ul>1.问题改变：由原来一次性1级或2级，变成任意的n级，每次可以跳n级</ul>
<ul>2.正确思路：和上面一样，第一次跳1级，后面有f(n-1)，跳2级，有f(n-2)，，，，，跳n-1级，有f(1)=1，跳n级，有f(0)=1，也就是f(n)=f(n-1)+f(n-2)....+f(1)+f(0)，，，更加巧的是，刚好是2的n-1次</ul>


<h1>2.7</h1>

**1.位运算**
<ul>1.位运算大概是 与，或，异或，移位，而移位较为麻烦，左移时，右边一律补0，右移时，左边补相应符号位，正就补0，负就补1</ul>
<ul>2. >> 是右移，>>1 效果上等于除以2 ，但是效率速度上比除以要快</ul>

**2.找出二进制数中 1 的个数**
<ul>1.在不使用字符串的前提下，这个问题需要用位运算</ul>
<ul>2.正常思路：利用与运算，将N 和 1 进行与，因为1 除了最后一位，都是0，所以结果如果是1，那么N 的最低位为1，结果为0，最低位就是0，以此类推，将1 左移一位，得到 0010 这样的数，如果结果为2，则该位是1</ul>
	就是N 和 1与，结果 =1 ，最后位就是1
	 1左移，重复
<ul>3.更好的思路，将N 减去 1 ，就可以令最靠后的一个1变成0，它后面的0都变成1，这样的话 ，N*(N-1)就会变成，将N 的最后一个1变成0，前面的不变的效果</ul>
	N & (N-1) 会消去最后一个1

**3.小细节**
<ul>1.反码补码等又忘记了</ul>
<ul>2.做 & 的时候，直接用10进制也可以，不用很麻烦变成二进制</ul>
<ul>3.二进制一般弄到range(0,32)</ul>
<ul>4.N & (N-1) 会消去最后一个1</ul>
<ul>5.python bin(1)=0x1 ，长度为3</ul>

**4.位运算的例子**
<ul>1.判断一个数是不是2的整数次？？2的整数次，就是说，2进制数中只有一个1，这样的话，使用N*(N-1),就会变成0</ul>
<ul>2.有m和n，问要改变多少个二进制位，才能让mn相等？？？？先求异或，不一样就是1，然后统计1的个数</ul>


<ul>2.3</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<ul>2.3</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<ul>2.3</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul>2.3</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>