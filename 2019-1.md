<h1>1.10</h1>

- **空白期总结**
<ul>在拼命复习啊，所幸，付出的还是有结果的，自我感觉考得不错，不会影响下半学期出去实习</ul>

- **近期目标**
<ul>1.github项目都加上readme</ul>
<ul>2.作品集整理</ul>
<ul>3.简历重新修改</ul>

<h1>1.13</h1>

- **效率工程EE笔试**
<ul>1.寻找二叉树左视角的列表，这个很容易，先确定数组长度，在2的几次方之后，根据数组切片，查看相应段的第一个非 # 字符</ul>
<ul>2.岛屿问题，这个以前做过，DFS就行</ul>
<ul>3.做题的时候，遇到了python的 stdin模块，，sys.stdin.readline()就是读一行，就直接结束了，，，while true就一直读了，，win下 ctrl+z就停止了，Linux ctrl+D ，，这时候，就可以 if not line: break
</ul>
<ul>4.sys.stdin和 input 差不多</ul>

- **后续目标**
<ul>1.寒假里，剑指offer</ul>
<ul>2.多投几家公司，由于自己的失误，明明会做的题，在牛客上反而没做出来，这次的字节就是警告，以后一定要注意</ul>


<h1>1.14</h1>

- TCP三次握手名词解释
<ul>1.ACK是一个确认信号，如果一方收到的上一次信息无误，下次传回的包，就是ACK为1，ACK等于0，就是无效包</ul>
<ul>2.SYN，这是一个同步的标志吧，当SYN等于1 ，就说明TCP两方需要同步序列号，也就是说，两方在建立连接，也就是三次握手的前两次</ul>
<ul>3.ack，这是这一端，下次希望收到的序列号</ul>
<ul>4.seq，这是本次包，携带的序列号</ul>

- 三次握手流程
<ul>1.第一步从客户端开始，发一个包，因为有同步序列号的请求，所以SYN=1，没有ACK，seq为i ，接下来，客户端从关闭状态，，到了等待回复的，也就是同步已发送（SYN-SEND）</ul>
<ul>2.然后就是服务端，接收到客户端的包，进行确认，无误，就设置ACK=1，然后因为也是同步，SYN=1，发送自己的开始序列seq=j，这时候服务端就同步完成了，他希望收到客户端seq=i+1 的回复，从关闭状态到SYN-RECV状态</ul>
<ul>3.客户端收到服务端的同步，客户端觉得OK，就变成连接状态，发送ACK=1，由于已经不需要同步，客户端拿到了服务端的seq=j，服务端也相应拿到了i ,所以SYN=0，这是发送i+1,期待j+1</ul>
<ul>4.具体看博客  https://blog.csdn.net/qq_38950316/article/details/81087809</ul>

- 通俗理解
<ul>1.由于TCP是全双工的，两边都要互通数据，所以两边都要知道对方从什么序列号开始，A对B说，我从1开始， B说我知道了，回复A说，B是从100开始的，A收到又说，知道了，，，这就是三次握手</ul>

- 面试问题
<ul>1.为啥是三次握手，不是两次？不是四次？   回答：一种理解是，根据上面的通俗解释，发出的同步序列号，都需要确认，这样最少，就需要三次，两次的话，如果丢包，就不能保证可靠传输。  第二种理解，防止已失效的连接请求又传送到服务器端，因而产生错误，这个我不是很认同。
</ul>

<h1>1.15</h1>

- **杂项**
<ul>1.修改了简历，并分门别类</ul>

- **数据库复习**
<ul>1.外连接，分为左右，，内连接，就是只返回相匹配的项</ul>
<ul> C/S模式，客户端服务端， B/S 浏览器服务端</ul>


<h1>1.16</h1>

- **数据库概论复习**
<ul>1.查询优化，代数优化和物理优化， https://www.jianshu.com/p/edf503a2a1e7</ul>
<ul>2.group by  https://www.cnblogs.com/snsdzjlz320/p/5738226.html ，最关键是这个GROUP_CONCAT</ul>
<ul>3.常用的mysql操作  https://www.cnblogs.com/123456789qq/p/5891289.html</ul>

- **寒假目标**
<ul>1.把自己曾经的想法都落实一遍</ul>
<ul>2.剑指offer的算法，和面经</ul>

<h1>1.18</h1>
<ul>1.单元测试怎么写的？？</ul>
<ul>2.断点，单步跟踪，查看内存，分析调用栈</ul>
<ul>3.代码鲁棒</ul>
<ul>4.边界条件，特殊输入，错误处理</ul>



<h1>1.19</h1>
<ul>1.用python实现hashmap</ul>
<ul>2.行排序，列也排序，寻找值</ul>
<ul>3.赛码</ul>

<h1>1.20</h1>

- **hash 的再学习**
<ul>hash需要解决的两个问题：1.映射出来的索引尽量集中，不要浪费过多的内存  2.减少映射冲突</ul>
<ul>1.直接定址法，直接用key本身，或者key 的线性函数，来做索引，这样只要key不同，就不会有冲突，但是这样，索引会很散，申请的内存大小会很大</ul>
<ul>2.除留余数法，假设hash表的大小定为 N ，这时候找一个小于N 但又接近N 的最大素数 P，key对P 取余，就是索引，这个方法，内存占用小，因为取余之后映射到了 0-N 这一块，但是还是会有冲突</ul>
<ul>3.平均查找长度，就是每一个元素查找的长度，除以元素个数</ul>
<ul>4.线性探测法，二次探测法，链表法</ul>

<h1>1.21</h1>

- 面试题3
<ul>1.python 的二维数组使用 list 中套 list 来实现的，但是List 本身不能对二维数组进行切片，要先转化为numpy 数组，进行[:,:,:]</ul>
<ul>2.& 是且的意思，但是python里直接用 and 和 or 关键字</ul>
<ul>3.这道题，就是找一个特殊的位置，比如右上角，是一行的最大和一列的最小，逐步筛小范围</ul>


<h1>1.23</h1>

- **aigen面试**
<ul>1.首先自我介绍，随后让我自己说了下做过的项目</ul>
<ul>2.回顾了笔试的瑕疵，指出了点小问题</ul>
<ul>3.给了道题，二叉树的右视角的点，这道题的思路是右子树的右视图，加上左子树超过右子树长度的右视图</ul>

- **网易游戏的准备**
	- 计算机网络
	<ul>1.TCP/UDP的概念</ul>
	<ul>2.TCP三次握手，和四次挥手的具体细节</ul>
	<ul>3.TCP/UDP 的上层协议有哪些和应用场景：tcp有http，HTTPS,FTP,SMTP,POP3.SSH,场景大概是文件传输，邮件传输，浏览器，，，udp有snmp,dhcp,ntp,场景有语音啊，视频，直播</ul>
	<ul>4.DNS在域名解析时候，用的是udp,区域传输用的是tcp</ul>
	<ul>5.http是明文传输，https使用了证书，还有ssl加密</ul>
<ul></ul>
<ul></ul>
<ul></ul>

	
	- 操作系统
	<ul>1.进程和线程的概念和区别：进程是资源分配的最小单位，线程是程序执行的最小单位。进程有自己的独立的地址空间，但是线程之间共享相同的地址空间</ul>
	<ul>2.进程间的通信和线程中的资源共享：线程之间通信，就是互斥和同步，互斥指共享资源的独占使用，同步是说，一个线程等待另一个线程的唤醒，，，，全局变量是win32用的最多的多线程通信方式。。。。进程间：无名管道pipe（亲缘关系），有名管道（允许无亲缘关系），消息队列，信号量，套接字socket，信号，共享内存（最快速，因为进程可以直接读写内存，而不需要任何数据的拷贝）</ul>
	<ul>3.解决互锁，synchronized（塞酷睿Nice特）等待唤醒的同步机制</ul>

	- 网络编程
	<ul>1.select epoll等等的区别：select的几大缺点：

（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

（3）select支持的文件描述符数量太小了，默认是1024</ul>

	- 算法，数据结构
	<ul>1.各种排序，快排等</ul>
	<ul>2.二叉树</ul>


<h1>1.24</h1>

- 自我介绍
- 语言基础
<ul>问我主要会啥，我说python，就开始问了</ul>
<ul>1.Python导包的加载顺序</ul>
<ul>2.python命名空间</ul>
<ul>3.值传递，还是引用传递，本子上有例题</ul>
<ul>4.__init__和__new__有什么区别</ul>
<ul>5.__delete__，还有python对象的生成和销毁</ul>
<ul>6.作用域，闭包</ul>
<ul>7.python多线程等等，多线程适合io密集吗，还是cpu密集？？</ul>
<ul>8.python 实现单例</ul>
<ul>9.垃圾回收机制</ul>
<ul>10.除了global以外，还有什么</ul>
<ul>11.项目中，导包使用相对路径好还是绝对路径好</ul>

- 数据库
<ul>1.用的什么数据库</ul>
<ul>2.数据库引擎之间有什么区别</ul>
<ul>3.有哪些数据库索引，具体讲一下</ul>
<ul>4.orm？很复杂的orm你怎么写，还有有哪些具体的API</ul>
<ul>5.怎么分析，sql语句的时长</ul>
<ul>6.怎么优化查询，当一个查询语句时间很长，怎么分析</ul>
<ul>7.查看有那些慢查询</ul>
<ul></ul>


<h1>1.25</h1>

- 面试问题回顾解答<br>
-
**1.Python导包的加载顺序？**
<ul>python解释器会预先加载sys.builtin_module_names，和sys.modules这些字典里存放的模块，比如os，，然后再加载sys.path里的路径下的模块，，sys.path中：1.当前文件目录  2.python安装目录PYTHONPATH  3.默认的，比如unix下就是/usr/local/lib/python/，，，，这里有个例子，如果当前目录下有个os.py，此时导入import os，还是自带的，因为sys.modules里头有，预先加载了，这时候del sys.modules['os']，就会加载当前目录下的</ul>

**2.from x import x 和 import x有什么不同**
<ul>每个py文件就是一个对象，import到对象层次，没啥区别，到里面的方法，也是没区别。。。。后面是重点，import 最深就是到方法，不可以import到变量，但from import 可以，这时候就是一种深拷贝，深复制，数据是独立的，，，，但是另外的，比如import到该文件这个层次，或者from import到这个层次，就还是浅复制，是一种引用，是会改变的，，，，，，，，，，，，，，，，，总结一下，就是from import到变量，是一种深复制</ul>

**3. `_file_` 变量？**
<ul>该 _file_ 变量，python test.py这样执行，_file_ 就是test.py ，，python /ussr/test.py 这时候就是/usr/test.py 用相对路径就是相对，用绝对就是绝对，，，该变量通常用来 比如 os.path.dirname(__file__)</ul>


<h1>1.26</h1>

- 面试问题回顾解答<br>
-
**1.Python命名空间？**
<ul>1.函数内部有命名空间，该模块全局也有命名空间，最后还有内置的命名空间，对所有都是生效的，主要是这三块</ul>
<ul>2.查找顺序，从内到外，先函数内部命名空间，然后是外头的模块命名空间，最后是内置，一层一层找，全都找不到就是 not defined，，，，要注意，不同命名空间的命名没有任何关系，即使是同名</ul>
<ul>3.**global**这个关键字，一旦声明，就代表该变量在模块的全局命名空间里，以后一旦用到，就是直接在外面的命名空间里找，修改赋值也都成立</ul>

	i=1

	def foo():

		print i  # 这一步报错

		i=2

		print i
	---------------------------
	UnboundLocalError: local variable 'i' referenced before assignment



<ul>上面代码，由于函数中 i=2 ，所以函数内部命名空间中有 i 的存在，第一次 print 的时候，查找，在内部中查找到了，但是还没有赋值，所以报错</ul>
<ul>4. locals()和global() ，前者是内部命名空间key-vlaue的字典，后者则是全局的，，而且前者locals()["x"]=5 类似这样的改变不生效，是不可变的，而globals是可变的</ul>
<ul>5.引出from x import 和import 的另一个区别，import 进来，但是还是保留着自己的命名空间，所以要用sklearn.data 这样的模块名做前缀，但是from import 则是把自己的命名空间都融入进来了，所以不用</ul>
<ul>6.各命名空间创建顺序：python解释器启动 ->创建内建命名空间 -> 加载模块 -> 创建全局命名空间 ->函数被调用 ->创建局部命名空间</ul>
<ul>7.各命名空间销毁顺序：函数调用结束 -> 销毁函数对应的局部命名空间 -> python虚拟机（解释器）退出 ->销毁全局命名空间 ->销毁内建命名空间</ul>
<ul>8.像if ，for，while 都是块级作用域，是属于全局命名空间的，没有自己的命名空间</ul>
<ul>9.nonlocal和global的区别：第一，两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。

第二，两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误</ul>

**2.闭包？**
<ul>https://www.cnblogs.com/JohnABC/p/4076855.html</ul>

**3.`__new__`和`__init__`，还有python对象的创建，初始化，销毁?**
<ul>1.python的对象周期：创建__new__，初始化__init__，回收__del__</ul>
<ul>2.__new__方法在__init__之前，而且需要返回值，__new__若无指定，则会返回父类的__new__方法，会一直追溯到object基类，，而且有一点，如果某类的__new__返回的不是自身的实例，就不会调用自身的__init__，返回的是啥，调用的就是啥的__init__</ul>
<ul>3.__del__在对象被回收的时候调用</ul>
<ul>4.__new__(cls,*args, **kwargs) 其中的cls，是python解释器自己填充的，就是自身类的，比如<class '__main__.B'>，后面还需要return，return是啥，才是真的，可以使用type()来查看</ul>
<ul>5.介绍__new__,链接：`https://www.cnblogs.com/tuzkee/p/3540293.html`,`http://www.cnblogs.com/ifantastic/p/3175735.html`</ul>
<ul>6.__new__的用途：12.用来实现一些对基本类型的封装，比如自己实现一个转化成大写的类 2.实现单例</ul>

**4.python类的一些内置方法**
<ul>1.__call__:实例出来的对象，加了括号被当做方法来使用的时候，就会被调用</ul>
<ul>2.https://blog.csdn.net/techml/article/details/72626519</ul>
<ul>3.https://blog.csdn.net/sj349781478/article/details/79546806</ul>

**5.python实现单例模式？**


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>