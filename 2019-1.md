<h1>1.10</h1>

- **空白期总结**
<ul>在拼命复习啊，所幸，付出的还是有结果的，自我感觉考得不错，不会影响下半学期出去实习</ul>

- **近期目标**
<ul>1.github项目都加上readme</ul>
<ul>2.作品集整理</ul>
<ul>3.简历重新修改</ul>

<h1>1.13</h1>

- **效率工程EE笔试**
<ul>1.寻找二叉树左视角的列表，这个很容易，先确定数组长度，在2的几次方之后，根据数组切片，查看相应段的第一个非 # 字符</ul>
<ul>2.岛屿问题，这个以前做过，DFS就行</ul>
<ul>3.做题的时候，遇到了python的 stdin模块，，sys.stdin.readline()就是读一行，就直接结束了，，，while true就一直读了，，win下 ctrl+z就停止了，Linux ctrl+D ，，这时候，就可以 if not line: break
</ul>
<ul>4.sys.stdin和 input 差不多</ul>

- **后续目标**
<ul>1.寒假里，剑指offer</ul>
<ul>2.多投几家公司，由于自己的失误，明明会做的题，在牛客上反而没做出来，这次的字节就是警告，以后一定要注意</ul>


<h1>1.14</h1>

- TCP三次握手名词解释
<ul>1.ACK是一个确认信号，如果一方收到的上一次信息无误，下次传回的包，就是ACK为1，ACK等于0，就是无效包</ul>
<ul>2.SYN，这是一个同步的标志吧，当SYN等于1 ，就说明TCP两方需要同步序列号，也就是说，两方在建立连接，也就是三次握手的前两次</ul>
<ul>3.ack，这是这一端，下次希望收到的序列号</ul>
<ul>4.seq，这是本次包，携带的序列号</ul>

- 三次握手流程
<ul>1.第一步从客户端开始，发一个包，因为有同步序列号的请求，所以SYN=1，没有ACK，seq为i ，接下来，客户端从关闭状态，，到了等待回复的，也就是同步已发送（SYN-SEND）</ul>
<ul>2.然后就是服务端，接收到客户端的包，进行确认，无误，就设置ACK=1，然后因为也是同步，SYN=1，发送自己的开始序列seq=j，这时候服务端就同步完成了，他希望收到客户端seq=i+1 的回复，从关闭状态到SYN-RECV状态</ul>
<ul>3.客户端收到服务端的同步，客户端觉得OK，就变成连接状态，发送ACK=1，由于已经不需要同步，客户端拿到了服务端的seq=j，服务端也相应拿到了i ,所以SYN=0，这是发送i+1,期待j+1</ul>
<ul>4.具体看博客  https://blog.csdn.net/qq_38950316/article/details/81087809</ul>

- 通俗理解
<ul>1.由于TCP是全双工的，两边都要互通数据，所以两边都要知道对方从什么序列号开始，A对B说，我从1开始， B说我知道了，回复A说，B是从100开始的，A收到又说，知道了，，，这就是三次握手</ul>

- 面试问题
<ul>1.为啥是三次握手，不是两次？不是四次？   回答：一种理解是，根据上面的通俗解释，发出的同步序列号，都需要确认，这样最少，就需要三次，两次的话，如果丢包，就不能保证可靠传输。  第二种理解，防止已失效的连接请求又传送到服务器端，因而产生错误，这个我不是很认同。
</ul>

<h1>1.15</h1>

- **杂项**
<ul>1.修改了简历，并分门别类</ul>

- **数据库复习**
<ul>1.外连接，分为左右，，内连接，就是只返回相匹配的项</ul>
<ul> C/S模式，客户端服务端， B/S 浏览器服务端</ul>


<h1>1.16</h1>

- **数据库概论复习**
<ul>1.查询优化，代数优化和物理优化， https://www.jianshu.com/p/edf503a2a1e7</ul>
<ul>2.group by  https://www.cnblogs.com/snsdzjlz320/p/5738226.html ，最关键是这个GROUP_CONCAT</ul>
<ul>3.常用的mysql操作  https://www.cnblogs.com/123456789qq/p/5891289.html</ul>

- **寒假目标**
<ul>1.把自己曾经的想法都落实一遍</ul>
<ul>2.剑指offer的算法，和面经</ul>

<h1>1.18</h1>
<ul>1.单元测试怎么写的？？</ul>
<ul>2.断点，单步跟踪，查看内存，分析调用栈</ul>
<ul>3.代码鲁棒</ul>
<ul>4.边界条件，特殊输入，错误处理</ul>



<h1>1.19</h1>
<ul>1.用python实现hashmap</ul>
<ul>2.行排序，列也排序，寻找值</ul>
<ul>3.赛码</ul>

<h1>1.20</h1>

- **hash 的再学习**
<ul>hash需要解决的两个问题：1.映射出来的索引尽量集中，不要浪费过多的内存  2.减少映射冲突</ul>
<ul>1.直接定址法，直接用key本身，或者key 的线性函数，来做索引，这样只要key不同，就不会有冲突，但是这样，索引会很散，申请的内存大小会很大</ul>
<ul>2.除留余数法，假设hash表的大小定为 N ，这时候找一个小于N 但又接近N 的最大素数 P，key对P 取余，就是索引，这个方法，内存占用小，因为取余之后映射到了 0-N 这一块，但是还是会有冲突</ul>
<ul>3.平均查找长度，就是每一个元素查找的长度，除以元素个数</ul>
<ul>4.线性探测法，二次探测法，链表法</ul>

<h1>1.21</h1>

- 面试题3
<ul>1.python 的二维数组使用 list 中套 list 来实现的，但是List 本身不能对二维数组进行切片，要先转化为numpy 数组，进行[:,:,:]</ul>
<ul>2.& 是且的意思，但是python里直接用 and 和 or 关键字</ul>
<ul>3.这道题，就是找一个特殊的位置，比如右上角，是一行的最大和一列的最小，逐步筛小范围</ul>


<h1>1.23</h1>

- **aigen面试**
<ul>1.首先自我介绍，随后让我自己说了下做过的项目</ul>
<ul>2.回顾了笔试的瑕疵，指出了点小问题</ul>
<ul>3.给了道题，二叉树的右视角的点，这道题的思路是右子树的右视图，加上左子树超过右子树长度的右视图</ul>

- **网易游戏的准备**
	- 计算机网络
	<ul>1.TCP/UDP的概念</ul>
	<ul>2.TCP三次握手，和四次挥手的具体细节</ul>
	<ul>3.TCP/UDP 的上层协议有哪些和应用场景：tcp有http，HTTPS,FTP,SMTP,POP3.SSH,场景大概是文件传输，邮件传输，浏览器，，，udp有snmp,dhcp,ntp,场景有语音啊，视频，直播</ul>
	<ul>4.DNS在域名解析时候，用的是udp,区域传输用的是tcp</ul>
	<ul>5.http是明文传输，https使用了证书，还有ssl加密</ul>
<ul></ul>
<ul></ul>
<ul></ul>

	
	- 操作系统
	<ul>1.进程和线程的概念和区别：进程是资源分配的最小单位，线程是程序执行的最小单位。进程有自己的独立的地址空间，但是线程之间共享相同的地址空间</ul>
	<ul>2.进程间的通信和线程中的资源共享：线程之间通信，就是互斥和同步，互斥指共享资源的独占使用，同步是说，一个线程等待另一个线程的唤醒，，，，全局变量是win32用的最多的多线程通信方式。。。。进程间：无名管道pipe（亲缘关系），有名管道（允许无亲缘关系），消息队列，信号量，套接字socket，信号，共享内存（最快速，因为进程可以直接读写内存，而不需要任何数据的拷贝）</ul>
	<ul>3.解决互锁，synchronized（塞酷睿Nice特）等待唤醒的同步机制</ul>

	- 网络编程
	<ul>1.select epoll等等的区别：select的几大缺点：

（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

（3）select支持的文件描述符数量太小了，默认是1024</ul>

	- 算法，数据结构
	<ul>1.各种排序，快排等</ul>
	<ul>2.二叉树</ul>


<h1>1.24</h1>

- 自我介绍
- 语言基础
<ul>问我主要会啥，我说python，就开始问了</ul>
<ul>1.Python导包的加载顺序</ul>
<ul>2.python命名空间</ul>
<ul>3.值传递，还是引用传递，本子上有例题</ul>
<ul>4.__init__和__new__有什么区别</ul>
<ul>5.__delete__，还有python对象的生成和销毁</ul>
<ul>6.作用域，闭包</ul>
<ul>7.python多线程等等，多线程适合io密集吗，还是cpu密集？？</ul>
<ul>8.python 实现单例</ul>
<ul>9.垃圾回收机制</ul>
<ul>10.除了global以外，还有什么</ul>
<ul>11.项目中，导包使用相对路径好还是绝对路径好</ul>

- 数据库
<ul>1.用的什么数据库</ul>
<ul>2.数据库引擎之间有什么区别</ul>
<ul>3.有哪些数据库索引，具体讲一下</ul>
<ul>4.orm？很复杂的orm你怎么写，还有有哪些具体的API</ul>
<ul>5.怎么分析，sql语句的时长</ul>
<ul>6.怎么优化查询，当一个查询语句时间很长，怎么分析</ul>
<ul>7.查看有那些慢查询</ul>
<ul>8.mysql数据类型</ul>


<h1>1.25</h1>

- 面试问题回顾解答<br>
-
**1.Python导包的加载顺序？**
<ul>python解释器会预先加载sys.builtin_module_names，和sys.modules这些字典里存放的模块，比如os，，然后再加载sys.path里的路径下的模块，，sys.path中：1.当前文件目录  2.python安装目录PYTHONPATH  3.默认的，比如unix下就是/usr/local/lib/python/，，，，这里有个例子，如果当前目录下有个os.py，此时导入import os，还是自带的，因为sys.modules里头有，预先加载了，这时候del sys.modules['os']，就会加载当前目录下的</ul>

**2.from x import x 和 import x有什么不同**
<ul>每个py文件就是一个对象，import到对象层次，没啥区别，到里面的方法，也是没区别。。。。后面是重点，import 最深就是到方法，不可以import到变量，但from import 可以，这时候就是一种深拷贝，深复制，数据是独立的，，，，但是另外的，比如import到该文件这个层次，或者from import到这个层次，就还是浅复制，是一种引用，是会改变的，，，，，，，，，，，，，，，，，总结一下，就是from import到变量，是一种深复制</ul>

**3. `_file_` 变量？**
<ul>该 _file_ 变量，python test.py这样执行，_file_ 就是test.py ，，python /ussr/test.py 这时候就是/usr/test.py 用相对路径就是相对，用绝对就是绝对，，，该变量通常用来 比如 os.path.dirname(__file__)</ul>


<h1>1.26</h1>

- 面试问题回顾解答<br>
-
**1.Python命名空间？**
<ul>1.函数内部有命名空间，该模块全局也有命名空间，最后还有内置的命名空间，对所有都是生效的，主要是这三块</ul>
<ul>2.查找顺序，从内到外，先函数内部命名空间，然后是外头的模块命名空间，最后是内置，一层一层找，全都找不到就是 not defined，，，，要注意，不同命名空间的命名没有任何关系，即使是同名</ul>
<ul>3.**global**这个关键字，一旦声明，就代表该变量在模块的全局命名空间里，以后一旦用到，就是直接在外面的命名空间里找，修改赋值也都成立</ul>

	i=1

	def foo():

		print i  # 这一步报错

		i=2

		print i
	---------------------------
	UnboundLocalError: local variable 'i' referenced before assignment



<ul>上面代码，由于函数中 i=2 ，所以函数内部命名空间中有 i 的存在，第一次 print 的时候，查找，在内部中查找到了，但是还没有赋值，所以报错</ul>
<ul>4. locals()和global() ，前者是内部命名空间key-vlaue的字典，后者则是全局的，，而且前者locals()["x"]=5 类似这样的改变不生效，是不可变的，而globals是可变的</ul>
<ul>5.引出from x import 和import 的另一个区别，import 进来，但是还是保留着自己的命名空间，所以要用sklearn.data 这样的模块名做前缀，但是from import 则是把自己的命名空间都融入进来了，所以不用</ul>
<ul>6.各命名空间创建顺序：python解释器启动 ->创建内建命名空间 -> 加载模块 -> 创建全局命名空间 ->函数被调用 ->创建局部命名空间</ul>
<ul>7.各命名空间销毁顺序：函数调用结束 -> 销毁函数对应的局部命名空间 -> python虚拟机（解释器）退出 ->销毁全局命名空间 ->销毁内建命名空间</ul>
<ul>8.像if ，for，while 都是块级作用域，是属于全局命名空间的，没有自己的命名空间</ul>
<ul>9.nonlocal和global的区别：第一，两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。

第二，两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误</ul>

**2.闭包？**
<ul>https://www.cnblogs.com/JohnABC/p/4076855.html</ul>

**3.`__new__`和`__init__`，还有python对象的创建，初始化，销毁?**
<ul>1.python的对象周期：创建__new__，初始化__init__，回收__del__</ul>
<ul>2.__new__方法在__init__之前，而且需要返回值，__new__若无指定，则会返回父类的__new__方法，会一直追溯到object基类，，而且有一点，如果某类的__new__返回的不是自身的实例，就不会调用自身的__init__，返回的是啥，调用的就是啥的__init__</ul>
<ul>3.__del__在对象被回收的时候调用</ul>
<ul>4.__new__(cls,*args, **kwargs) 其中的cls，是python解释器自己填充的，就是自身类的，比如<class '__main__.B'>，后面还需要return，return是啥，才是真的，可以使用type()来查看</ul>
<ul>5.介绍__new__,链接：`https://www.cnblogs.com/tuzkee/p/3540293.html`,`http://www.cnblogs.com/ifantastic/p/3175735.html`</ul>
<ul>6.__new__的用途：12.用来实现一些对基本类型的封装，比如自己实现一个转化成大写的类 2.实现单例</ul>

**4.python类的一些内置方法**
<ul>1.__call__:实例出来的对象，加了括号被当做方法来使用的时候，就会被调用</ul>
<ul>2.https://blog.csdn.net/techml/article/details/72626519</ul>
<ul>3.https://blog.csdn.net/sj349781478/article/details/79546806</ul>



<h1>1.27</h1>
- 面试问题回顾解答<br>
-
**1.python 实现单例模式？**

	class Singleton(object):
	    _instance_lock = threading.Lock()
	
	    def __init__(self):
	        pass
	
	
	    def __new__(cls, *args, **kwargs):
	        if not hasattr(Singleton, "_instance"):
	            with Singleton._instance_lock:
	                if not hasattr(Singleton, "_instance"):
	                    Singleton._instance = object.__new__(cls)  
	        return Singleton._instance
<ul>上述代码使用__new__来实现单例，顺带解决了线程安全</ul>
<ul>还有好多，存在收藏夹里，有空再看</ul>

**2.python内存管理？？？**
<ul>对于整数和短的字符串,Python都会缓存这些对象，比如a=1,b=1，两者的id()都是一样的，都只是对 1 这个对象的引用</ul>
<ul>2.比如list，dict之类，里面的元素，就是引用</ul>

**3.python垃圾回收？？**
<ul>1.python的GC算法分两块，一个是引用数，另一个是分代收集机制</ul>
<ul>2.首先，python中一切都是对象，在C的底层实现中，都是一个结构体，pyObject，里面有一个引用数，每当比如，赋值，这种引用操作的时候，引用数就从1开始增加，减少引用就减少引用数，一旦检测到引用数为0，就直接回收</ul>
<ul>3.但是有些情况，比如循环的数据结构，或者你引用了我，我也引用了你（双端链表），这种情况就算这两个对象没有被外部调用，但是他们还彼此引用，引用数就不会变成0，不会被引用数机制回收，甚至重复这种操作，就会内存泄漏，这时候就用到分代收集机制</ul>
<ul>4.特殊情况：作为参数被函数调用，就是被引用两次</ul>
<ul>5.链接`https://www.cnblogs.com/Xjng/p/5128269.html`,`https://www.jianshu.com/p/22a8bedc39fd`</ul>
<ul>6.GC算法？？？</ul>

**4.python是值传递还是引用传递？？**
<ul>1.一般来说，值传递就是传进去的就是一个数据的副本，函数里修改对外面的数据没影响，引用传递就是对外面有影响的，，，但是在Python里面大错特错</ul>
<ul>2.python函数的参数，其实就是接收了一个引用，这个参数和外面的一样，都是一个对象的一份引用，这个可以用过id()查看，，，传进来的是一个可变对象的引用。比如是列表啊，字典的引用，这样修改字典里的内容是生效的，因为里面存的本身就是引用，并没有修改字典本身id，，，，如果传进来是不可变对象的引用，比如int 整数，这时候修改，其实就是函数内部的该引用指向了另一个对象，外面的那个引用不受影响</ul>
<ul>3.总结，python没有真正的值传递和引用传递（地址传递），不要被C语言的所误导 链接：https://www.cnblogs.com/loleina/p/5276918.html</ul>


<h1>1.28</h1>
- 面试问题回顾解答<br>
-
**1.python GIL全局解释器锁**
<ul>1.GIL是cpython解释器带来的概念，就是说，单核CPU下，多线程其实是串行的，程序必须拿到GIL锁，才能抢占到CPU，所以python的多线程是假的，同一时刻只有一个线程可以执行代码</ul>
<ul>2.解决GIL：1.因为是cpython带来的，换个解释器就好了比如jython,pypy   2.用多进程代替多线程 3.多线程部分用C来实现</ul>
<ul>3.GIL锁的释放：1.I/O阻塞了，CPU空闲，会释放 2.有一个ticket，当ticket为100，会释放GIL，ticket的阈值可以自己设，不一定100</ul>
<ul>4.GIL和线程互斥锁是不一样的：GIL是对CPU抢占的锁，互斥锁是对多线程共享变量抢占的锁，链接：https://blog.csdn.net/weixin_41594007/article/details/79485847</ul>

**2.Python多线程？**
<ul>1.cpu密集型和I/O密集型：cpu密集型的，适合用C语言之类的多线程，I/O密集的适合开发效率更高的脚本语言，比如python</ul>
<ul>2.对于python自己而言，因为python实在是太慢了又有GIL，所以对于CPU密集，python使用多进程，io密集型使用多线程，</ul>
<ul>3.链接：https://www.cnblogs.com/tkqasn/p/5700281.html</ul>

**3.python慢的原因？**
<ul>1.由于是动态语言，有很多动态类型的转换</ul>
<ul>2.GIL</ul>



<h1>1.29</h1>
- 面试问题回顾解答<br>
-
**1.mysql数据库引擎**
链接: `https://www.cnblogs.com/0201zcr/p/5296843.html`,`https://www.cnblogs.com/zhangjinghe/p/7599988.html`
<ul>1.mysql常见的引擎主要有 ISAM,MyISAM,HEAP,InnoDB,BDB，，这些主要分两大类ISAM,MyISAM,HEAP和InnoDB,BDB，前一类不支持事务和外来键，后一类支持</ul>
<ul>ISAM：查询速度远快于更新速度，但是不支持事务和容错，数据恢复，万一硬盘崩了，数据不能恢复</ul>
<ul>MyISAM：ISAM的升级版，增加了索引和字段管理，对多个并发读写有奇效，但还是没有事务和容错</ul>
<ul>HEAP：同样没有事务和容错，而且因为数据是存在内存里的，所以速度特别特别快，但是关机前不保存，数据就都没了</ul>
<ul>InnoDB：实现了事务和外来键等高级数据库功能，但是相应的，速度就比MYISAM要慢得多（BDB差不多）</ul>




<h1>1.30</h1>
- 自我收获<br>
-
**1.mysql**
<ul>1.MySQL在创建主键的时候，自动有了聚集索引</ul>
		建表语句
		CREATE TABLE `table_name` (  
		`id` mediumint(8) NOT NULL AUTO_INCREMENT,  
		`name` varchar(30) NOT NULL,  
		`type` mediumint(1) NOT NULL,  
		`code` text,  
		PRIMARY KEY (`id`),  
		KEY `type` (`type`)  
		);  
<ul>2.概念辨析：key和index。总的来说，key是数据库的物理结构，他实现了两种含义：1.约束 2.索引。打个比方，primary key 他一方面是约束条件，设定了主键，另一方面，有建立了一个主键索引，以此类推</ul>
<ul>3.mysql常见索引：主键索引(primary)、唯一索引(unique)、普通索引、全文索引(fulltext)、组合索引(建立索引的时候，把多个组合起来)</ul>
<ul>4.unique索引，唯一索引，允许有空值，而primary 索引是一种特殊的唯一索引，不允许空值</ul>
<ul>5.组合索引，有一个左匹配机制，比如index index_name(a,b,c)，这样就相当于做了a,ab,abc三个索引</ul>
<ul>n.desc，explain + 语句，show keys/index from</ul>
	比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;
	
	如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效
	
	率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,
	
	salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀
	
	特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。

- 面试问题回顾解答<br>
- 
**2.数据库索引**
<ul>1.常用的数据库索引结构有：B+树，B-树，HASH散列</ul>
<ul>HASH索引，本质上还是用了hash的算法，所以直接查询会很快，但是hash是不排序的，所以范围查找，还有模糊查找（本质上是范围查询），这些查询都不管用</ul>
<ul>2.创建索引的注意事项和优化方法，很有用：https://www.cnblogs.com/sweet521/p/6203360.html</ul>

<ul>https://www.cnblogs.com/aspwebchh/p/6652855.html</ul>
<ul>还涉及平衡二叉树</ul>

**2.非聚集索引和聚集索引**
<ul>聚集索引：就是指，物理顺序和逻辑顺序一致，就是说，逻辑中在后面的，物理的地址也在后面，，一般是指主键的那一列，而且一张表，只有一个聚集索引，通过聚集索引，可以查询到这个的所有列的数据</ul>
<ul>非聚集索引：物理顺序和逻辑顺序不一致，一般就是非主键的，一张表里面可以有多个，，，但是，非聚集只存着相关列的数据，和主键列的数据，不在相关列的数据，需要进行二次查询，二次查询的时候就会用到保存的主键列的数据来做聚集索引上的查询</ul>
<ul>对应mysql ，聚集索引基本就是主键索引，非聚集索引有普通索引，唯一索引，全局索引</ul>


<h1>1.31</h1>

mysql阶段总结<br>
-

<ul>首先是数据库引擎，最主要的是myisam和innodb，两边特点不用多说，还有他们相应的应用场景，然后是索引，按照结构分，有B+，B-树，有hash索引，按照用途类型分，有主键，唯一，普通，全文，组合，最后按照大的定义分，还有聚集索引和非聚集索引</ul>
<ul>看到一个小伙子的博客，有很多面试的东西https://me.csdn.net/sjyttkl</ul>

