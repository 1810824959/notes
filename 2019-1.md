<h1>1.10</h1>

- **空白期总结**
<ul>在拼命复习啊，所幸，付出的还是有结果的，自我感觉考得不错，不会影响下半学期出去实习</ul>

- **近期目标**
<ul>1.github项目都加上readme</ul>
<ul>2.作品集整理</ul>
<ul>3.简历重新修改</ul>

<h1>1.13</h1>

- **效率工程EE笔试**
<ul>1.寻找二叉树左视角的列表，这个很容易，先确定数组长度，在2的几次方之后，根据数组切片，查看相应段的第一个非 # 字符</ul>
<ul>2.岛屿问题，这个以前做过，DFS就行</ul>
<ul>3.做题的时候，遇到了python的 stdin模块，，sys.stdin.readline()就是读一行，就直接结束了，，，while true就一直读了，，win下 ctrl+z就停止了，Linux ctrl+D ，，这时候，就可以 if not line: break
</ul>
<ul>4.sys.stdin和 input 差不多</ul>

- **后续目标**
<ul>1.寒假里，剑指offer</ul>
<ul>2.多投几家公司，由于自己的失误，明明会做的题，在牛客上反而没做出来，这次的字节就是警告，以后一定要注意</ul>


<h1>1.14</h1>

- TCP三次握手名词解释
<ul>1.ACK是一个确认信号，如果一方收到的上一次信息无误，下次传回的包，就是ACK为1，ACK等于0，就是无效包</ul>
<ul>2.SYN，这是一个同步的标志吧，当SYN等于1 ，就说明TCP两方需要同步序列号，也就是说，两方在建立连接，也就是三次握手的前两次</ul>
<ul>3.ack，这是这一端，下次希望收到的序列号</ul>
<ul>4.seq，这是本次包，携带的序列号</ul>

- 三次握手流程
<ul>1.第一步从客户端开始，发一个包，因为有同步序列号的请求，所以SYN=1，没有ACK，seq为i ，接下来，客户端从关闭状态，，到了等待回复的，也就是同步已发送（SYN-SEND）</ul>
<ul>2.然后就是服务端，接收到客户端的包，进行确认，无误，就设置ACK=1，然后因为也是同步，SYN=1，发送自己的开始序列seq=j，这时候服务端就同步完成了，他希望收到客户端seq=i+1 的回复，从关闭状态到SYN-RECV状态</ul>
<ul>3.客户端收到服务端的同步，客户端觉得OK，就变成连接状态，发送ACK=1，由于已经不需要同步，客户端拿到了服务端的seq=j，服务端也相应拿到了i ,所以SYN=0，这是发送i+1,期待j+1</ul>
<ul>4.具体看博客  https://blog.csdn.net/qq_38950316/article/details/81087809</ul>

- 通俗理解
<ul>1.由于TCP是全双工的，两边都要互通数据，所以两边都要知道对方从什么序列号开始，A对B说，我从1开始， B说我知道了，回复A说，B是从100开始的，A收到又说，知道了，，，这就是三次握手</ul>

- 面试问题
<ul>1.为啥是三次握手，不是两次？不是四次？   回答：一种理解是，根据上面的通俗解释，发出的同步序列号，都需要确认，这样最少，就需要三次，两次的话，如果丢包，就不能保证可靠传输。  第二种理解，防止已失效的连接请求又传送到服务器端，因而产生错误，这个我不是很认同。
</ul>

<h1>1.15</h1>

- **杂项**
<ul>1.修改了简历，并分门别类</ul>

- **数据库复习**
<ul>1.外连接，分为左右，，内连接，就是只返回相匹配的项</ul>
<ul> C/S模式，客户端服务端， B/S 浏览器服务端</ul>


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>