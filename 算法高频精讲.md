
---
<h1>第一章</h1>

1.A,B先后从数组首或尾取数字，求最后和更大的是谁，是多少？

	##递归思路1
	写两个递归函数，模拟先拿和后拿的过程，f(arr,a,b)和s(xxx)。

	f先拿中，a=b，就只有一个，先拿就直接拿了，return arr[a]，如果不是，就下一层递归，return max{arr[a]+s(a+1,b)和arr[b]+s(a,b-1)}，一种是拿头的，下一次就是s后拿，另一种是拿尾巴的，也是后拿，两种的下标长度不一样，在结果中选max的

	s后拿，a=b，就一个我还后拿，就是没了，返回0，a不等于b的话，由于后拿，前一个人一定是拿了它的最大。对于本次s来说，能期待的就是len-1后的f先拿，当前s的收益就是f(a,b-1)和f(a+1,b)中的一个，而且选最小的

	##思路1改动态规划
	1.f和s都是a,b起始和终止决定了值，所以是dp二维数组可以确定。
	2.再看终止条件，f是a=b时返回arr[a]，所以在dp数组中横纵坐标一样时又已经确定的值
	3.返回值是f(0,len-1)和s(0,len-1)，所以数组中最后的值是dp[0][len-1]
	4.主体逻辑中，一个坐标，都是看它的下方和左边，所以循环方向，从左到右和从下往上，而且a>b没有意义


2.有效的括号

	##只有()
	弄一个count计数，遍历char数组，左括号就+1,右括号就-1，每次都检查count，小于0就直接false，遍历完之后，再检查count是不是等于0

	##多种括号 {}[]()
	弄一个栈，然后弄一个map，里面存()，{}这样的对应串。开始遍历数组，不管什么左括号，就压入，遇到右括号，就去比对栈最外面的是不是它对应的，不是就false，因为不能括号穿插，遍历完之后，看stack有没有被消耗光

	###题目升级，有效括号的最大长度
	一个字符串，求有效括号的最大长度。

	1.动态规划
	dp数组，每一个位置上都代表，以这里为结尾有效括号的最长是多少，所以，左括号就是0，因为不可能是结尾，遇到右括号，向前看一位，如果是有效的，就跳到有效的之前，判断再前一个是不是能对应的左括号，如果是，dp[i] = dp[i-1]+2，同时找到那个对应的之后，在往前跳一位，看是不是有效的，因为有可能是前面已经有了一部分，也要加进去。其他情况就继续循环
	

3.一个数组，求和为K的最长子数组的长度

	##数组只有正数
	准备双指针，都指向第一个，然后开始右指针滑动，把窗口变大，同时计算sum，当sum=K，记下来，小于K就继续，大于，则说明开头以first起始的数组，已经没有可能，就头指针向后，直到sum<=k为止

	##数组任意
	这题考虑每一个位置作为结尾的情况，第j个位置代表，0到j的总和，比如是sum，前面的第i个位置是k，那么i+1到j的和就是sum-k。让这一段差值等于我们要的值就好
	
	遍历整体数组，一直累加，如果没在map中，就存进去(sum,index)，累加值和它最早出现的index，每次都去找sum-k在不在已有的map里，就可以。
	

3.1 做题技巧

	遇到子串，子数组，等等的题目，首先想到的思路应该是，对每个Index，以它为开头的，以它为结尾的，并判断第i个是不是能从第i-1个推出来



---
<h1>第二章</h1>

1.仅仅使用递归，不使用额外空间，使栈元素逆序

	递归中，对栈进行处理，每一层进来，都pop一下，然后存住，直接进入下一层，递归完了之后再push回来

		def foo()
			i = pop()
			foo(下一层)
			stack.push(i)  //再弄回来

	###本题思路
	先弄一个取出栈底，最底下元素，其他不变的函数。然后写reverse主函数。每一层先取出最底下的，如果剩下的不为空，就进入下一层，递归外面再扔进去


2.求小和

	
3.子数组累加最大和

	搞一个最大值，搞一个cur代表已经加上的累加和，遍历数组，如果cur<0，就置0，否则就加上，每次都迭代比较大小	


4.题目用到单调栈，再学习下

	##单调栈
	维护一个，里面元素只能从大到小的栈，遇到不符合的就弹出，这样，弹出的元素的最近的左边右边的比它大的值就找到了。弹出后还在栈顶的，就是左边最近的，当前的，因为它而弹出的，就是右边的。

	同理，单调递增栈，找的就是最近的比它小的


5.循环数组中，给每个数找出下一个更大的值，没有就-1

	把原数组弄成2倍，就解决了循环的问题，然后遍历数组，使用单调栈



---
<h1>第三章</h1>

1.岛屿问题，一个二维数组中01，1是岛屿，问有几个岛屿

	#dfs
	很经典了，遍历二维数组，遇到1就进入dfs，整个dfs就是从某个点开始，去探索所有的岛屿，经过的岛屿都是0

	##并查集
	并查集就是查询，合并的过程，遍历二维数组，遇到1，就上下左右去找，可以联接的1，最后发挥数量即可


2.并查集

	##应用
	可以解决朋友圈类似问题，但是这个数据结构本身就是为了解决，高效的合并，以及查询操作

	##实现
	准备两个hash表，一个是fathermap，存父子关系，(a,b)代表a的父亲是b，还有一个rankmap，(a,2)代表层级，或者是树高，也可以理解成size大小，在union的时候，那个数量多，就挂在哪个上面

	总共也就两个操作，一个findfather，一个联接union，准备阶段，再把每个元素，都在fathermap中以自己做父亲存下，rankmap中存下1
	
	find函数，先查出当前的父亲是谁，如果不是自身，就father = find(father)递归查，返回就行

	union函数，参数是两个待联接的元素，先分别查出父亲，一样就没事，不一样，就按照层级挂在一边，更改father和rank

	计数操作可以在union中count--

	###简单实现
	一堆数组吧，每个都是-1，根据对应关系，两个元素相关，父亲元素-1，变成-2，子元素从-1变成父亲的index，要知道有几个集合，看有几个负数，要看单独的，看具体是负几

	
	###拓展
	可以还可以用于一些并行计算，比如一个把一份数据切分在两个cpu计算，然后再合起来，抠一下边界，合并就行


2.两个节点的公共祖先节点

	##搜索树
	因为左小右大，如果xy和root相等，root就是xy的最近祖先，如果刚好在左右两边，root也是祖先，如果都在一边，那就是root.left的递归结果

	##普通二叉树
	递归来做，终止条件root,x,y==null，返回null。接下来进入主题，如果root和任一个相等，root就是，然后计算left和right的递归，返回结果null就是没找到。如果左右都不是null，说明左右都找到了，root就是，左边找到了，就看左边的递归结果，右边也是，都找不到，就返回null

	##普通二叉树的，非递归
	就像找寻node的一条路径一样，找出两个点的路径，存在数组或者其他，从头开始比对


3.拓展的

	1.找出指定节点的路径，递归和非递归


---
<h1>第四章</h1>

1.最大子数组乘积

	弄两个变量，imax和imin，保存前面连续的最大值和最小值。遍历数组时，当遇到第i个，arr[i]>0，就乘上imax，或者是本身(imax=0)，如果小于0，就乘上imin，如果等于0，imax和imin都置为0。虽然这样也可以，但是代码长，而且不优雅，没体现算法本身

	##思路
	提到过，子数组这类问题，就去考虑类似第i个为结尾这种情况，从i-1推出第i个，这里，遍历数组，计算第i个为结尾的最大和最小。

	分三种情况，当前数>0，imax*cur，小于0，imin*cur，前面的是小数，或者是0，不值得乘起来，就是本身。所以对于第i个数，只需要比较三个数，imax*cur，imin*cur，cur，三者最大更新为imax，最小更新为imin，每轮都找最大即可

	这里cur=0没有特别考虑，因为既然cur=0，那么imax*cur肯定也是0，归在那一类了


2.最大子矩阵和

	##题目相关
	一个m*n的矩阵，可以找出多少个矩形，一个元素也算。能找出n^2*m^2级别个，因为起点有n*m个，终点也有n*m个。

	能找出多少个正方形，是n*m^2级别，起点是n*m，然后边长是m种

	##题解
	单独一行的最大累加和可以做，那么以第一行的可以做，第12两行的也可以，两行加起来救就行，那么123也行，1234也行，再后面是2，23，234，此类，每轮都算过来。

	实现上
	
	for i to len:  ##这里是起点行
		new int[]   ##用来累加的数组，当做一行来算
		for i=j to len:  ##终点行
			int[] 累加   #比如第一次进来，就只有第一行，j第二次进来，就加上，变成二层
			逻辑

	##分析，优化
	所以是n^2*m的复杂度，如果行数很多，而单独一行很短，那么n大了，导致复杂度很高，可以倒过来，行做列，列做行


3.接水容器最多水

	##
	做过了，算每一格上能存多少水，设置辅助数组


4.两个不交叉数组，累加和最大是多少


5.把一个数组切分为左右两部分，两部分max之差是多少
	


---
<h1>第四章</h1>

1.力扣84，01矩阵中的最大矩形

	一行一行的去算，0就是0，1的话，就和上面的累加起来，每一行都形成一个数组，其实就是形成一个柱状图，再用下面的方法去计算，找出最大值


	1.1 引申：柱状图中的最大矩形，力扣85

	##单调栈做法
	我们可以求，每个位置上，以它为最高的矩形，比如32156，3上面就是自己，2是两个格子，类推。也就是从当前位置向左向右，找到最近的小于它的位置，这个其实就是单调栈，单调的递增栈，遇到小的弹出，找出的就是最近的小的。

	每一轮弹出时，当前高度*（右最小-左最小），更新max即可

	##分治法
	遍历一遍，找出当前最小的位置，用它作为最高，可以有一个矩形，然后左边递归，可以得到一个，右边地柜也可以得到一个	

2.子数组最大值最小值，差值小于K的子数组数量


3.返回相交链表的交点，时间复杂度m+n，不用额外空间

	##暴力
	o(m*n)

	##hashset法
	o(m*n)，空间复杂度o(m)

	##尾巴对齐
	两个链表，m和n，先都遍历一遍，知道他们的长短，让长的先走差值的步数，这样他们尾巴就对齐，遍历下去，相等就返回，没找到就null

	## m+n=n+m
	两个链表一起遍历下去，一个遍历完就接在另一个的头，可以理解成两个人速度一样，走过一样的路程，会在同样的重点相遇，m+n=n+m


4.复制随机链表





<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>


<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>



<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>


<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>