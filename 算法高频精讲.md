---
<h1>第一章</h1>

1.A,B先后从数组首或尾取数字，求最后和更大的是谁，是多少？

	##递归思路1
	写两个递归函数，模拟先拿和后拿的过程，f(arr,a,b)和s(xxx)。

	f先拿中，a=b，就只有一个，先拿就直接拿了，return arr[a]，如果不是，就下一层递归，return max{arr[a]+s(a+1,b)和arr[b]+s(a,b-1)}，一种是拿头的，下一次就是s后拿，另一种是拿尾巴的，也是后拿，两种的下标长度不一样，在结果中选max的

	s后拿，a=b，就一个我还后拿，就是没了，返回0，a不等于b的话，由于后拿，前一个人一定是拿了它的最大。对于本次s来说，能期待的就是len-1后的f先拿，当前s的收益就是f(a,b-1)和f(a+1,b)中的一个，而且选最小的

	##思路1改动态规划
	1.f和s都是a,b起始和终止决定了值，所以是dp二维数组可以确定。
	2.再看终止条件，f是a=b时返回arr[a]，所以在dp数组中横纵坐标一样时又已经确定的值
	3.返回值是f(0,len-1)和s(0,len-1)，所以数组中最后的值是dp[0][len-1]
	4.主体逻辑中，一个坐标，都是看它的下方和左边，所以循环方向，从左到右和从下往上，而且a>b没有意义


2.有效的括号

	##只有()
	弄一个count计数，遍历char数组，左括号就+1,右括号就-1，每次都检查count，小于0就直接false，遍历完之后，再检查count是不是等于0

	##多种括号 {}[]()
	弄一个栈，然后弄一个map，里面存()，{}这样的对应串。开始遍历数组，不管什么左括号，就压入，遇到右括号，就去比对栈最外面的是不是它对应的，不是就false，因为不能括号穿插，遍历完之后，看stack有没有被消耗光

	###题目升级，有效括号的最大长度
	一个字符串，求有效括号的最大长度。

	1.动态规划
	dp数组，每一个位置上都代表，以这里为结尾有效括号的最长是多少，所以，左括号就是0，因为不可能是结尾，遇到右括号，向前看一位，如果是有效的，就跳到有效的之前，判断再前一个是不是能对应的左括号，如果是，dp[i] = dp[i-1]+2，同时找到那个对应的之后，在往前跳一位，看是不是有效的，因为有可能是前面已经有了一部分，也要加进去。其他情况就继续循环
	

3.一个数组，求和为K的最长子数组的长度

	##数组只有正数
	准备双指针，都指向第一个，然后开始右指针滑动，把窗口变大，同时计算sum，当sum=K，记下来，小于K就继续，大于，则说明开头以first起始的数组，已经没有可能，就头指针向后，直到sum<=k为止

	##数组任意
	这题考虑每一个位置作为结尾的情况，第j个位置代表，0到j的总和，比如是sum，前面的第i个位置是k，那么i+1到j的和就是sum-k。让这一段差值等于我们要的值就好
	
	遍历整体数组，一直累加，如果没在map中，就存进去(sum,index)，累加值和它最早出现的index，每次都去找sum-k在不在已有的map里，就可以。
	

3.1 做题技巧

	遇到子串，子数组，等等的题目，首先想到的思路应该是，对每个Index，以它为开头的，以它为结尾的，并判断第i个是不是能从第i-1个推出来



---
<h1>第二章</h1>

1.仅仅使用递归，不使用额外空间，使栈元素逆序

	
<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>


<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>



<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>


<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>