---
<h1>9.1</h1>

1.**意向锁**
<ul>1.存在的意义</ul>

	innodb中有表级锁和行级锁，当一行被排它锁占了，另一个操作要锁表，这样就冲突了。锁表的那个，每一行去查有没有被锁，效率也会很低，所以出现意向锁
<ul>2.具体</ul>

		X	IX	S	IS
	X	冲突	冲突	冲突	冲突
	S	冲突	冲突	兼容	兼容
	IX	冲突	兼容	冲突	兼容
	IS	冲突	兼容	兼容	兼容

	在申请行锁之前，首先申请对应的意向锁，
	1.比如上面的例子，我要行排它锁，就先申请意向写锁，后面的锁表操作来了，发现了意向写锁，说明有某一行在占用，阻塞了
	2.我先表级写锁了，后来我想行写锁，就需要先申请意向写锁，但是根据上面的表，是冲突的，就不行

	###意向锁之间是兼容的
	这个兼容的概念，应该是针对不同资源的，我锁A行的意向写锁，你锁B行的意向写锁，当然没冲突

	###意向锁是表级的
	表级和表级之间，才会有冲突关系

<ul>3.链接：https://blog.csdn.net/zcl_love_wx/article/details/82015281</ul>


2.**mysql架构**
<ul>1.组件和架构</ul>

	主要分为3层：客户端，server层，存储引擎层

	###客户端
	主要就是连接器，负责连接管理，权限验证

	###server层
	1.查询缓存
	2.分析器：语法分析
	3.优化器：生成执行计划，选择索引
	4.执行器：去操作存储引擎，返回结果

	###引擎（不多说）
<ul>2.查询缓存</ul>

	mysql默认是开启查询缓存的

	一个sql语句进来，如果已经开启了缓存，就先查缓存，缓存有就返回，这时候这条sql不进行分析，也不优化，直接就过了

	当sql有自定义函数，用户变量，或者特定函数，比如now这种获取时间的函数，就不会缓存，因为容易变，没有意义。而且在表的数据或者额结构改变，关于这张表的缓存就会失效，所以写操作多的情况，缓存弊大于利，还不如不开启


<h1>9.2</h1>

1.做题
<ul>腾讯那些题，明天再总结吧</ul>



2.**杂**
<ul>1.海量数找中位数</ul>

	###内存够
	用快排，找到第K个值就行，顶多优化下，找到一个m的，m>k，就在后半段做，m<k，就在前半段做

	###内存不够
	int数32位，可以把这32位的数的范围，分成K个区间，保证每个区间能被内存装下
	比如内存够加载100W个，就每次拿出100w，映射在区间内，在里面+1，遍历完一遍后，开始累加sum，当sum大于一半时，说明找到了那个区间，再找出所有这个区间的数。可以重复做，直到区间可以被内存装下。然后就按照能装下的方法做

	
<ul>2.大数据量下的topk</ul>

	topk很容易，快排法，最小堆法，大批量数据的话，分块，每一块找出K个，然后合并起来再比较
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


1.昨天填的天翼云，还要成绩单
2.咪咕可以投了，在手机短信里
3.forkjoin

1.复习
<ul>1.项目介绍</ul>

	1.每个点再走一下，mq调优，mysql调优，反扒，大批量去重，布隆过滤器
	2.异常流量检测算法/百度到的和自己的无监督

	3.concurrenthashmap 源码，流程
	4.线程池流程
	5.设计模式
	6.spring ioc,aop
	7.算法
	8.业务设计
	9.dubbo/zookeeper

---
<h1>9.5</h1>

1.**杂**
<ul>1.可重入锁默认非公平</ul>
<ul>2.拓扑排序</ul>

	有一个连通图，检测它内部有没有环，可以用拓扑排序，找到每一个点的入度，从入度0的开始，把他们剔除，与此同时，剔除的点他们指向的点，入度也会减少，这样一直下去，如果到最后，还存在入读不为0的，说明有环存在，拓扑排序进行不下去
<ul></ul>
<ul></ul>


2.**做题**
<ul>1.力扣207，课程表安排，每个课程都有先后顺序，先上了A课，才能去上B课，问会不会有冲突</ul>

	实际上就是问，这里面会不会有环的构成，可以使用拓扑排序来做，当拓扑排序进行不下去，说明剩下的还有入度不为0的点，就会冲突

	###还有一道题，210
	问的是一样的题干，求能全部上完的顺序，还是拓扑排序，每次用到就记录下来就行


---
<h1>9.6</h1>

1.**海量数据怎么排序**
<ul>1.思想：内排序加外排序</ul>

	1.把海量数据分成N块，对每一块的数据内部进行快速排序，这样每一块都是有序的
	2.利用归并排序的思想，拿出每块的第一个，进行排序即可
<ul>2.优化</ul>

	1.相同元素算作一个

---
<h1>9.7</h1>

1.贪心专题训练
<ul>1.力扣435，给一串区间，删掉若干区间，让剩下的区间不重叠，求最少删几个</ul>

	贪心，把区间按照stop排序，去选一条不重叠的最长区间，减一下就好
<ul>2.力扣452，每个气球占到一个区间的大小，现在从横坐标发射飞镖，问最少几个飞镖全部扎完</ul>

	当有重叠的，就可以用一个飞镖扎掉重叠的气球，按照stop排序，遍历气球，符合重叠的部分，就加入，不符合就重新开辟，count+1
<ul>3.力扣406，根据身高重建队列，(h, k)，h表示身高，k表示前面有几个大于等于他身高的人</ul>

	首先根据身高从大到小排，每次取出一个，都能保证，已经排好的，都比当前大，那么不管当前放在哪里，都不影响K值

	那就很简单了，根据K值，K多少，就放在第K位
<ul></ul>

2.买卖股票系列
<ul>1.力扣121，一串价格，只能买卖一次，求最大收益，如[7,1,5,3,6,4]，最大收益6-1=5</ul>

	##动态规划
	dp[i]=max(dp[i-1],当前价格-前面的最小)

		n = len(prices)
        if n==0:
            return 0
        dp = [0 for _ in range(n+1)]
        maxV,minV = 0,prices[0]
        for i in range(1,n):
            if prices[i]>=minV:
                dp[i] = max(dp[i-1],prices[i]-minV)
            else:
                minV = prices[i]
        print(max(dp))

	##双指针
	一个buy指针，一个sell指针，buy不动，sell往后，如果对应元素sell>buy，就照常算，如果小于，buy就移到那一位，记录过程中的最大值

<ul>2.力扣122，现在可以买卖多次</ul>

	没什么特殊思想，试想 1，3，2，4，这样的价格，怎么最赚，肯定不是4-1，而是(3-1)+(4-2)=4，这样就发现，只要一旦下降，就在这之前就卖，最后的和，只是每次升序升的值而已


---
<h1>9.8</h1>

1.基础知识
<ul>1.String/StringBuffer补充</ul>

	对String修改，其实就是new了一个新的StringBuffer，调用append，最后再toString
	对StringBuffer修改就是append
<ul>2.占用多少资源，才不会死锁，假设3个进程，每个都需要4个资源，最少几个不死锁：最坏的情况，每人拿了3个，互相等待，现在只要再来一个，其中一个进程就完成了，释放了，就不死锁了</ul>
<ul>3.动态分区存储管理的系统，其初始空闲主存容量为55mb，采用最先适配算法；分配和释放的顺序为：分配15mb、分配30mb、释放15mb、分配8mb、分配6mb，此时主存中最大空闲分区的大小是：（10）。</ul>
<ul>4.java中，double定义用小数，float要用0.1f,int定义小数会咋样</ul>
<ul>5.哈夫曼树度为1的结点数等于度为2和0的结点数之差()</ul>

2.做题
<ul>1.力扣903</ul>
<ul>2.种花问题，输入01的数组，1代表有花种着了，0代表没有，1的两侧不能种花，也就是花不能相邻，问给一个数组和一个K，数组中能不能加上K朵花</ul>

	其实很简单从头开始，当连续出现3个0，说明可以种一朵花，并把种花的位置置为1，就可以。关于边界，可以前后加0，就不用考虑边界了


<h1>9.9</h1>

1.**中兴笔试**
<ul>1.选择题</ul>

	考察的较多的是sql语句，还有关于网络传输方面的，代码题反而很少，其实都是硬基础，印象深的是几个sql题

	举例
	1.删除某个表中某个字段，用drop?alter?还是delete?
	考察drop,delete,alter的用法，我们甚至可以加上truncate
	总的来说，drop,delete,truncate都是删除操作，drop偏向于删除表的结构，delete偏向于删除表中的数据，和where连用删除指定行，truncate则是清空表中的数据，对结构不改变

	而alter则是对表的字段，结构等进行修改，修改嘛，自然也可以删除，范围稍微大一点，所以创建索引，删除索引，add字段，删除字段，用alter都可以

	所以选答案中的alter(选项当然不是单独的一个alter，而是alter语句)

	2.给一个out join 的语句，问返回多少行
	考察内外连接，复习的话，还可以加上左右连接
	内连接就是只返回两表都匹配的
	左右连接其实都是外连接，左连接就是以左表为准，去匹配右表，如果匹配不上，结果中相应的位置为null，那一条其实还是返回的，所以，如果左表4条，右表500条，最少也是有4条返回，这时候都不匹配，最多呢，有503条数据，右表的500条都匹配到同一条数据上了，左表的另外三条都是Null
	全外连接，都是全部都返回
	
<ul>2.编程题</ul>

	1.给两个数组，里面的元素可能重复，找出在两个数组中只出现过一次的元素，统计个数

	挺简单，遍历两个数组，遍历第一个的时候，用桶排序或者hashmap记录下每次元素出现的次数(毕竟可能有重复)，遍历第二个的时候，也这样做，最后遍历一次hashmap去掉重复的就行，复杂度大约是 O(3N)

	为什么不遍历第一个数组，去第二个里面找有没有？复杂度太高，超时

	2.小偷找珠宝，给一个长方形矩阵，1代表可通过，0代表不能通过，9代表有珠宝，小偷从左上角(0,0)出发，问能不能找到珠宝

	典型的bfs问题，只要别忘了找过的点，状态置为-1即可

<ul>3.总结：中兴算是做过的笔试里，最省心的了</ul>

2.做题
<ul>1.力扣309，买卖股票含冷冻期。给一串数组，代表股票价格，现在任意买卖若干次，但是卖出后会有1的冷冻期不能交易，求最大利润</ul>

	###动态规划
	首先设置一个dp二维数组，dp[i][j],i代表第几天，j是0或者1，代表手里有没有股票
	dp[i][0],第i天手里没股票，有两种可能，第i-1天卖了，或者今天卖了，取最大，max(dp[i-1][0],dp[i-1][1]+prices[i])
	dp[i][1],手里有股票，有两种可能，第i-1天就买了，第i天也就是今天刚买，max(dp[i-1][1],dp[i-2][0]-prices[i])，为啥dp[i-2]呢，因为有冷冻期，今天要想买，必须起码是i-2天刚卖的

	写代码
	def maxProfit(prices):
        n = len(prices)
        dp = [[0,0] for _ in range(n)]
        dp[0][0]=0
        dp[0][1]=-prices[0]
        dp[1][0]=max(dp[0][0],dp[0][1]+prices[1])
        dp[1][1]=max(dp[0][1], -prices[1])
        for i in range(2,n):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])
        return dp[n-1][0]

<ul>2.力扣123，买卖股票，但是只能交易两次</ul>

	###动态规划
	设置一个三维数组，题目里有这些个条件，天数会变，购买的次数会变，股票会被买卖。
	dp[i][k][0]，代表，在第i天，手里没有股票，已经交易了k次，所以理所当然的想到状态转换方程，要么是前一天就已经卖了，要么是今天才卖的，在dp[i-1][k][0]和dp[i-1][k-1][1]+prices[i]中间取大的
	dp[i][k][1]，手里有股票，要么是昨天就买了，要么是刚买的, dp[i-1][k][1] 和 dp[i-1][k-1][0]-prices[i]

	天数 i 从1开始 ,k从1开始,就行了

	        k = 2
            n = len(prices)
            dp = [[[0, 0] for _ in range(k + 1)] for _ in range(n)]
            dp[0][1][0] = 0
            dp[0][1][1] = -prices[0]
            dp[0][2][0] = 0
            dp[0][2][1] = -prices[0]
            for i in range(1, n):
                for j in range(1, k + 1):
                    dp[i][j][0] = max(dp[i - 1][j][1] + prices[i], dp[i - 1][j][0])
                    dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i])
            print(dp[n - 1][k][0])
            return dp[n - 1][k][0]

	###总结一下
	当有多个状态的动态规划时，可以考虑多个维度，或者是干脆弄两个dp数组，互相取最优的情况


---
<h1>9.10</h1>

1.做题
<ul>1.力扣84，柱形图中的最大矩形</ul>

	###分治法
	以第 i 个位置为例，以这个高度为最小高度，做成的矩形，就是越宽越好，从 i 开始向左向右，一旦遇到更小的就停下，计算面积

	那么现在选取最矮的一个，可以分成三种情况，第一种，以这个最矮的为高度，计算最宽的面积，第二种，把左边的作为新的一块，选出一个新的最矮，重复，第三种，右边的。这样就成了分治法，复杂度O(N*logN)
	
    def foo(heights):
        n = len(heights)
        if n == 0:
            return 0
        if n == 1:
            return heights[0]
        mid = min(heights)
        index = heights.index(mid)
        a = mid*n
        b = foo(heights[:index])
        c = foo(heights[index+1:])
 
        return max(a,b,c)

	###单调栈
	这个是真的很难想到，但是想通了就很简单。单调栈一个性质，保持栈的单调性

	这个问题可以转换下脑子，如果是一个递增的高度，我们怎么做？以i为最矮高度的矩形，就height(i)*(size-i)，这里我们应该从后向前，因为从前向后，当最矮的在中间，前面的面积就会漏下

	递增的知道了，我们是否可以把不递增的，强行转换成递增的来思考，现在使用单调栈

	def foo(heights):
        stack = []
        heights = [0]+heights + [0]
        res = 0
        for i in range(len(heights)):  ##这里i是递增的size
            # print(stack)
            while stack and heights[stack[-1]] > heights[i]:
                tmp = stack.pop()
                res = max(res, (i - stack[-1] - 1) * heights[tmp])
            stack.append(i)
        print(res)
        return res
	
<ul>2.其实做了好多题，但是写题解太累了，明天写吧</ul>


---
<h1>9.11</h1>

1.做题
<ul>1.力扣10，正则表达式匹配，字符串只有字母，pattern只有字母和  .  * </ul>

	##递归
	
<ul>2.力扣152，乘积最大连续子序列</ul>

	这道题可以联想下最大子序列之和，那道题，pre<0就重置，这个不行，因为有正有负，现在是负数，但是下一个也是负数，就翻过来了，说不定还是最大，所以，每一次的最大和最小都要记录

	###
	记录每一次的最大和最小，根据cur的大于0还是小于0，取到不同的值

	if cur>0
		tempMax,tempMin = max(tempMax*cur,cur),min(tempmin*cur,cur)
	else:
		一样的思路


---
<h1>9.12</h1>

1.**杂**
<ul>1.排序再总结</ul>

	不稳定的:快些选一堆朋友（快速，希尔，选择，堆）

	##每一个排序的特点
	冒泡：一轮结束，就有一个到最后的位置
	快速：每一轮都有一个到正确的位置
	简单选择：每次从后面选一个最小的到前面，所以每一轮，前面都是有序的
<ul>1.重写和重载</ul>

	重写：方法名一样，参数一样，权限要大于等于原来的，返回值要和原来的有继承关系，而且必须更小
	重载：只要方法名一样就行了，参数随意，但必须不一样，返回值没规定


---
<h1>9.13</h1>

1.操作系统做题
<ul>1.分段式，段内连续，段外可以不连续，段长不定</ul>
<ul>2.并发，是在同一处理器上，宏观并行，微观串行，并行，是真的，在多个处理器上</ul>
<ul>3.内存分配</ul>

	内存分配方式有三种：
	  （1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
	
	  （2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
	
	  （3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多
<ul>4.管道其实是一个缓冲区，可以双向传输，但是不能同时双向，也就是说，同一时间只能一个方向。满了，写阻塞，空了，读阻塞。管道大小一般是一页，和磁盘容量无关</ul>
<ul>5.不同存储介质之间拷贝，要用同一物理结构</ul>
<ul>6.各种cpu调度算法</ul>
<ul>7.mutex，代表允许一个进入，0代表不允许，也就是以及各有一个占用了，-1就是一个占用了，另一个已经在等了</ul>
<ul>8.现有磁盘读写请求队列为2、4、0、5、1，若当前磁头在1号磁道上,若采用FCFS算法进行磁盘调度时，则平均寻道长度为（  3.2    ）</ul>
<ul>9.cpu饥饿</ul>
<ul>10.覆盖和交换技术，一个完成的程序，分成多个相对独立的模块，只加载其中一个模块，用完就加载下一个，就是覆盖，替换的时候就是交换，放在外存的交换区</ul>
<ul>11.银行家算法</ul>

	安全状态 
如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。
不安全状态 
不存在一个安全序列。不安全状态不一定导致死锁。
<ul>12.cpu是可剥夺资源，不会产生死锁</ul>
<ul>调度算法：</ul>

	常见的批处理作业调度算法
1.先来先服务调度算法（FCFS）:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。

2.短作业优先调度算法(SPF): 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。

3.最高响应比优先算法(HRN)：FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。

4.基于优先数调度算法(HPF)：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。

5.均衡调度算法，即多级队列调度算法**

基本概念：

1
2
3
4
作业周转时间（Ti）＝完成时间(Tei)－提交时间(Tsi)
 作业平均周转时间(T)＝周转时间/作业个数
 作业带权周转时间（Wi）＝周转时间/运行时间
 响应比＝（等待时间＋运行时间）/运行时间
进程调度算法
1.先进先出算法(FIFO)：按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。

2.时间片轮转算法(RR)：分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。

最高优先级算法(HPF)：进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。
4.多级队列反馈法：几种调度算法的结合形式多级队列方式。

空闲分区分配算法
1.首先适应算法：当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。

2.最佳适应算法：当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。

3.最坏适应算法：当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。

虚拟页式存储管理中的页面置换算法
1.理想页面置换算法(OPT)：这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。

2.先进先出页面置换算法(FIFO)：选择最先进入内存的页面予以淘汰。

3.最近最久未使用算法（LRU）：选择在最近一段时间内最久没有使用过的页，把它淘汰。

4.最少使用算法（LFU）：选择到当前时间为止被访问次数最少的页转换。

磁盘调度
1.先来先服务（FCFS）

2.最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题

3.扫描算法（SCAN）或电梯调度算法：总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。

4.循环扫描算法（CSCAN）：循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。




常见的批处理作业调度算法：
        先来先服务调度算法（FCFS）
        短作业优先调度算法（SPF）
        最高响应比优先算法（HRN）
        基于优先数调度算法（HPF）
        均衡调度算法
进程调度算法：
        先进先出算法（FIFO）
        时间片轮转算法（RR）
        最高优先级算法（HPF）
       多级队列反馈法
空闲分区分配算法：
        首先适应算法
        最佳适应算法
        最坏适应算法
虚拟页式存储管理中页面置换算法：
        理想页面置换算法
        先进先出页面置换算法
        最近最久未使用算法（LRU）
        最少使用算法（LFU）
磁盘调度算法：
        先来先服务（FCFS）
        最短寻道优先（SSTF）
        扫描算法/电梯调度算法（SCAN）
        循环扫描算法（CSACN）
<ul>13.线索二叉树，原来是左右子树，现在是根据前中后遍历，有多加了直接前驱和直接后继</ul>
<ul>14.二叉树</ul>

	节点个数 = n1+n0+n2，而n0 = n2+1
	第m层，最多2的m-1次
	K高，最多2的K，再-1
<ul>727035025</ul>
<ul>15.UNION操作符会省略重复的结果，UNION ALL会保留重复的结果</ul>
<ul>16  .403,服务器拒绝，404找不到，301永久移动，503服务器无法使用</ul>
<ul>17.linux中调用write发送网络数据返回n(n>0)表示（ 已发出N个）</ul>

	
<ul>18.用户态和内核态</ul>
<ul>19.ping测试是否连同，telnet是通过telnet协议和另一主机相联</ul>
<ul>20在 SQL 中，与“ NOT IN ”等价的操作符是 （ ）。

正确答案: A   你的答案: B (错误)
<>ALL
<>SOME
=SOME
=ALL</ul>
<ul>20.ip地址，ipv6??</ul>
<ul>21,七层模型我忘记了</ul>

	五层是应用，传输，网路，链路，物理
	七层就是应用拆出来，变成应用，表示，会话
<ul>22.数据库，count是统计出现次数，sum是求和，DISTINCT去重，union是合并去重，union all不去重</ul>
<ul>23.模式，概念模式
内模式：子模式，存储模式
外模式： 用户模式</ul>
<ul>24.协议</ul>

	snmp:获得路由器上的数据，更好的统计
	smtp:邮件协议，TCP/IP
	telnet：远程登录，telnet连接
	ICMP是Internet控制报文协议，是TCP/IP协议的子协议，用在IP主机和路由器之间传递控制消息，是网络层协议
	PPP协议面向字节、HDLC协议面向位，都是链路层协议
<ul>25.时间片用完后，该进程状态由执行态变为就绪态</ul>
<ul>26.外模式/模式的映像保证逻辑独立性，模式/内模式的映像则保证物理独立性。</ul>
<ul>27.ip地址中全1全0要除去</ul>
<ul>28.OSPF和都是路由协议，前者适合大的，后者适合小的</ul>
<ul>29.</ul>

	每个进程维护一个自己的列表，该列表每条存储一个描述符
每个描述符指向一个内核维护的打开文件列表的其中一个条目
文件列表条目指向一个inode列表条目，inode列表条目中的信息实际上指向真正存储文件信息的block块。
inode中的信息包括很多，其中含有引用计数，当我们删除一个文件，并不会真的删除，只有当引用计数到达0的时候由系统删除。然后每个inode和一个文件对应，可能含有多个block。文件目录项和inode的关系并不是一对一，假设有硬链接的存在，那么就是多对一。软连接的会有新的inode号，但是其block中的内容存储软连接所指向的文件名。
<ul>30.CPU不能读取硬盘上的数据，但是能直接访问内存储器；CPU主要包括运算器和控制器；CPU是整个计算机的核心部件，主要用于控制计算机的操作。</ul>	
<ul>31.sql 中 BETWEEN 20 AND 30，前后都包括</ul>
<ul>32.数据库日志记录更新操作，所以满了之后，只能做读操作</ul>
<ul>33.abcd分类ip</ul>
<ul>34.它将独占设备改造为共享设备，实现了虚拟设备功能，把独占设备改造成共享设备从而提高独占设备的利用率</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<ul>1.中缀转后缀？ipv6?</ul>

---
<h1>9.14</h1>

1.做题
<ul>1.8瓶水，用动物检测，最少用几只，怎么做</ul>

	把8瓶水编号，0到7
	000，001，010....111
	把每一位上为1的水，给同一个人喝，在这里，1，4.等号码给A老鼠喝，另一位的给B喝，最高位的给C喝，A死了，说明最低位1，B死了，第二位就是1，以此类推

	所以3只动物

---
<h1>9.16</h1>

1.**group by用法**
<ul>1.group和聚合函数</ul>

	没有使用聚合函数的字段，必须在group by的后面
	比如 select a,b from table group by a 这句毫无意义
	应该写成 select a,count(b) from table group by a ，这样才是根据 a 来分组统计 b
<ul>2.where 和 having</ul>

	where是在group之前就筛选好
	having 是在group之后筛选

2.**做题**
<ul>1.力扣739，每日温度，给一个数组，里面是每天的温度，返回当前天，再过几天温度才能超过他</ul>

	###单调栈
	O(N^2)，从i 出发，向后去找第一个比他大的，复杂度太高，所以用单调栈

	这样想，从前到后，不知道第几天才是，但是从后向前，是可以知道的。
	从后向前，如果 i-1 比 i小，i-1的值就是1，同时压入栈，一旦遇到更大的，就pop栈，直到栈空(这样说明后面没有比他大的了)，或者遇到一个比他大的，就计算stack[-1]-i，就是结果，唯一的要点就是，栈存的是下标
<ul>2.力扣139，单词拆分，给一个字符串，和一个字典，求字典中的元素是否可以组成字符串，可以重复</ul>

	###递归
	def dfs(self,have,start,s,wordDict):
        if start>=len(s):
            return True
        for i in range(start,len(s)):
            if s[start:i+1] in wordDict:
                if self.dfs(have,i+1,s,wordDict):
                    return True
        return False

	###优化的，带记忆的递归
	前面递归是这个思路，首先终止条件，start>=len，然后for 循环，从start开始，当截取的字符串在字典中，就递归下去，ok就返回true

	但是上面那种有很多重复的问题，比如到了第i个，之前知道失败了，这次再轮到他，直接返回失败即可，把他们记录下来，减少很多递归分支

	核心思想，一旦发现 从第i个开始不行了，就把have[i]=False，下次遇到就直接false

	###动态规划
	上面也提到了，有很多子问题是重复的，所以用dp二维数组，从后开始遍历i，j

	if s[i:j+1] in wordDict:   //在字典里，就true
		dp[i][j] = True
    if j<n-1 and dp[i][j] and dp[j+1][-1]:  //如果后面的也是，就都True
        dp[i][-1] = True

<ul>3.topk再复习</ul>

	首先创建堆数组，然后从 k-1//2开始，也就是非叶子的最后一个开始shift

	shift是单独的调整函数，分左右，换里面最大的或者最小的


---
<h1>9.17</h1>

1.**做题**
<ul>1.力扣79，单词搜索，给一个矩阵，都是字符，可以上下左右走，问是否包含某个字符串</ul>

	###DFS+回溯
	1.进入dfs的条件：当遇到的字符和目标word第一个相等时，可以减掉很多递归
	2.dfs终止条件：不相等，超出
	3.小技巧，path要么用[(x,y)]，要么用二维数组
	4.各个方向，就用dirs=[]弄一个列表，for就行
<ul>2.力扣200.岛屿数量，给一个矩阵，都是01，1代表岛屿，0代表海水，求岛屿数量，斜对角不算</ul>

	###DFS
	1.进入dfs条件：当前位=1
	2.终止：越界，等于1
	3.四个方向递归，遇到1置为0，遇到0return


---
<h1>9.18</h1>

1.做题
<ul>1.下一个排列</ul>

	比如1234变成1243，1243变成1324

	##
	从后向前遍历，遇到第一个比前一个小的，就记下来下标，再从后向前，遇到的第一个比它大的，交换，然后，后面的排序就行了

---
<h1>9.19</h1>

1.做题
<ul>1.三数之和</ul>

	###字典法，不好弄，怪麻烦的

	###指针法
	首先对数组排序，然后一次选取一个元素，作为三个数的第一个。
	就和两数之和一样，不过发生了重复，跳过就好
<ul>2.N个点，规定出口入口，和路径，不能重复经过某个点，问哪些点不会被经过</ul>
<ul>3.数独</ul>
<ul>4.记下的很多知识点</ul>

---
<h1>9.20</h1>

1.**杂知识点**
<ul>1.java | 和 ||：||是短路或，前一个true，第二个就不执行，|不管咋样，都是要执行的</ul>
<ul>2.Math.round(11.5)=12，Math.round(-11.5)=-11,因为是+0.5再处理的</ul>
<ul>3.HashMap没有contains方法，分为了containsKey和containsValue</ul>
<ul>4.协议</ul>

	dns:应用层协议
	icmp：网络层，管路由器传递消息的
	igmp:网络层
	arp:网络层，ip to mac (RARP,反一下)
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


2.**ip地址分类和子网掩码再复习**
<ul>1.地址分类</ul>

	ip地址有五类
	A类，开头0，所以是0~126，因为127测试用，前8位网络号
	B类，开头10，所以是128.0~191.255，是前16位网络号
	C类，开头110，所以是192开头，前24位是网络号，所以是192.0.0~223.255.255
	D类，开头1110(224)，用于多播地址
	E类，开头11110，保留
	
	###全1全0
	网络号全0：只能作为源端，不能作为目的端，另外无所谓
	网络号全1：主机号不是全1就无所谓，也是全1，那就是一个受限的广播地址，不能被转发

	主机号全1，广播地址，那就是只能做目的端
	主机号全0，没啥特大讲究

	##私有(局域网)
	A类地址：10.0.0.0～10.255.255.255 
	B类地址：172.16.0.0～172.31.255.255 
	C类地址：192.168.0.0～192.168.255.255
<ul>2.子网掩码</ul>

	两种算法
	###根据子网数算
	1.看看是哪类地址，比如B类，主机号就是从第17位开始
	2.有几个子网，就从前面开始置为1

	###根据主机数算
	1.找类别
	2.一个子网有几台主机，就从后面开始置为1


3.**get/post的区别**
<ul>1.参数上：get参数可见，通过拼接url传递，用问号分割，post，参数不可见，数据放在request body里面</ul>
<ul>2.数据大小上：get参数在url，url有长度限制，一般是2K个字节，post理论上无限制，但是实际上80kb</ul>
<ul>3.建立连接过程：get是发送一个tcp包，服务器返回200,post则是先发送一个header，服务器返回100 continue，再发第二个包data，服务器返回200</ul>
<ul>4.回退：get回退时没影响，post回退，会再提交一遍数据</ul>
<ul>5.是否被缓存：get会被服务器缓存，post需要自己设置</ul>
<ul>6.编码类型：get只能发ascii，post可以发别的</ul>
<ul>7.更大的方面：get更快，因为只发一个包，get是幂等，post非幂等，get不安全，post更安全</ul>

4.**加密算法**
<ul>1.常用对称加密：DES,AES，非对称：RSA</ul>

	##DES
	把明文分组，分组成64bit的M，经过ip置换后，分成左右两部分，左右两部分再和密钥进行F函数（就是，拓展变换，S盒，P盒，再异或）的运算，其实就是，左右交换并进行16轮，最后把两部分合在一起，做最后的逆ip置换，得到密文

	###REA
	找两个大素数pq，求出欧拉函数，在求出n=pq,找一个和欧拉值互素的数e，用e,n做公钥，pq做私钥 C = M的e次对n取模，解密是M=C的d次对n取模

<ul></ul>

5.**做题**
<ul>1.剪绳子，一个长度n的绳子，剪成若干段，求各个长度积最大</ul>

	###动态规划
	比如长度7，分成了4盒3，4又有2和2的情况，所以是有子问题的

	设置0123的情况，后面的，就是两两相乘的结果，取最大

	###贪心
	上面也说了，实际上就是3和2的取多少个的问题，实际上，任何一个数都可以拆成3和2的组合，尽量选3，不够再选2	



<ul>2.力扣130，被围绕的区域，一个矩阵都是XO，把被X完全包围的O变成X，像联通边界的这种就不用</ul>

	我本来想的是，全丢进dfs，向四周遍历，再加上回溯，遇到边界就全部重置，但是发现不太行，超时

	###正确思路
	先把边界的处理了，丢进dfs，遇到O就变成#，边界都弄完之后，剩下的里面，有O的就是完全被包围的
	
	再遍历一遍矩阵，接下来有顺序的，遇到O变成X，遇到#变成O

---
<h1>9.23</h1>

1.做题
<ul>1.二叉树打印路径</ul>
<ul>2.力扣179，一些数字，组成最大的数</ul>

	普通的排序就会有问题，其实这道题应该使用冒泡排序的思想

	两层循环，外层是要排出来的最大值的位置，内层遍历
	for i in range(len(nums)-1):
		for j in range(i+1,len):
			比较 str(i+j) 和 str(j+i)，大的在前
<ul>3.和为正数的最长序列</ul>
<ul>402</ul>

2.杂
<ul>1.循环队列，front 和 rear</ul>
<ul>2.do while和while,do while就是不管咋样，都先执行一次</ul>
<ul>3.父类可以捕获子类的异常，子类不能捕获父类的</ul>

3.各种引用的使用场景
<ul>1.soft软引用：在内存不够时，发生GC就会被回收</ul>

	适用于做缓存等等，内存不够了，发生gc就会回收了，不会发生OOM
<ul>2.weak虚引用：有GC就会被回收</ul>

	一个对象作为key，被引用，明明已经不会被使用，但是hashmap还在，就不会被回收，可以使用虚引用
<ul>3.链接：https://blog.csdn.net/weixin_41985660/article/details/83716110</ul>


---
<h1>9.24</h1>

1.做题
<ul>1.给一个数字，返回所有连续的和为n的组合，比如给90，返回的结果中有29,30,31等等</ul>

	###双指针
	left和right,while right<n/2，一直right向后，当和小于n，继续，大于，就移动前面的，直到小于为止。过程中有等于的，就加入
<ul>2.java的输入输出/其他</ul>

	import java.util.Scanner
	Scanner scanner = new Scanner(System.in)
	scanner.nextline()
	scanner.nextInt()

	string变成char[]数组，处理完再整回来，String.valueOf(res)

---
<h1>9.25</h1>

1.**做题**
<ul>1.力扣938，二叉搜索树的范围和，给两个值，求他们之间的路径和</ul>

	递归，传入root，判断，如果两个值在两边，该值就在路径上，return root.val+递归左+递归右，在同一边就向单边递归
<ul>2.力扣617，合并二叉树</ul>

	###新建一个新的树
	new一个节点，设定cur.left是递归下一层，右边也如此，遇到t1=null，返回右边，t2==null,返回左边

	###加到t1树上
	1.t1和t2都有，t1.val加上t2的，然后t1.left/right指定成递归下一层
	2.t1有，t2没有，啥事没有
	3.t1没有，t2有，直接返回t2
<ul>3.力扣977，有序数组的平方，给一个有序数组，有正有负，返回他们平方的排序数组</ul>

	输入：[-4,-1,0,3,10]
	输出：[0,1,9,16,100]

	##o(n)
	可以先遍历一遍，找到正负的分界点
	再从分界点开始，从负数和正数方向，双指针遍历，类似于归并
<ul>4.二叉搜索树返回子树/普通二叉树返回子树</ul>

	###搜索树
	递归嘛，每一层向下找，找到就往上抛符合的。
	首先是终止条件，为空就返回null，符合就返回当前节点。都不符合就往下，根据和val的大小比较，判断在左树还是右树，向下递归

	###普通
	另外一样，但其实，左右任何一边找到，另一边都找不到了的，所以先找左边的，是空就继续找右边的，有值就返回就好了
<ul>5.力扣961，重复N次的数字，总共2N个数，有N+1个不同的数，其中一个重复了N次</ul>

	仔细想想，其实就是一个数占半数，另外都是不一样的

	这样更简单，遍历，记录下来，出现了两次就是的
<ul></ul>


2.**java做题**
<ul>1.java 异或 ^ ,Java与 &</ul>
<ul>2.java数组初始化 int[] i = new int[]{xxxx,xxx}</ul>


---

<h1>9.26</h1>

1.做题
<ul>1.力扣476，数字的补数，101就是010</ul>

	101异或010，是111，所以101异或111就是010

	这道题用int过不了，要先long，最后再转int
<ul>2.力扣416，分割等和子集，把一个数组，分成两个和相等的组合</ul>

	###回溯
	首先，对总和取模，不能被2整除，肯定不行，可以的话，再获得和的一半，作为target，就是找，有没有和为一半的组合

	回溯

	###动态规划
	变化成背包问题
	bool dp[i][j]，i是第i个元素，j是目标值
	首先求出第一行，dp[0][j]，然后做背包的正常操作就行

2.**负载均衡算法**
<ul>1.简单轮询</ul>
<ul>2.随机</ul>
<ul>3.hash法，甚至可以是一致性hash</ul>
<ul>4.加权轮询，类似于dubbo里介绍的那个</ul>
<ul>5.加权随机</ul>
<ul>6.最小连接，优先分配给连接数量最少的</ul>

3.海量数据下的问题
<ul>1.通用思路</ul>

	1.分治+hashmap
	2.分治+堆
	3.外排序
	4.位图


2.杂
<ul>1.java取整</ul>

	四舍五入 Math.round()
	向上取整 Math.ceil()
	向下取整 Math.floor()
<ul>2.ascii，a=65 ,A = 97</ul>

	Python取ascii	
	java取ascii


---
<h1>9.28</h1>

1.杂
<ul>1.归并排序手写</ul>
<ul>2.相同的请求，只处理一次，缓存？</ul>
<ul>3.statement和preparedstatement</ul>
<ul>4.快排稳定性，最差情况，怎么改进最差情况，基准如何选择（三种：固定，随机，三数取中）</ul>
<ul>5.孤儿进程和僵尸进程</ul>
<ul>6.海量数据的处理</ul>


2.**海量数据处理**
<ul>1.海量数据，找出频率最高的N个元素</ul>

	###重复频率高
	由于重复的多，所以实际上，去重之后，也许就存的下了。
	分批读取，设置一个hash表存key和value，value就是count

	###分治+归并
	见下面

<ul>2.海量数据，找出最大的N个数</ul>

	###最小堆
	分治+堆
	首先设置一个最小堆，然后分批读取数据，当大于堆顶，就交换，然后调整堆，遍历完，就是最大的，复杂度 nlogk

	###堆的缺陷，重复元素过多
	上面这种方法，重复的元素过多的话，堆可能全都是某个元素，就达不到效果了。这时候可以先对数据进行去重，不管是hash还是布隆过滤器，去重后再处理

	也可以事先估计重复度，高的话，说明数据本身不多，甚至可以用桶排序

	###分治+归并法
	把数据分成N块，不是随便分，而是通过hash来分。找出每一块的前N个数，然后再汇总。

	为啥这样可行，看起来很扯不是吗？如果是随便分数据，当然不行，某一个数据十分散乱，每一块都有，但是每一块都排不上前N。所以我们分的时候，通过hash来分，保证相同的数据(或者是hash相同的数据)，是在同一台机器的，就不会漏下了
<ul>3.海量数据，排序</ul>
<ul>4.海量数据，判断是否有重复</ul>

	###位图


3.设计题	
<ul>1.hash</ul>
<ul>2.树结构</ul>
<ul>3.可靠性，断电恢复</ul>
<ul>4.单点故障</ul>


