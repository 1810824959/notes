
---
<h1>10.2</h1>
1.做题
<ul>1.力扣905，按奇偶堆数组排序，偶在前</ul>

	##有额外空间
	新设一个res数组，两个指针指向开头和末尾，遍历一遍原来的数组，是偶数，就是放在前面，下标+1，是奇数就放在末尾，下标-1，只需要遍历一遍就好了

	##原地处理
	还是两个指针，开头末尾，现在对 i j 两个位置的元素处理
	所以， 4 种情况针对 (A[i] % 2, A[j] % 2)：
	
	如果是 (0, 1)，那么万事大吉 i++ 并且 j--。
	如果是 (1, 0)，那么交换两个元素，然后继续。
	如果是 (0, 0)，那么说明 i 位置是正确的，只能 i++。
	如果是 (1, 1)，那么说明 j 位置是正确的，只能 j--。

	###题目变形，让元素本身奇偶和下标奇偶一样
	还是双指针
<ul>2.力扣171. Excel表列序号</ul>

	其实就是个进制转换，里面最难的其实是ascii码，char字符的处理等

    ###python 
	int 转 字符 chr()
	字符转int ord()

	###java
	没这么多讲究，char和int直接强转就行

	
---
<h1>10.3</h1>

1.杂
<ul>1.hashmap不指定类型，get就是object</ul>
<ul>2.hashmap更新值，map.put(key,map.get(key)+1);</ul>
<ul></ul>
<ul></ul>

2.做题
<ul>1.力扣1122. 数组的相对排序，两个arr，两者都有的元素保持相对顺序，不在的升序排列</ul>

	###计数排序
	用数组来做桶，计数排序，遍历一遍A，存进桶里，再遍历B，放进最终的res数组，最后是遍历缓存数组，按照升序存

	index初始值设为-1，每次都++，完美
<ul>2.力扣784. 字母大小写全排列，数字不变，字母可以是大写或者小写，返回所有的组合</ul>

	###回溯
	经典递归回溯，不想用全局变量，就在函数本身中传递结果集
	dfs(List res,int level,char[] temp,char[] origin)
	结束条件 level==origin.length
	递归内容：如果是数字，继续，如果是字母，大写小写各来一遍

	###大小写转换
	异或上 1<<5，大写变小写，小写变大写

---
<h>10.4</h>
1.做题
<ul>1.力扣283. 移动零，一个数组，里面有N个0，把0放在最后，另外保持相对顺序</ul>

	##O(N)
	只遍历一次，每一个非零元素，其实只需要移动前面0的个数即可
	比如[0,1,0,3,12]，1移动一次，3移动两次，每次移动完，置当前为0就好了


---
<h1>10.6</h1>
1.做题
<ul>1.力扣20. 有效的括号</ul>

	以前做过的题目，居然也花了一点功夫才A出来

	用栈来做，考虑进来的元素是左括号还是右括号，左括号因为可以叠加，所以直接加进来。
	右括号不可以串着来，所以必须一对一，第一种情况，stack空，右括号肯定错，不为空，如果不是对应的左，也错
<ul>2.力扣287. 寻找重复数</ul>

	题目：有n+i个数，从1到N都有，保证有且只有一个重复的数，但是重复的次数不保证，所以可能是[1,2,3,2]，也可能是[2,2,2,2]，求找出那个数的方法，要求时间复杂度低，而且空间复杂度只能是o(1)，而且不能改变原来数组

	###空间复杂度o(n)的方法
	创建hash表，查重

	###改变数组的方法
	对数组排个序，重复的肯定相邻

	###符合题意的二分法应用
	题目中说，都是1-n的数，且只有一个数会重复，比如是1-7，mid=4，如果不重复，小于等于4的，会有4个，现在有一个或者多个重复，遍历一遍，如果小于等于4的，超过4个，说明重复的数小于等于4，如果小于等于4个，说明比4大，这样来二分就可以了

	顺便总结下二分
	while(left<right):
	left = mid+1
	right = mid

	###抽屉原理
	其实就是类似于链表成环的解法。把下标和下标对应的值作为一个映射，就会发现如果有重复值，就会有环的存在，那么用快慢指针就可以了

		int fast=0,slow = 0;
        while (true){
            slow = nums[slow];      //慢的走一步
            fast = nums[nums[fast]];  //快的走两步
            if (slow==fast){
                break;
            }
        }
        int step1 = 0,step2=slow;
        while (true){
            step1 = nums[step1];
            step2 = nums[step2];
            if(step1==step2){
                break;
            }
        }
        return step1;

	


2.杂
<ul>1.java的stack，没有pop(0)这种方法，可以用remove(0)，也可以返回，单纯的arraylist，就是remove()，就是删除第一个</ul>


---
<h1>10.7</h1>

1.快排基准优化
<ul>1.基准的选择</ul>

	###固定选
	比如每次都选最后一个，有可能出现数组有序的情况，就其实移动了所有，复杂度o(n^2)

	###随机选
	每次选基准，随机选

	###三数中元
	选随机三个数，或者直接拿左中右端上的数据，取他们的中间值为基准

---
<h1>10.8</h1>

1.**zookeeper(脑裂等)**
<ul>1.zookeeper节点必须是奇数个？</ul>

	不是的，比如两个也可以啊

	zookeeper有一个机制，Quorums阔润丝(法定人数)，当zookeeper中的存活数量大于等于法定人数，才是有效的，才是对外可用的。而这个法定人数，一般是一半+1

	打比方，3个节点，Quorums就是2，说明可以容忍1个节点挂掉；4个结点，Quorums就是3，也是只能容忍一个节点挂掉。我们发现奇数和偶数个，他们的容忍值是一样的，那么为了节省资源，就用奇数个就可以了
<ul>2.脑裂</ul>

	一个zookeeper集群出现两个甚至多个master，就是脑裂。但是实际上，分两种情况：1.原来的master假死，新的master已经产生，但是老的又连接回来了  2.老的就是死了，新的里面，产生了两个master

	###zookeeper防止脑裂
	1.针对老master回归，每次产生新的master，都会有一个epoch，而这个epoch是递增的(类比paxos算法的提案id)，每个follow会拒绝小于自身的epoch，所以老master没啥用，也会被同化的
	2.同时一次性产生两个master。zookeeper有Quorums法定人数机制，当小于等于一半数量，对外直接失效。所以有效时，只能选出一个master，防止了脑裂

	###普适的，防止脑裂方法
	1.Quorums法定人数，没有一半以上直接无效，有一半，由于半数同意才能选出，所以最多选出一个，没有脑裂
	2.冗余通信，别总是一种通信方式，master一种通信方式挂了，还可以通过其他方法连上
	3.设置一个共享资源，能看到就是在集群里，能得到就是leader
<ul>3.zookeeper半数是，总数的半数，不是现存的半数</ul>

2.**sql语句**
<ul>1.count</ul>

	###count和sum
	sum是求和，count是统计行数

	###
	count(1)和count(*)，包含了所有字段，所以其实就是统计有多少行，不会忽略Null
	count(列名)，会忽略null

	###快慢
	列是主键，肯定是count(列名)快，而1 和 *比，有主键就是*更快
<ul>2.Mysql order by与limit出错</ul>

	两个关键字一起用，出现了数据丢失，数据重复的情况，比如240到250条，出现了123，而没有出现122，在250到260又出现了123。在这里122丢失，123重复了

	那是因为相同的排序值时，Mysql 的order by排序并不是稳定排序，而是随机的排序状态
	1.可以加上别的排序字段，把顺序确定下来
	2.用子查询，先把该弄的查出来，再排序


3.**DNS过程**
<ul>1.首先浏览器会有缓存，浏览器没有就去找hosts文件，再没有就调用getHostName方法</ul>
<ul>2.向本地服务器请求，看看本地dns服务器有没有缓存</ul>
<ul>3.本地服务器没有缓存，就通过本地服务器查找，没有，就交给13个根DNS服务器</ul>
<ul>4.根服务器找到相应的，就给本地服务器地址，让他自己去查，这就是迭代查询，重复找到为止</ul>
<ul>5.迭代查询和递归查询</ul>

	客户端和本地服务器，是递归查询，就是只得到一个结果
	本地服务器和根服务器，是迭代查询，就是告诉本地服务器，下一个查询的地址


---
<h1>10.12</h1>
1.做题
<ul>1.力扣650. 只有两个键的键盘，初始一个A，给一个数字N，只能做两种操作，复制和粘贴，问最少几次操作能做到N个A</ul>

	总的来说，就是看是不是素数，素数就是N次，非素数，就处理

		int h = (int)Math.sqrt(n);
        for(int i=3;i<n+1;i++){
            dp[i] = i;
            for(int j=2;j<=h;j++){
                if (i%j==0){
                    dp[i] = dp[i/j]+dp[j];
                    break;
                }
            }
        }
        return dp[n];
<ul>2.力扣496. 下一个更大元素 I，下一个更大的元素，单调栈模板</ul>

	一列数，找出下一个更大的，类似的场景有很多，一列高楼，一眼望过去看到的，一群人排队，能看到的最近的那个人。

	###单调栈
	因为栈是先进后出的，所以从后往前遍历，处理的时候就是从前往后。现在从后往前开始，设置一个res的返回数组。一个元素进来先判断，如果栈有，就比较栈顶的元素，如果栈顶的小，就说明看不到，就pop丢掉，直到空或者有更大的为止，然后把res设置好，当前元素进栈，就可以了

	
	##模板
	vector<int> ans(nums.size()); // 存放答案的数组
    stack<int> s;
    for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放
        while (!s.empty() && s.top() <= nums[i]) { // 判定个子高矮
            s.pop(); // 矮个起开，反正也被挡着了。。。
        }
        ans[i] = s.empty() ? -1 : s.top(); // 这个元素身后的第一个高个
        s.push(nums[i]); // 进队，接受之后的身高判定吧！
    }
    return ans;

	##循环就是 %N



<明天>
1.大数乘法手撸
2.推荐系统https://www.jianshu.com/p/e4deedf9a5e3

---
<h1>10.13</h1>
1.做题
<ul>1.力扣16. 最接近的三数之和，数组中找出三个数之和最接近target，保证有唯一结果</ul>

	###借鉴三数之和的做法
	固定一个数，另外两个数用双指针，这样的话就要数组先排序

	过程中记录下差值最小的就行
<ul>2.力扣94. 二叉树的中序遍历</ul>

	##迭代版本
	中序就是左根右，外面用一个栈，先左边走到黑，再弹出，检查右边有没有，这整个外面是一个while

		while (!s.isEmpty() || root!=null){
            while (root!=null){
                s.push(root);
                root = root.left;
            }
            TreeNode cur = s.pop();
            res.add(cur.val);
            root = cur.right;
        }


---
<h1>10.15</h1>

1.代码业务题目
<ul>1.循环队列实现</ul>

	最关键的思想，就是下标取模
	1.判断满：(rear+1)%n==front
	2.判断空：front==rear
	3.求长度：(n+rear-front)%n

<ul>2.LRU的o(1)实现</ul>

	1.数组实现
	两个数组，一个代表时间戳，其实就是一个数，另一个数组是元素本身。每一次操作，都让时间戳+1，更新和插入，都会让新元素时间戳置0，要删除的时候，删除时间戳最大的就行

	2.O(1)的双向链表
	两个东西，一个是用来查询的hashmap，一个是链表，保证顺序。
	首先定义头和尾，在链表中体现，hashmap中不体现。头和尾一直都在，新插入就放在头的后面，要删除的时候，就删除tail.pre，这个意思。把操作抽象出来，就是insertHead和remove(node)

	3.现成的lru
	linkedhashmap(cap,0.75f,true).
	true是访问顺序，插入更新的也算，false是插入顺序

<ul>3.两个栈实现队列，两个队列实现栈</ul>

	###两个栈实现队列
	只往stack1中加，pop的时候，从stack2中pop，2里面没有，就从1里面弹到2里

	###两个队列实现栈
	加的时候，看哪个有元素，就加在哪里，pop的时候，把有元素的弹出放进另一个，直到只剩下一个为止
<ul></ul>
<ul></ul>

---
<h1>10.18</h1>
1.**为什么不使用外键？**
<ul>1.外键就是，A表的某个字段，是另一个表的主键，就是外键。但是我们这里讨论的，不是把表融合在一起，变成一张表，而是考虑，需不需要，在数据库层面去建外键，或者是人为的规定即可</ul>
<ul>2.外键的用途</ul>

	就是foreign key，必须使用innodb。
	一张表中删除字段，另一张表中对应外键也会被删除。如果是更新，也会被更新，是数据库层面的，保证数据一致性的东西
<ul></ul>
<ul>2.结论</ul>

	不使用外键。这里说的外键是，数据库层面的，实实在在的外键。不通过数据库层面来保证数据一致性，而是代码层。

	1.降低数据库性能，在插入更新删除的时候，都会去检查另一张表。我们自己代码层，可能不需要查询，但是由于是外键，是肯定会去查的，所以性能上有问题
	2.并发，使用了外键，每次修改数据，都会去检查另一张表，并发量大，可能会有死锁
	3.拓展性：做平台迁移，分库分表，不好弄，相反，如果是代码层面，就很好搞
	4.最终还是效率。我们实际上，是允许一些多余数据的出现的，比如学生表和书表对应，删除了学生，书的记录也允许它存在，保证效率

---
<h1>10.19</h1>
1.redis缓存
<ul>1.缓存一致性</ul>

	###最终一致性
	给redis缓存设置时间，就算存在暂时的不一致，但是总归会失效，最终还是一致性的

	###先删缓存，再更新数据库
	出现问题：A操作写数据，缓存失效，这时候B操作来读，发现缓存没有，就从DB取，这时候A还没更新，把老数据弄到缓存去了，最后A才更新完数据库，这样缓存和DB数据不一致，缓存是脏的

	解决：延迟双删。先删缓存，进行DB更新，然后sleep一会，再删除一遍缓存。结尾再删一次，是为了删除数据库更新过程中的脏缓存，sleep是为了让其他操作，完整的把缓存弄好，保证读请求是结束的。休眠时间的确定，就是为了让读操作做完，预估一下读请求的时间即可。

	###先更新数据库，再删缓存
	问题：此时没有缓存，A操作去读，然后想要写缓存，此时一个B操作来写，更新完之后，A操作把老值写进缓存

	解决：上述问题需要一个条件，写更新的操作，要比读更快，这已经很困难了，所以该方案已经不错了。如果一定要解决，就保证，读操作完成后，删除缓存，让这时间内产生的脏缓存消失就行。

	###只更新缓存，异步更新数据库
	读不变，写的时候只写缓存，然后缓存异步的批量的区去更新数据库，这样只读写缓存，速度飞起，而且可以多条数据合并更新。借鉴了linux的Page Cache算法，所以同样的，会有数据丢失情况，就想linux强制关机数据丢失一样。



---
<h1>10.20</h1>
1.**泛型**
<ul>1.ClassCastException</ul>

	类型转换错误。比如有动物类，狗类和猫类是子类。
	Animal a = new Dog();
	Animal b = new Cat();
	(Dog)a;
	(Cat)a;
	
	第三行没错，第四行就错了。因为b本来是猫类，怎么能转换成狗类呢。所以，类型转换，必须要是相对应的子类才行。
<ul>2.泛型</ul>

	在jdk5以后加入的功能，比如 ArrayList arrayList1=new ArrayList(); 和 ArrayList<String> arrayList1=new ArrayList<String>();

	后者规定了添加进去的元素的类型，不符合就编译不通过。取出来的时候，也是相应的类型。
<ul>3.怎么实现的</ul>

	###类型擦除
	虽然代码定义中有着各自的类型，但是在jvm层面，看到的都是list的原始类型，可以狭义的理解成都是object类型。比如两个list，不同的泛型，但是getclass()==getclass()却是相等的，是true，就说明了这一点。
	
	###编译前的检查
	既然类型擦除，是怎么做到只能插入指定类型的，因为在java代码编译之间会进行检查，查看是否正确，直接编译不通过。

	定义一个带泛型的list，前后都要有泛型指定，哪个生效？是前面的，因为前面的是引用，所有的这种，都按照引用的来，ArrayList a=new ArrayList<String>(); 前面不用，后面用，其实就是object

	###其他的编译错误
	泛型前后不允许出现继承关系的类型。存object,取出是string，就是ClassCastException。存string，取出object，自己来强转，那你要泛型干嘛，违背设计初衷。所以都是编译错误。
<ul>4.既然类型擦出，我取出的时候怎么不是object</ul>

	像arraylist 的get方法，在最后就是做了强转的。
<ul>5.链接：https://blog.csdn.net/LonelyRoamer/article/details/7868820  他写的博客都很好，可以看看</ul>
<ul></ul>


---
<h1>10.21</h1>
1.spring事务
2.springmvc
3.jdbc
4.垃圾回收的算法名字。和cms

1.spring事务
<ul>1.本质：</ul>

	spring自己哪有事务，其实就是对数据库事务的封装。
	所以遵循数据库的隔离级别和出现的问题等，也就是可重复读啊，还有之类的

	spring 通过注解或者xml配置，帮我们把开启事务和提交/回滚操作给做了
<ul>2.传播级别</ul>

	什么叫传播呢？当两个方法A和B，都是一个事务方法，A调用B，那么B怎么算，算哪个事务呢，现在就需要事务传播级别

	propagation 
	REQUIRED：已有事务就加入，没有则新建
	SUPPORTS：已有事务就加入，没有就拉倒，非事务的执行
	MANDATORY：有就加入，没有加报错
	REQUIRES_NEW：如果已经有存在的事务，就把前一个挂起，执行现在这个
	NOT_SUPPORTED：总是非事务执行，并且挂起已经有的任何事务
	NEVER：总是非事务，有就报错
	NESTED

	上面这些，是这样用的
	@Transactional(propagation = Propagation.REQUIRED)



---
<h1>10.24</h1>
1.做题
<ul>1。力扣322. 零钱兑换</ul>

	给一些币值不同的硬币，和一个价格总额，求用最少的硬币买东西，需要最少多少个硬币。

	##动态规划
	f(n) = min(f(n),f(n-coin)+1)
	每一个n就是一个消费总额，每一轮都去算减去某个币值的最少个数
	初始都弄一个amount+1,就是不可能达到的


---
<h1>10.26</h1>
1.做题
<ul>1.最长回文子串</ul>

	###暴力
	前后两个下标，再去检查是不是回文，所以是 n的三次方的复杂度

	###动态规划
	dp二维数组，代表左右下标，右下标向后移，里面一层是左下标从0到i,当s[i]=s[j] 且 (dp[l+1][r-1] or r-l<3)，就Ok ，过程中保存最长的

<ul>2.力扣654. 最大二叉树，就是给一个数组，用最大的元素做根元素，构建二叉树，返回头结点</ul>

	def foo(nums,left,right)
	传入数组，和左右下标，遍历一遍找到最大元素的下标，新建cur节点，设置为最大的元素，然后cur.left = 递归下去。

	别忘了，cur.left = 递归的前提是，每一层的函数，都要return cur
	
		TreeNode cur;
        if(left==right){
            cur = new TreeNode(nums[left]);
        }
        if(left>right){
            return null;
        }
        int max = Integer.MIN_VALUE;
        int index = -1;
        for (int i = left;i<=right;i++){
            if(nums[i]>max){
                max = nums[i];
                index = i;
            }
        }
        cur = new TreeNode(max);;
        cur.left = dfs(nums,left,index-1);
        cur.right = dfs(nums,index+1,right);
        return cur;
<ul>3.力扣113. 路径总和 II，给一个普通二叉树，值可以重复，返回所有路径和为num的路径</ul>

	因为每个值都不一样而且是普通的树，所以都要查一遍，可以用回溯法。

	###
	复习回溯法模板，1.结束条件  2.for遍历或者啥的，总之是添加进去，处理，然后remove
<ul>4.力扣112. 路径总和，看有没有和为num的路径，返回布尔</ul>

	递归，首先是终止条件，root==null,return false，然后检查是不是叶子节点，并且和是不是，最后递归

---
<h1>10.27</h1>
1.做题
<ul>1.最短路径，有N个城市和M条路径，路径有权值，求走完的最短路径</ul>

	有几个先决条件：
	1.代表路径的邻接矩阵，一般是map[][]
	2.最短的路径值，初始值max
	3.一个集合或者数组，代表去过了

	dfs(起始点，已经有的权值)：
		结束条件：都去过了，或者权值已经超出了
		遍历，回溯，求最小的权值

	private static int dfs(int x, int s) {
        if(s > ans) return Integer.MAX_VALUE;       // 超过之前的最优路径，没必要继续走
        if(set.isEmpty()) return s;                 // 需要去的城市都去过，即找到路线
        int tmp = Integer.MAX_VALUE;                // 记录到达 x 之后， 后面的最短路线
        for(int i = 1; i <= n; ++i) {
            if(map[x][i] > 0 && vis[i] == 0) {
                boolean flag = set.remove(i);
                vis[i] = 1;
                tmp = Math.min(dfs(i, s+map[x][i]), tmp);
                vis[i] = 0;
                if(flag) set.add(i);
            }
        }
        return tmp;
    }
	
<ul>2.归并排序链表</ul>

	归并的思想，就是先拆成小的，再合并，总的就是 n logn

	###拆
	首先找到中点(偶数就是左边的那个)，用快慢指针法，slow=head,fast=head.next。 然后while head!=null and head.next!=null: slow=slow.next,fast=fast.next。这样最后slow就是中点。

	此时，slow.next=null，这样就切断了两个链表。然后两边递归。

	###合并
	新建一个节点n,然后再弄个m = n。
	如果两个节点都存在，n.next = 小的， h = h.next，这里就是小的后移一位，然后n = n.next,新的链表也后移一位，注意这里是while。弄完之后，哪个不为空就接上。
	
	最后返回m.next，这就是前面又引用了一遍的原因，m是新建的，所以返回后面的一个我们自己加的


---
<h1>10.28</h1>
1.做题
<ul>1.力扣559. N叉树的最大深度</ul>
<ul>2.力扣907. 子数组的最小值之和，一个int数组，所有可能的子数组搭配中，所有最小值的搭配</ul>

	###思路
	暴力法，移动前后下标，然后找最小，是n^3.

	现在换种思路，从某个元素左右出发，找寻左右方向上第一个比它大的元素，记录下表，那么这中间的就是以该元素为最小元素的，乘一下就好。而单调栈刚好就是适合找出下一个更大或者更小元素的东西。

	###单调栈
	一般都是在过程中，就把问题解决了。比如这道题，先从左到右遍历一遍，整个栈，空的时候就直接push，当发现栈不空，而且当前比较的元素，比top的大，就找到了cur的前一个，并存下来。假如cur更小，就pop，空了还不行就是没有，就是-1

	所以这里要遍历两遍
	

---
<h1>10.30</h1>

1.内存溢出和内存泄漏
<ul>1.概念</ul>

	内存泄漏：申请了内存，但是无法被释放
	内存溢出：分配给你的内存，满足不了需求，其实就是内存不够，就是OOM
<ul>2.内存泄漏的原因/解决</ul>

	总的：一个对象用不到了本来要被回收，但是被另一个引用了，比如是一个全局的hashmap，更甚至是两个对象互相引用

	具体：
	1.单例中使用了静态对象，生存周期和整个应用一样长
	2.内部类会持有外部类的引用，如果内部类中创建了静态实例，由于静态实例和应用的生命周期一样，所以会一直存在
	3.资源未正确关闭
	4.全局的hashmap中引用，就不会被回收

	###解决
	1.使用弱引用
	2.保持对生命周期的敏感，比如单例，全局容器

<ul>3.内存溢出原因/解决</ul>

	##原因
	1.内存泄漏过多引起的
	2.一次性读取了太多数据
	3.启动参数过小
	4.死循环

	###解决
	1.修改启动参数，-Xms，-Xmx参数一定不要忘记加
	2.检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。
	3.排查代码
	4.使用内存查看工具动态查看内存使用情况


---
<h1>10.31</h1>

1.记一次线上调优
<ul>1.过程</ul>

	1.top命令，发现java的某个进程cpu和内存占用率过高
	2.查看该进程具体情况 jinfo pid 9999，最后一行conmand line显示所有启动参数之类的
	3.查看gc情况， jstat gcacuse 9999，显示每个代上的gc次数和gc时间
	4.那就看看堆上内存具体怎么分布，jmap -heap 9999。
	###这里可能出现年轻代过小，频繁young gc，而且大文件直接进入老年代，老年代占用过大

	5.Java自动gc失败，那就命令行手动， jstat -gc 9999 1000

	###分析
	这里如果还不行，说明可能出现内存泄漏，泄露可能是僵尸线程，也可能是代码层面，总之去检查

	6.既然有可能是僵尸线程，就去看看线程，jstack 9999 | head -50，里面可以进行wc -l统计之类的。
	###在本例，发现线程过多，最多发现是对外连接数量过多，是es连接过多

	7.初步找出问题，更精确，就看堆，jmap -dump下来，用MAT分析堆快照，最后发现是有大量的连接池对象
<ul>2.参考：https://blog.csdn.net/u014730165/article/details/81984523</ul>
<ul></ul>
<ul></ul>