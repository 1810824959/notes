<h1>6.1</h1>

**1.数据库范式**
<ul>1.第一范式，符合不可分割的属性就可以</ul>
<ul>2.第二范式，不存在部分依赖</ul>
<ul>3.第三范式：在第二范式的基础上，也不存在传递依赖</ul>
<ul>4.一些概念的解析</ul>

	1.函数依赖：可以由A确定B，而且是绝对不重复的确定，就说B依赖于A
	2.完全依赖，一组码，只有他们都在一起时，才能确定另外的，叫做完全依赖，所以按理说，码只有一个，就一定是完全依赖
	3.部分依赖，码中的部分属性，也可以单独拿出来确定其他的属性，就是部分依赖
	4.传递依赖：一张表里，A确定B，B确定C，A和C之间没有必然的联系
<ul>5.为什么要有范式</ul>

	情景：现在登记学生信息，学号，姓名，成绩，课程名，老师，系名等等
	1.都放在一张表，主码是学号，系名是附加在学号上的，现在我要加一个系，系里还没有学生，咋办？？？或者说，没有这个系的学生在名单里，是不是就没有这个系？？？
	2.一个学生可以学很多课，有很多成绩，那系名之类的数据，就会反复出现，数据冗余
	3.某个学生转系了，要改的太多太多


2.从1月日记开始复习
<ul>1.数据库左右连接，内外连接：用法,select * from a a_XX left join b b_XX on a_xx.id=b_xx.id</ul>

	记住，左连接，右连接，说的都是关于join的位置

	SELECT * FROM tbl_dept a RIGHT JOIN tbl_emp b ON a.id=b.deptId 
	UNION 
	SELECT * FROM tbl_dept a LEFT JOIN tbl_emp b ON a.id=b.deptId;

	###
	上面这种复杂查询，可以这么写，也可以用嵌套

	###
	union是求并集这种的，而and or 是wehere条件时用的
<ul>2.tcp/udp区别</ul>

	1.面向连接与无连接
	2.占用资源多和少
	3.tcp保证顺序和稳定性正确性/udp一概不保证



<h1>6.2</h1>

**1.今日想做**
<ul>2.nio,netty</ul>
<ul>3.操作系统中，线程的状态</ul>
<ul>9.spring设计模式，ioc机制，aop机制</ul>
<ul>10.具体项目</ul>
<ul>11.Java socket</ul> 
<ul>13.二叉树遍历！！！！</ul>
<ul>14.设计模式的应用，比如装饰器在java iostream中的使用，在spring的使用？？</ul>
<ul>15单例具体？？，补充昨天的模式</ul>
<ul>16.sql慢查询</ul>

1.B树，B+树
<ul>1.介绍</ul>

	B树是一个平衡的多叉树，每一个节点都带着数据，某个节点有K个数据，他就可能被分成K+1个孩子，也同样是左小右大

	B+树对B树进行了拓展，中间的非叶节点，不带有数据，只是单纯的索引，数据全部在最下面的叶子节点上，而且和B树一样，一定是同一层，而且叶子节点之间，有指针相串联
<ul>2.各自优点</ul>

	B树非叶节点也储存数据，所以可能查询的时候不用到最下面的叶子节点，在中间就找到了，时间缩短

	B+树
	1.非叶节点不储存数据，所以设计更多的非叶节点也不占用内存，可以更加矮胖
	2.叶子节点之间有指针，对范围查询，或者遍历，非常友好
<ul>3.为什么用B/B+树，不用二叉树，红黑树</ul>

	每一层，或者说每一个节点，都是一次磁盘IO，B树更加矮胖，磁盘IO次数更加少

<ul>4.哈希索引：用hash函数定位相应的位置，所以等值查询的时候特别快，但是范围查询，排序，就毫无用处，像like ‘xxx%’  这种本质上就是范围查询，也没有用</ul>
<ul>5.具体使用</ul>

	CREATE INDEX index_name ON table_name(column_name(length))  
  
	ALTER TABLE table_name ADD INDEX index_name ON (column_name)  


<h1>6.3~6.6</h1>

**1.离职杂事与复习**


**2.分布式锁**
<ul>1.单机锁和分布式锁:</ul>

	单机上，一般是多线程的问题，syncronized关键字不知道怎么实现的，但是lock类是对某个volitile的int变量做可见的处理

	分布式麻烦一些，不仅是多线程，还涉及多进程，那么关键点就从同一台机器上的共享变量，变成多台设备之间的共享存储，就是放到所有进程都看得到的地方
<ul>2.基于mysql</ul>

	1.表主键：innodb插入时会有行锁，所以同时的插入只会有一个成功，而且一旦某个主键有了记录，再次插入相同主键，就会失败，插入成功就说明获得锁，删除记录就是释放

	2.乐观锁实现：每个表设一个版本号字段，乐观锁,里面弄个state，空着或是被占用，乐观方式update实现分布式
<ul>3.基于redis</ul>

	使用setnx和expire，也就是set插入，NX就是不存在时才插入，并设置过期时间，也避免了锁不被释放

	###出现的问题
	但是这样不保险，当A获得锁，但是和redis之间挂了，这个expire被B和C检测到了，都发现了超时，B先删除原来，更新了新的，C也知道超时，也进行删除，但删除的是B更新的，然后更新成C的，这样B得到锁，C也得到锁

	###解决
	B和C同时发现超时，不删除，而是进行getset，把那个expire更新，B发现超时，算出自己的超时时间，更新一次，C发现超时，也查一下，发现是B的更新过了的，不是超时的，就不更新了

	###RedLock实现高可用
	不再是redis单机，而是集群，对集群每台都进行一样的操作，超过半数台就OK

	

<h1>6.8</h1>
<ul>1.jstat</ul>
<ul>2.数据库持久化</ul>
<ul>3.redis</ul>
<ul>4.zookeeper做亮点</ul>
<ul>5.mvcc</ul>
<ul>6.hashmap jdk7的死循环</ul>
、

<h1>6.9</h1>

**1.ZooKeeper**
<ul>1.用途：网上一大堆，我自己看上去有用的是，分布式锁，命名管理，通过选举解决单点故障，管理配置（配置更新，直接同步到注册的每台机器上），甩链接：https://blog.csdn.net/zhanaolu4821/article/details/81103005</ul>
<ul>2.分布式锁</ul>

	要拿锁，就去zk某目录下创建临时节点，设置编号最小的得到锁，其余失败，失败的可以对比自己小 1 的进行监听，不在了就拿锁
<ul>3.zk 做分布式锁，和redis的优缺点</ul>

	redis:性能高
	zk:性能不高，因为对于锁的操作，都是创建和删除临时节点的，而且写操作只能leader节点做，并同步都foller等节点，比较慢，但是解决了单点故障，可重入，锁无法释放的问题

<ul>4.选举FastLeaderELection</ul>

	两种情况选举：1.刚启动 2.leader挂了
	核心思想：比较zxid（事务id，一般是时间戳） 和 myid（机器id），优先看zxid，且都是大的先

	当超过半数统一了意见，就算是选出了新leader，在选举期间，对外不开放，所以也能理解机器数小于N/2-1 ，zk集群会崩，因为选不出leader

<h1>6.10</h1>

1.zk的ZAB
<ul>1.定义：ZooKeeper Atomic Broadcast protocol，也就是zk的自增广播协议，包括两个部分，请求跟恢复</ul>
<ul>2.请求：当leader还在的时候，leader收到消息，首先复制给follower们，follow收到会回复ack，当超过半数ack，leader就觉得ok了，并commit自己的，然后对每个follow发送commit</ul>
<ul>3.恢复阶段：其实就是选举</ul>

2.zk的数据同步
<ul>1.情景：数据更新的过程中，有部分foller节点挂了，等他们重连的时候，数据怎么同步</ul>
<ul></ul>

3.mysql备份恢复
<ul>备份：格式：mysqldump -h主机名  -P端口 -u用户名 -p密码 –-databases 数据库名 > 文件名.sql </ul>
<ul>恢复：mysql -h 10.6.208.183 -u test2 -p 123  -P 3310 < test.sql（看到没 < 和 > 的方向不一样）</ul>
<ul>注意：导入的时候，需要是一个空的数据库</ul>

<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>