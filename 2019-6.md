<h1>6.1</h1>

**1.数据库范式**
<ul>1.第一范式，符合不可分割的属性就可以</ul>
<ul>2.第二范式，不存在部分依赖</ul>
<ul>3.第三范式：在第二范式的基础上，也不存在传递依赖</ul>
<ul>4.一些概念的解析</ul>

	1.函数依赖：可以由A确定B，而且是绝对不重复的确定，就说B依赖于A
	2.完全依赖，一组码，只有他们都在一起时，才能确定另外的，叫做完全依赖，所以按理说，码只有一个，就一定是完全依赖
	3.部分依赖，码中的部分属性，也可以单独拿出来确定其他的属性，就是部分依赖
	4.传递依赖：一张表里，A确定B，B确定C，A和C之间没有必然的联系
<ul>5.为什么要有范式</ul>

	情景：现在登记学生信息，学号，姓名，成绩，课程名，老师，系名等等
	1.都放在一张表，主码是学号，系名是附加在学号上的，现在我要加一个系，系里还没有学生，咋办？？？或者说，没有这个系的学生在名单里，是不是就没有这个系？？？
	2.一个学生可以学很多课，有很多成绩，那系名之类的数据，就会反复出现，数据冗余
	3.某个学生转系了，要改的太多太多


2.从1月日记开始复习
<ul>1.数据库左右连接，内外连接：用法,select * from a a_XX left join b b_XX on a_xx.id=b_xx.id</ul>

	记住，左连接，右连接，说的都是关于join的位置

	SELECT * FROM tbl_dept a RIGHT JOIN tbl_emp b ON a.id=b.deptId 
	UNION 
	SELECT * FROM tbl_dept a LEFT JOIN tbl_emp b ON a.id=b.deptId;

	###
	上面这种复杂查询，可以这么写，也可以用嵌套

	###
	union是求并集这种的，而and or 是wehere条件时用的
<ul>2.tcp/udp区别</ul>

	1.面向连接与无连接
	2.占用资源多和少
	3.tcp保证顺序和稳定性正确性/udp一概不保证



<h1>6.2</h1>

**1.今日想做**
<ul>2.nio,netty</ul>
<ul>3.操作系统中，线程的状态</ul>
<ul>9.spring设计模式，ioc机制，aop机制</ul>
<ul>10.具体项目</ul>
<ul>11.Java socket</ul> 
<ul>13.二叉树遍历！！！！</ul>
<ul>14.设计模式的应用，比如装饰器在java iostream中的使用，在spring的使用？？</ul>
<ul>15单例具体？？，补充昨天的模式</ul>
<ul>16.sql慢查询</ul>

1.B树，B+树
<ul>1.介绍</ul>

	B树是一个平衡的多叉树，每一个节点都带着数据，某个节点有K个数据，他就可能被分成K+1个孩子，也同样是左小右大

	B+树对B树进行了拓展，中间的非叶节点，不带有数据，只是单纯的索引，数据全部在最下面的叶子节点上，而且和B树一样，一定是同一层，而且叶子节点之间，有指针相串联
<ul>2.各自优点</ul>

	B树非叶节点也储存数据，所以可能查询的时候不用到最下面的叶子节点，在中间就找到了，时间缩短

	B+树
	1.非叶节点不储存数据，所以设计更多的非叶节点也不占用内存，可以更加矮胖
	2.叶子节点之间有指针，对范围查询，或者遍历，非常友好
<ul>3.为什么用B/B+树，不用二叉树，红黑树</ul>

	每一层，或者说每一个节点，都是一次磁盘IO，B树更加矮胖，磁盘IO次数更加少

<ul>4.哈希索引：用hash函数定位相应的位置，所以等值查询的时候特别快，但是范围查询，排序，就毫无用处，像like ‘xxx%’  这种本质上就是范围查询，也没有用</ul>
<ul>5.具体使用</ul>

	CREATE INDEX index_name ON table_name(column_name(length))  
  
	ALTER TABLE table_name ADD INDEX index_name ON (column_name)  


<h1>6.3~6.6</h1>

**1.离职杂事与复习**


**2.分布式锁**
<ul>1.单机锁和分布式锁:</ul>

	单机上，一般是多线程的问题，syncronized关键字不知道怎么实现的，但是lock类是对某个volitile的int变量做可见的处理

	分布式麻烦一些，不仅是多线程，还涉及多进程，那么关键点就从同一台机器上的共享变量，变成多台设备之间的共享存储，就是放到所有进程都看得到的地方
<ul>2.基于mysql</ul>

	1.表主键：innodb插入时会有行锁，所以同时的插入只会有一个成功，而且一旦某个主键有了记录，再次插入相同主键，就会失败，插入成功就说明获得锁，删除记录就是释放

	2.乐观锁实现：每个表设一个版本号字段，乐观锁,里面弄个state，空着或是被占用，乐观方式update实现分布式
<ul>3.基于redis</ul>

	使用setnx和expire，也就是set插入，NX就是不存在时才插入，并设置过期时间，也避免了锁不被释放

	###出现的问题
	但是这样不保险，当A获得锁，但是和redis之间挂了，这个expire被B和C检测到了，都发现了超时，B先删除原来，更新了新的，C也知道超时，也进行删除，但删除的是B更新的，然后更新成C的，这样B得到锁，C也得到锁

	###解决
	B和C同时发现超时，不删除，而是进行getset，把那个expire更新，B发现超时，算出自己的超时时间，更新一次，C发现超时，也查一下，发现是B的更新过了的，不是超时的，就不更新了

	###RedLock实现高可用
	不再是redis单机，而是集群，对集群每台都进行一样的操作，超过半数台就OK

	

<h1>6.8</h1>
<ul>1.jstat</ul>
<ul>2.数据库持久化</ul>
<ul>3.redis</ul>
<ul>4.zookeeper</ul>
<ul>5.mvcc</ul>
<ul>6.hashmap jdk7的死循环</ul>
、

<h1>6.9</h1>

**1.ZooKeeper**
<ul>1.用途：网上一大堆，我自己看上去有用的是，分布式锁，命名管理，通过选举解决单点故障，管理配置（配置更新，直接同步到注册的每台机器上），甩链接：https://blog.csdn.net/zhanaolu4821/article/details/81103005</ul>
<ul>2.分布式锁</ul>

	要拿锁，就去zk某目录下创建临时节点，设置编号最小的得到锁，其余失败，失败的可以对比自己小 1 的进行监听，不在了就拿锁
<ul>3.zk 做分布式锁，和redis的优缺点</ul>

	redis:性能高
	zk:性能不高，因为对于锁的操作，都是创建和删除临时节点的，而且写操作只能leader节点做，并同步都foller等节点，比较慢，但是解决了单点故障，可重入，锁无法释放的问题

<ul>4.选举FastLeaderELection</ul>

	两种情况选举：1.刚启动 2.leader挂了
	核心思想：比较zxid（事务id，一般是时间戳） 和 myid（机器id），优先看zxid，且都是大的先

	当超过半数统一了意见，就算是选出了新leader，在选举期间，对外不开放，所以也能理解机器数小于N/2-1 ，zk集群会崩，因为选不出leader

<h1>6.10</h1>

1.zk的ZAB
<ul>1.定义：ZooKeeper Atomic Broadcast protocol，也就是zk的自增广播协议，包括两个部分，请求跟恢复</ul>
<ul>2.请求：当leader还在的时候，leader收到消息，首先复制给follower们，follow收到会回复ack，当超过半数ack，leader就觉得ok了，并commit自己的，然后对每个follow发送commit</ul>
<ul>3.恢复阶段：其实就是选举</ul>

2.zk的数据同步
<ul>1.情景：数据更新的过程中，有部分foller节点挂了，等他们重连的时候，数据怎么同步</ul>
<ul></ul>

3.mysql备份恢复
<ul>备份：格式：mysqldump -h主机名  -P端口 -u用户名 -p密码 –-databases 数据库名 > 文件名.sql </ul>
<ul>恢复：mysql -h 10.6.208.183 -u test2 -p 123  -P 3310 < test.sql（看到没 < 和 > 的方向不一样）</ul>
<ul>注意：导入的时候，需要是一个空的数据库</ul>


<h1>6.11</h1>

**1.杂**
<ul>1.Thread的start和run</ul>

	线程状态：创建，就绪，运行，阻塞，死亡
	start调用之后，相当于线程进入就绪状态，也就是进入一个队列，等待调度
	run内的就是方法体，run调用就是运行状态


**2.http协议**
<ul>1.http1.0和http1.1</ul>

	##1.1支持长连接且默认就是长链接，1.0不支持，只有短连接
	##1.1有host字段，1.0没有
	##1.1允许客户端只发送一个header，服务端可以返回100（1.1新加的，表示有权限访问）
	
<ul>2.http状态码</ul>
	
	100：http1.1新加的，表示该header有权限访问
	200：成功
	300：重定向
	400：客户端错误  404 not found
	500：服务端错误  502("Bad Gateway")  

<ul>3.长连接</ul>

	这是http1.1加入的新功能，要使用的时候，头部加入Connection:keep-alive

	其实http的长连接，就是tcp的长连接，或者说是tcp连接的复用，为了避免每次连接都要三次握手，四次挥手，降低了效率，消耗了性能，所以长连接中，连接不会立马断开，而是会停留一阵子

	###长连接缺点
	服务端维护了过多连接，就会占用太多资源，这时候服务端会定期探测连接是否存活，并且为了防止某个客户端连接数太多，会限制单个客户端的连接数量

	###应用场景
	现在大部分都是http1.1了，而且是协议本身控制的，不受编程影响，能影响的是长短轮询而已（关于长短轮询和长短连接：https://blog.csdn.net/luzhensmart/article/details/87186401）
<ul>4.http和https</ul>

	https本质上是http的安全版，就是在http上加了一层SSL加密层（这个解释太过笼统）

	###对http的改进（流程）
	http一直是明文传输的，可能会有加密，但还是明文的，现在https采用了两层加密，一方面，对要传输的数据进行对称加密，然后把加密的密钥，进行非对称加密

	1.客户端和服务端沟通，拿到服务端的证书（内含公钥）
	2.确认证书无误后，随即生成对称加密要用的密钥，进行对称加密，同时顺便把密钥用刚才的公钥加密了，一起发送给服务端
	3.服务端收到加密过的密钥，和密文，用自己的私钥得到密钥，再用密钥得到明文，过程结束
	PS 4.如果服务端还要回传，那就用已经解密的密钥，来加密信息，发回给客户端，因为反正是对称加密，而且双方都知道了密钥

	###其他注意点
	1.http 80 , https 443
	2.https要用到证书，里面就有公钥之类的，而且一般免费的很少
	3.对称加密有DES，AES，非对称有RSA
	
<ul>5.header属性</ul>

	###request请求
	Host: 47.106.71.188:9999
	Connection: keep-alive
	Cache-Control: max-age=0
	Upgrade-Insecure-Requests: 1
	User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
	Referer: http://47.106.71.188:9999/in
	Accept-Encoding: gzip, deflate
	Accept-Language: zh-CN,zh;q=0.9
	Cookie: ticket=2d3dd46768a04e52a7d8e8e83a673c11

	###response
	Content-Type: text/html;charset=UTF-8
	Date: Wed, 12 Jun 2019 04:46:39 GMT
	Expires
	Server
	Set-cookie



<h1>6.12</h1>

**1.cookie和token**
<ul>1.概述：cookie都是针对http无状态设计的，目的是让服务端能记住客户端，使得不用每次登录都要查询数据库账号密码什么的</ul>
<ul>2.cookie</ul>

	###cookie一般都搭配session使用
	1.客户端第一次请求，服务端查数据库验证账号密码，验证好了之后，服务端自己存一个session，一般是内存，也可以是数据库，把对应的session_id放在cookie里面，然后set-cookie
	2.客户端收到，然后就有cookie了，以后再请求，就带着cookie过去，server收到拿出session_id，去查数据库或者其他，发现有这条记录，就通过，认为它前面就登陆过
	3.用户登出，服务端的session要删除，客户端的cookie一般也要删除

<ul>3.token</ul>

	###token流程
	1.用户发起请求，服务器查数据库验证账号密码，OK就生成一个token（token生成一般有一定规则，而且服务端并不保存），发回给客户端
	2.客户端下次请求，把token放在header中，服务端收到，验证它的正确性（一般是这样，token发一份，然后cookie中有一份加密的token，验证他们是否一样）
	3.用户登出，因为服务端没保存，所以客户端自己删除就好了

<ul>4.token和cookie的区别（或者说优点）</ul>

	1.cookie在服务端有session存储着，而token验证，服务端没有存储，只需要验证token的有效性而已，而使用cookie就会存在session太多，占用资源的问题，当然也可以采用session-token的机制

	2.cookie跨域很麻烦，只能同域或子域，而token没有限制

	3.移动平台对cookie支持不太方便，大多使用token

	4.token可以防止csrf

	5.JWT可以顺便存放数据？？？
<ul>5.token防止csrf</ul>

	csrf就是通过你的身份，来伪造你的请求，打比方，你当前页面已经登陆过了，有了cookie，页面上有个隐藏的跳转或者url，不小心触发之类的，就带着你的cookie去访问了，但实际上你不希望这么做，它只是盗用了你的cookie

	###使用token来防护
	把token放在本地存储，而非cookie中，请求的时候，需要带着token，但是攻击方拿不到token，他们顶多拿到cookie,token错误或者无效，就没用

	###当然了，还可以通过检查referer来防止csrf

<ul>6.token有两种，一种是token-session，一种是服务端不存，服务端保存一个密钥比如用设备号，mac地址之类的加密，只要服务端能验证就好</ul>


**2.疑问**
<ul>1.JWT？？？</ul>


<h1>6.13</h1>

**1.杂**
<ul>1.线程同步的方式</ul>

	临界区：只能独占着来，有了一个，其他就进不来
	互斥对象：只能被一个占用，只有拿着该对象才能范文公共资源
	信号量：一般用可用资源的最大值为信号量，用一个就-1，0就不能占用
	事件通知：相当于wait/notify
<ul>2.进程通信方式，详解</ul>

	1.管道：无名管道用于父子进程通信，有名管道可以任意
	2.信号量：和线程介绍的一样，是一个整数，一般用作锁机制
	3.消息队列：是内核中的消息队列
	4.信号：类似于wait/notify，也是通知进程同步的东西
	5.共享内存：多个进程共享一个内存
	6.socket：不同机器的进程通信
<ul></ul>


**2.死锁**
<ul>1.简单的死锁例子</ul>

	class MyThread:
		int flag = 1
		run(){
			if flag=1:
				对A加锁：sleep 5秒
				再对B加锁
			
			if flag=0:
				对B加锁：sleep 5秒
				再对A加锁
		}

	###两个线程分别继承，一个flag=1，另一个为0，这样就会死锁

<ul>2.解决死锁：其实就是破坏死锁的条件</ul>
	
	###预防层面
	1.在等另外线程的同时，不释放已占用的（那就让它可以被释放）
	2.环路等待，有互相等待的情况（要么一次性给够资源，要么就释放代价最小的线程的资源）
	###解决层面
	3.从其他进程剥夺足够的资源给他
	4.直接撤销相关进程


<ul>3.银行家算法：很简单，就是一个试探进程资源分配安全性的东西，找出一个安全序列，让可分配的资源，始终大于需求就行</ul>

**3.进程调度算法**

	1.先来先服务：可能导致长作业长期占用CPU
	2.短作业优先：短的先上，可能导致长的任务一直上不去
	3.带优先级的（分为抢占与非抢占）：抢占的就是，一个任务正在跑，更高优先级的来了，就立刻让位子，非抢占就是等现在的这个弄完再说

	***4.高响应比优先调度：说白了，就是它的优先级是按照任务时间长度和等待时间来的，等了越久，优先级越高，时间越短，优先级也高。他照顾了两方面：有两个任务，等待时间一样，那短的先来，如果任务时间一样，等的久的先来

	5.时间片轮转调度：有一个队列，上面的每个进程，都只运行一个时间片的time，超过就移到队列最后。时间片定的太长，就慢慢退化成先来先服务，定的太短，就要频繁切换，增加了CPU浪费


<h1>6.16</h1>

1.**String/StringBuffer/StringBuilder**
<ul>String:是final修饰的，不可变，而且频繁做字符串拼接，浪费内存，底层是char数组</ul>
<ul>StringBuffer:相对String来说，是可变的，所以相对来说做拼接会节约一些资源，因为不会创建很多新的对象。最重要一点，它线程安全</ul>
<ul>StringBuilder:可变，但是线程不安全，相当于不安全，但快速的StringBuffer</ul>


<h1>6.21</h1>

**1.前段时间总结**
<ul>1.主要都在复习信息论与编码，是门硬课</ul>
<ul>2.查看牛客网的招聘信息，现在正式重新开始复习</ul>

**2.位图算法**
<ul>例题：找出40亿数中重复的数</ul>
<ul></ul>

**3.数据库null值**
<ul>1.Null和空字符串"":在mysql中不同的，而在Oracle中是相同的</ul>
<ul>2.索引和Null的关系：</ul>

	按道理说，索引是为了加快查询，而且B+树索引中有排序的操作，我猜测Null值是不允许的，**但实际是允许的!!!!!!**

	除了主键本身是不允许Null的，所以主键索引不能null，另外都是可以存在NUll值的。

	###但是不推荐存在NUll
	1.Null值并没有节约资源，Null 列需要更多的存储空间，需要一个额外字节作为判断是否为 NULL 的标志位，这就是mysql对null的特殊处理，而空字符串反而不占空间
	2.当null被索引，每条记录都需要一个额外的字节
	3.做统计，null不会被统计进来，而空字符串可以
	4.上面提过的，空字符和Null不同


<h1>6.22</h1>

**1.浏览器从输入网址到看到网页的全过程**
<ul>1.键盘接受输入，产生微小电流，操作系统产生中断，发送到应用程序</ul>
<ul>2.浏览器检查url是否符合规范，并从中得到协议(http)，域名或者ip（/之后的内容），还有路径（后缀）</ul>
<ul>3.DNS查询，拿到域名，总要知道ip地址</ul>

	1.首先在chrome自身缓存中找
	2.chrome找不到就首先调用系统 gethostbyname 的库函数，gethostbyname 会先在本地HOSTS里面找，没有就向DNS服务器发送查询请求 

<ul>4.得到了IP地址，就调用套接字，封装成tcp的包，进行三次握手，建立连接</ul>
<ul>5.连接之后，发送http包，服务器进行响应</ul>
<ul>6.浏览器解析页面</ul>
<ul>7.连接断开，就是四次挥手</ul>


**2.由ARP协议衍生出来的想法**
<ul>1.ARP就是域名解析协议，把IP 变成mac地址</ul>
<ul>2.ip数据报在链路层的传输：</ul>

	通常说，网络层通过ip协议传输数据报，是不准的，其实还经过了链路层的传输，在这一层，数据包被封装成以太数据帧，通过mac地址传输。

	###在同一子网中传输
	首先拿到ip地址，根据掩码，进行与操作，判断是不是一个子网的，这里假设是。

	先查看自身是否保存有对方的mac地址，没有就进行第二层广播，发送目标ip，子网中如果有主机发现自己ip与广播的一样，就回复自己mac地址，这样数据就完整了，可以发送了

	###不在同一子网
	和上面差不多，先传到当前子网的路由器，然后路由器通过路由算法，传到目的子网，另外一样
<ul>3.DNS查询和ARP的关系</ul>

	其实本质上没啥关系，但是，当DNS服务器在同一子网中，和不在同一子网中，会有上面提过的差别

	###DNS到底是UDP还是TCP
	DNS占用53端口，TCP/UDP都有，但是大部分时间用的是UDP，比如DNS查询，解析，都用的TCP，只有在区域传输才用TCP，因为数据量大且要保证可靠传输。普通的使用UDP最大原因是快，其次一般DNS查询数据包都不大，不超过512


<h1>6.23</h1>

1.协议补充
2.redis补充


<h1>6.27</h1>

**1.状态码301和302的区别**
<ul>1.区别</ul>

	301是永久性转移，一般是比如域名更换，之类的，访问老域名的时候，会跳转到新域名，搜索引擎也会收录新的url

	302是临时性转移，比如登录之后的重定向，或者是微博短域名这种，之后做的重定向，搜索引擎还是会保留原来的旧网址
<ul>2.重定向的概念</ul>

	访问某url，服务器返回 3XX 状态码，浏览器根据响应头的location来进行跳转


**2.面试中问到的一些突破反爬的策略**
<ul>1.蜜罐：就是给出一些正常用户不会访问的，但是爬虫经常去访问的资源</ul>

	比如 hidden属性，比如display:None，比如src链接或者元素在页面之外，普通人根本看不到，又或者被iframe所遮盖

	遇到这种，只能进行具体分析，并且在爬取之前对相关元素进行这类的检测，确认是不是能被人所看到
<ul>2.投放脏数据</ul>

	比如html代码中是123，人眼在网页上看到是567，通过字体的变化，来做。这种就可以直接查看页面的字体，找出对应规律

<ul>3.根据以上的，后端有一些方法来检测是不是爬虫：这时候我们一般要带上一些上下文操作，比如加上refer，比如模仿一下正常用户的操作和行为轨迹，争取像个正常用户</ul>
<ul>4.还有个很脏的办法，就是把自己伪装成百度，搜狗这种搜索引擎的UA</ul>
<ul>5.https://www.zhihu.com/question/58342241  这上面受教了</ul>

3.**mysql分页优化**
<ul>1.mysql分页：一般是用select xxx from xxx order by xxx DESC/ASC limit 1000 10 ，类似于这种，意思是从1000开始，取10条 </ul>
<ul>2.分页非常慢：</ul>

	limit的分页，在表的前面一些，还算快，越到后面越慢，为什么？？？因为limit 100 10，这个意思是先读取110条，然后舍弃100条，最后再返回10条，所以前面的起始部分，也是要查询的

	###怎么解决？
	写在了纸上，实在是不好描述



面经 1.06.17

<ul></ul>


<h1>6.29</h1>

**1.mysql优化再复习**
<ul>1.分页优化</ul>

	分页一般用 select * from table where 条件 order by 排序字段 limit 9000000,10; 诸如此类

	###limit慢的原因
	比如limit 900,10 实际上是查询了910条，然后舍弃前面900，返回10条，所以当到了后面，要查询的量会非常大
	
	###
	select * from table limit 1000000,10
	上面这个很明显，直接是全表扫描，这里就可以提出几种优化方式
	1.剪切select 的字段，因为查询的时候不一定是所有字段都需要的，实际上，如果万一后面有where之类用到了索引的东西，前面select中有不在索引中的字段，mysql就会在用索引查到相应行后，再去查询行上的其他数据，很浪费
	2.让语句走索引，修改一下，加上order by 或者where总之是加上索引

	###
	select * from table order by id limit 1000000,10;
	而这一种情况，也提出几种优化建议
	1.节约字段开销，使用子查询  select * from table where id>=(select id from table order by id limit 1000000,1) limit 10; 本来的sql是，查到相关行的所有字段数据，再limit，修改后，先查相关行的id，而id是有索引的，快很多，在用where走索引，又快很多
	1.join法，也可以直接分成两个表，思想和上面的差不多
	SELECT * FROM table AS t1   
	JOIN (SELECT id FROM table ORDER BY id  LIMIT 1000000, 1) AS t2   
	WHERE t1.id <= t2.id ORDER BY t1.id desc LIMIT 10; 

	###
	select * from table where xxx order by xxx limit 1000000,10;
	这里用到了where条件查询，需要注意，一条语句，只能用到一个索引！！所以where 和 order by需要是同一个索引，要么是联合索引
	1.联合索引
	2.前面一样的，join法


	###如果这些都搞不定，就上大数据吧，hive,hbase
	

<ul>2.mysql的排序</ul>

	mysql的排序主要是两种机制，索引排序和文件排序(fileSort)

	索引排序就是取遍历B+树的叶子节点，总之走的是索引，explain结果那里Extra = Using Index，而没有索引或者走不了索引，就是fileSort，mysql先找出相关行，再进行排序，相应的，应该会慢很多，就是Using fileSort

	###总结
	order by 就是为了避免filesort的，尽管fileSort的效率不一定比索引差

<ul>3.一个sql语句，只能使用一个索引!!!</ul>


<ul>临时表消耗太大</ul>
<ul>FORCE INDEX (create_time)</ul>
<ul>这是因为通常ORDER BY子句会与LIMIT子句配合，只取出部分行。如果只是为了取出top1的行 却对所有行进行排序，这显然不是一种高效的做法。这种场景下 按顺序取的索引扫描排序可能会比filesort拥有更好性能（当然也有例外）。</ul>
<ul>字段长度定义合适就好（避免过长）</ul>


<ul>4.Explain详解</ul>

	+----+-------------+--------+------------+------+---------------+------+---------+------+----------+----------+-------+
	| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra |
	+----+-------------+--------+------------+------+---------------+------+---------+------+----------+----------+-------+
	|  1 | SIMPLE      | person | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10284764 |      100 | NULL  |
	+----+-------------+--------+------------+------+---------------+------+---------+------+----------+----------+-------+
<ul>字段说明：https://www.cnblogs.com/butterfly100/archive/2018/01/15/8287569.html</ul>

	###select_type
	simple:简单查询
	primary:复杂查询中的外部查询
	subquery：包含在 select 中的子查询（不在 from 子句中）
	derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）
	union：在 union 中的第二个和随后的 select

	###type(从坏到好)
	ALL：全表扫描
	index:遍历索引树
	range:有范围的查找索引树
	ref: 说人话，索引和某个值相比较，比如where xxx="xxx"
	eq_ref: 介于ref和const之间，贼少见，这个只出现在不同表用主键做连接的时候，同一张表主键查用const，不同表用非主键，是ref
	const、system: 是ref的高级版，用的是唯一索引或者主键，在一张表中查询，就是const，如果该表只有一行，就是system
	NULL: 最快，甚至不用访问表和索引，直接拿着最大的最小的就行了，比如 min , max

	###Extra
	distinct: 一旦mysql找到了与行相联合匹配的行，就不再搜索了
	using fileSort:用到了文件排序
	using index：直接用索引就做完了，根本没去读数据
	using where：需要回表查询，不能单单靠索引（这里是有问题和争议的，但是暂时这么写）
	Using temporary？？？
<ul>5.关于联合索引</ul>

	联合索引有最左原则，不符合呢？？？
	
	实际上，不符合最左原则，比如 (a,b,c)是联合索引，这里where b>5; 的确，他不会走整个的联合索引，type就不是range，但是实际上，他还是会显示走了索引，依旧是这个联合的索引，但type=index，是遍历了整个索引树

	理解：联合索引，一级二级三级，可以理解成，一级是有序的，二级在一级的基础上才是有序的，所以单独的二级不能触发整个联合索引，但是mysql可以优化，弄成type=index的遍历，依旧要比all全表扫描要好



<h1>6.30</h1>

**1.杂**
<ul>1.order by 默认是asc，也就是升序</ul>
<ul>2.mysql里 != 和 <> 都可以用，看具体版本，都是不等于的意思</ul>
<ul>3.自己制作千万级测试表，从已有的1000条中，随机选出若干条，再插回去</ul>
<ul></ul>
<ul></ul>
<ul></ul>

**2.索引失效的时候**
<ul>1.不符合联合索引的最左原则</ul>
<ul>2.模糊查询 like "%xxx%"</ul>
<ul>3.使用 != 或者 <> ,可以使用 小于 union 大于</ul>
<ul>4.对索引的字段做运算 ，比如 where age +10 > 30</ul>


**3.优化终极方法**
<ul>1.语句优化</ul>

	1.select 选取的字段进行裁剪，不要select *
	2.减少临时表的大小，比如上面提过的用子查询，join优化
	3.字段长度尽量小，如果实在太大，就多设置一个字段存他的hash，到时候查hash(hash 会有冲突，但是代价比起查询时间，可以接受)

<ul>2.索引</ul>

	1.用explain分析，判断走的什么索引，索引是否生效等等
	2.对where 和 order by 等，建立联合索引
	3.有时候可以强制用索引，并指定用哪个索引 ：FORCE INDEX (index_name)
	4.有些时候索引不生效，注意

<ul>3.引擎方面，myisam和innodb的选用</ul>
<ul>4.另外的经验之谈</ul>

	1.简化法，每次减少一个查询的条件，找到影响效率的主要原因
	2.开启慢查询
	3.开启时间记录，set profiling=1，并 show profiles
