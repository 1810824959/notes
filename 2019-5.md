<h1>5.1</h1>

1.想法
<ul>最近几天各种杂事，没有真正静下心学习，但是也思考了很多另外的东西，列一下</ul>

	1.笔记上写的东西越来越多，但是好多记下又忘了，一定要定期复习!!!
	2.面试的准备，很多要现在开始准备了，打有准备的仗（本地单开一帖）
	3.面经要看，在收藏里头
	4.优秀的人太多，需要追赶的人也太多，我还有自己的一些小小的私心，想要有所成就去找她，不能这样随便的放弃

2.小疑问
<ul>1.他们平时mongo数据都是怎么导出的？？？</ul>



<h1>5.2</h1>

1.类加载机制和类加载器
<ul>1.类加载机制：加载，验证，解析，准备，初始化</ul>

	准备阶段，给类变量（static变量）赋值，0或null
	初始化阶段，先静态，再普通，最后构造

<ul>2.类加载器</ul>

	Java中类加载分两种，1.自带的装载，也就是new，2.手动装载，就是Class.forname()这种的，多用于反射

	而java在虚拟机启动时，会自动装载程序运行的基础类，另外的在用到时才会装载，这样就节约了内存，也算是动态性的体现。

	###类加载器具体分类（自顶向下）
	1.bootstrap loader：这是启动时的类加载器，并不是java写成的，是C++，负责加载JRE/lib/里面的class，和-Xbootclasspath参数指定的路径里的类（并且要符合命名规范，比如rt.jar ，否则放在lib里，也不会加载）

	2.Extension loader:扩展的类加载器，负责加载JRE/lib/ext里的class，和java.ext.dirs系统变量指定的路径中类库

	3.application loader:应用级（系统级）类加载器，负责加载classpath下的类和jar，通常ClassLoader 的 getSystemClassLoader()返回的就是这个

	4.自定义类加载器：继承java.lang.ClassLoader，并重写父类的findClass方法，例如tomcat之类的容器都有自己类加载器，而且不太一样，优先加载自己的，没有再去向上委托


	###双亲委托机制
	需要加载一个类时，先是下面的类加载器拿到，然后委托给父加载器，父加载器不能加载，才下放，这样就保证了比如 Object这种顶层类不会加载错误，即使你下面重写了一个自己的Object类，也不会被加载，因为该类早在启动时就加载好了

	注意有一点，虽然Ext的父加载器是null，所以打印时，显示Null，因为bootstrap是C++实现的，java虚拟机没有相应的class类，但是当向上委托时发现父类加载是空，就会用启动类加载器，道理是一样的
	
<ul>3.反射</ul>

	###反射常见的有两种api
	Class.forName(Name)  //默认初始化
	ClassLoader.loadclass(className)  //默认不链接

	像JDBC用的就是Class.forName() ,因为DriverManager注册等的代码，都是写在static块中，需要初始化
	
<ul>4.补充</ul>

	事实上，jvm判断两个类是否相等，用的类加载器，所以，即使是同一个类或者同一份代码，用不同类加载器加载，也是不同的class对象，equals也是不一样的


<h1>5.3</h1>

1.想做
<ul>1.查看每个类的重写的equals方法，和hashcode()</ul>


2.八种基础数据类型
<ul>1.哪8种：</ul>

	###四种整数类型
	byte(8位)  -2^7~2^7,
	int(32位),
	long(64位),像这种，就要在数字后面加 L 
	short(16位)

	###两种浮点数类型
	float(32位)，加 F 或 f
	double(64位),加 D 或 d
	浮点数是不精确的，不能做精确比较

	###一种字符类型和布尔类型
	char(16位)
	boolean



<h1>5.4</h1>
1.String常量池
<ul>1.jvm相关概念回顾</ul>

	###JDK7
	方法区存：类信息，常量池，静态变量
	所以String常量池也在里面

	###JDL8
	把常量池迁到了堆上，作为其中的一块区域

<ul>2.String常量池作用：减少相同字符串频繁创建的消耗，而且像一种缓存，提高性能</ul>

<ul>3.不同的创建字符串的方式</ul>

	### 
	String str2 = new String("abc");

	上面的语句发生了什么？？创建了两个对象，和一个引用。
	1.首先查询常量池是否有"abc",发现没有，就在常量池创建"abc"的对象，然后在堆上创建一个String对象，引用前面的"abc"，最后用 str2 引用

	###
	String str2 = "aaaa";
	
	这句就是只在常量池创建一个对象，而如果是 String str2="abc"，这样就不用创建对象，因为原来的常量池里面已经有了。
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



2.String类型不可变
<ul>1.String是引用类型</ul>
	
	首先，String不是基本数据类型，是引用类型，是存放在堆上的，而且因为是不可变的，所以每次更改，比如 += 都是重新拷贝一份，对原来的不改变，这也就导致字符串这种，用完即扔，等待垃圾回收

<ul>2.String的不可变怎么实现的</ul>

	jdk8源码
	public final class String implements Serializable, Comparable<String>, CharSequence {
	    private final char[] value;
	    private int hash;

	###
	String本质是char数组，这里用的final其实是保证引用不变，但是数组里面的元素还是可以变的，但是被封装死了，没有setFValue的方法，而且是private，所以不可变了

	###注意
	final关键字不仅不可变，而且不可被继承
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<h1>5.5</h1>

1.杂，疑问
<ul>1.hbase??</ul>
<ul>2.回去面经的加上，线程池的使用，就在那个hl_node里面，还有那个webmagic的架构咋样</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<groupId>com.dbapp</groupId>
	<artifactId>hlserver</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>