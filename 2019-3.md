<h1>3.1</h1>

**1.http权威指南心得**
<ul>1.http流程：先通过url ，拿到域名，端口，通过DNS得到IP地址，然后发出请求报文，这是应用层，到了传输层，通过TCP分成一块一块的IP分组，到了网络层，再用IP找到对应主机，服务器再同样返回响应报文（response）</ul>


	###英文名词
	URI:Uniform Resouce Identifier(统一资源标识符)
	URL:XXX XXX Locator
	TCP:Transmission Control Protocol
	IP:Internet Protocol
	SSL:Secure Socket Layer

	###web中间层
	1.代理（proxy）:客户端和服务端的中间实体
	2.缓存（cache）:一种特殊的代理，访问到直接返回缓存的内容
	3.网关（gateway）:也是一种中间实体，用来转换协议 eg : HTTP to FTP
	4.隧道（tunnel）：也是一个中间层，封装数据（两可以对非http数据），进行盲转发，可以突破防火墙
	5.agent代理：本质上就是一个用来标识的字段，可以辨别是什么东西访问

<ul>2.URL的格式：（最通常）协议：// host / xx资源路径，还有 ; ? & # 分别知道含义用途即可，（http请求时不带#，服务端返回的就是整个资源，拿到之后显示才是会找到相关# 名字的内容）</ul>
<ul>3.不安全字符需要转义，通常是 "%+十六进制"，比~字符，十六进制是"0x7E"，所以在URL中就是 "%7E"'，还有些需要保留，比如 % 会作为转义字符来保留，但是真的需要 % 该意思的时候，就直接转义</ul>


	###请求报文格式
	GET URL HTTP/1.0
	headers
	body

	###响应报文格式
	HTTP/1.0 200 OK(提示消息)
	headers
	body

	###注意点
		1.请求报文中可以没有body，很多都是没有
		2.请求报文和响应报文的协议版本可以不一致，一个是1.0，一个是1.1
		3.说是纯文本，但本质上是ASCII文本
	
<ul>4.首部字段的语法："字段名"：+空格+"值"+"\r\n"，各种首部字段不再赘述</ul>
<ul>5.http和https的区别之一就是，https在http和tcp中间插入了一层加密层（ssl或者TLS）</ul>
<ul>6.http和socket都是底层用TCP/IP协议，但是一个是应用层协议，另一个是封装的APIc</ul>
<ul>7.对于http双峰特征的理解：http主要是请求和响应，请求进行时，流出方向的包很少或者说是没有，响应时候同理，所以确认的ack分组找不到大分组来捎带</ul>
<ul></ul>
<ul></ul>

2.入职谨记
<ul>1.每周末都要写周报</ul>
<ul>2.定期有学习会</ul>


3.小知识点
<ul>3.CRLF：是回车加换行，也就是\r\n ，CR是回车 \r ，LF是换行 \n</ul>


4.http过程中的延时
	
	###http本身的延时
	1.解析ip地址，域名的时候，有延时
	2.建立tcp新连接会有延时
	3.服务端从tcp读数据，并处理，有延时
	4.回送响应，有延时
	总结：这些都是硬件速度，网络或者服务器的负载造成的

	###TCP协议本身造成的延时
	1.tcp的握手延时，第一次SYN，第二次SYN+ACK，第三次直接ACK+数据，可以节约时间，再者，这第三次，因为http的交换数据不多，很有可能这一次就直接传完，所以为了这么点数据就握一次手，很浪费
	2.TCP有一个确认机制，会回送ack分组，这个分组通常很小，所以有一个延迟确认算法，该确认的小分组先缓存下来，等到有大分组带它，才发送，但是http主要是请求和响应，请求进行时，流出方向的包很少或者说是没有，响应时候同理，所以确认的ack分组找不到大分组来捎带，所以会一直等着，有很大延时，因此可以修改或者禁用延迟算法
	3.tcp有个慢启动，新建立的连接，因为害怕会造成过载和拥塞，会采用指数级增长的发送，第一次发一个，成功就2个，在成功就4个，所以可想而知，新的连接都挺慢，所以会有延时，这时候可以重用已有，现有的连接，避免
	4.tcp接口是可以封装任意大小的数据的，所以即使很小，也会被封装发送，这样很浪费，所以使用了Nagle算法，小分组先缓存，等到后面的小分组加起来凑成个大的再发，只有当另外的分组都发完并确认了，才会发凑不到规模的小分组，这样一来，小分组等不到另外小分组时候，就有延时，另一方面还会和延时算法有关系，这里在等待确认分组时，也会受到延时算法的影响，所以有时候建议关闭，不过要保证，装的都是大分组
	5.time_wait导致在2MSL时间内，不能重复端口号（理由在下面），一台客户机一台服务器，能变的四元组只有源端口号，假设有60000个可用，2msl=120s，那就是每秒最多500次，如果超出就会端口耗尽，解决方法，就增加负载，或者用虚拟ip等，总之四元组有更多组合，不需要只能在6w个端口里选

5.time_wait的真正产生原因
<ul>time_wait是四次挥手最后的状态</ul>
<ul>1.第一个原因早先提过了，防止最后一次ack包丢失，导致服务端FIN包一直重传</ul>
<ul>2.第二个，假设发完ack就直接关闭，然后立即建立一条新的连接（同样的四元组，因此TCP分不出来），因为是立即，所以线路中还有些旧的连接的数据，新的连接并分不出啦，会当成新的传上去，这样就会有问题，所以设置2MSL的目的还有一个，防止该时间内重新创建一个相同四元组的连接</ul>



<h1>3.2</h1>(4,5)

**1.http处理多个资源连接**
<ul>1.</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

**2.http服务器该做的事(Apache,Nginx,Tomcat)**
<ul>1.接受客户端连接（识别客户端主机名，反向DNS用ip得到，或者ident协议）</ul>
<ul>2.接受请求报文（解析首部，方法等等，还有如果有主体，用content-length读取主体）</ul>
<ul>3.处理请求</ul>
<ul>4.访问对应的资源（这里会做相应的映射，比如很多setting配置会做的目录配置）</ul>
<ul>5.构造响应（涉及状态码，MIME类型，这个类型转换是有表的，还有关于主体的content-length）</ul>
<ul>6.发送响应</ul>
<ul>7.记录日志（很多服务器都有的日志配置）</ul>

**3.补充**
<ul>1.复用I/O这种服务器，只有在一个状态变化时才处理，否则就处于连接列表，就是异步，有事情做才做，不会专注等待一个连接</ul>


<h1>3.3-3.6</h1>

<h3>SeimiCrawler</h3>
<ul>重要的对象</ul>

	1.Request
	2.Response
	3.SeimiQueue接口
	4.CrawlerCache
	5.CrawlerModel
	6.SeimiProcessor
	7.SeimiDownloader接口

<ul>2.重要的都在纸上，这里写不了</ul>

1.IDEA使用
<ul>1.调试跳过相关类，比如String类，logger类，在setting的Debugger.stepping中设置，调试用F8就可以</ul>
<ul>2.查看当前类的继承与被继承关系，Navigate.type hierarcy</ul>

2.chrome代理插件switchyOmega
<ul>1.设置不同url通配符下的不同规则</ul>

3.win下安装服务
<ul>1.可以把mysql，mongodb安装成服务，弄成安装自启</ul>
<ul>2.net start xxxx，这个命令要在管理员权限下</ul>

4.maven操作
<ul>总：IDEA是在lifecycle里执行的</ul>
<ul>1.clean</ul>

5.今日工作心得										
<ul>1.spring 标红，不要直接 alt + enter ，容易莫名其妙加上依赖，反而会错</ul>



<h1>3.7</h1>
<ul>1.JRebel热加载插件？？</ul>
<ul>3.mongodb的使用,mongdb的数据结构</ul>
<ul>4.正则，还有java正则用法</ul>
<ul>5.域名咋样的格式？</ul>
<ul>6.js要重新学一下</ul>
<ul>7.sweetAlert</ul>
<ul>8.前后端传数据，model，getparams等等，结合项目看</ul>
<ul>9.不只是github,还有svn这种东西，自己电脑可以装个小乌龟</ul>
<ul>10.css位置调整等等</ul>
<ul>11.java的format字符串格式化</ul>
<ul>12.java http 的各种方式https://blog.csdn.net/javarrr/article/details/83113838</ul>
<ul>https://blog.csdn.net/zhangcanyan/article/details/51793951</ul>


2.工作里学到的小技巧
<ul>1.有一些变量，不需要写死，可以写在constant之类的实体类中，作为常量用</ul>
<ul>2.有一些基础数据，比如select的标签值，可以通过后台传给前端，一般是在页面加载的时候，就传过来了</ul>
<ul>3.用户输入值的校验，一般在前端校验，后台的效率不高</ul>

3.IDEA
<ul>1.勤用maven的reimport</ul>
<ul>2.版本控制，revert回退</ul>
<ul>3.还有个很牛批的功能，compared with</ul>


<h1>3.8</h1>

1.工作心得
<ul>1.维护项目时，尽量不要更改原先的代码</ul>

	本来昨天就做好了，但是ajax是post的，我用的是RequestMapping，这样本来没有问题，但是胡老板要求用PostMapping，这样就会诞生一个问题，我add之后，没有反应，经过浏览器debug，发现数据的确是传到前端了，但是后续没有反应。这时候发现ajax的处理中对json.code有判断，经过胡老板点拨，原来是有一个拦截器，里头只写了RequestMapping的拦截方法，里头做了result的code封装。

	这时候我想到这几种方法：
	###不让，必须要post
	1.直接用RequestMapping，这种不报错，如果必须的话，就指定post的method常数
	###不让，最好不要更改原有代码
	2.更改拦截器，对PostMapping也进行拦截，代码可以参照之前
	###这个被要求
	3.自己返回code

	但在这里又遇到了问题，域名正确当然没关系，如果错了，代码逻辑是抛出异常


<ul>2.java trim去除前后</ul>
<ul>3.java枚举</ul>


2.疑问
<ul>1.拦截器？？？</ul>
<ul>2.listener??</ul>
<ul>3.invoke???</ul>


<h1>3.9</h1>

	最近心态有点问题，的确，找到了工作是件很高兴的事情，但是我真的不能因此就变得很怠惰，只在安恒的这一年一定要好好把握，学到更多的东西，以后才有安身立命的本钱。


<h1>3.10</h1>

**1.activeMQ学习**
<ul>1.概念</ul>
	
	1.MOM:(Message-oriented middleware)面向消息中间件，就是在消息发送和消息接收的中间层，可以实现异步啊，松耦合之类的
	2.JMS:(Java Message Service)用Java实现的MOM的规范

<ul>2.消息传递主要分两种：P2P ，还有Pub/Sub</ul>
	
	P2P:换句话说，就是多对多，中间有个队列，生产者一直生产，消费者一直消费，但是注意，一个消息，只能给一个消费者来消费

	订阅模式：这个就和群发邮件一样，生产者在队列中注册，消费者也注册，一旦生产者发布了内容，队列就推送给所有的消费者，在这里，一份消息会发给所有的消费者，和P2P不一样

<ul>3.通用流程</ul>
	
	- 获取连接工厂
	- 使用连接工厂创建连接      ### Connection
	- 启动连接       ### Connection.start
	- 从连接创建会话     ### Session
	- 获取 Destination    ### Destination就是待存或待取的队列
	- 创建 Producer
		- 创建 Producer
		- 创建 message
	- 创建 Consumer，
		- 创建 Consumer
		- 注册消息监听器（可选）
	- 发送或接收 message
	- 关闭资源（connection, session, producer, consumer 等)
	
	
**2.同步和互斥？？线程同步？**
<ul>首先要明白，操作系统中的同步和编程语言的多线程同步不是一个概念</ul>
	
	###操作系统角度
	操作系统中分为同步和互斥两个概念，
	互斥就是同时刻下，该资源只能被独占，线程之间互相排斥，是无序的，谁也不知道该任务执行完，下个是谁来使用资源
	同步就是，多个任务按照相应的时间顺序来执行，比如A和B，B要打印A的数据，在A做完之前，B不能动，这也是一种变相的互斥，但他是有序的

	###编程语言角度
	一门编程语言的多线程，是分为同步和异步概念
	线程同步，就是说，按照一定顺序执行，这样就不会造成数据的紊乱，让线程变成串行运行
	异步就不一样，在一个线程做完之前，另一个线程也可以做，就会造成数据的脏读之类的


<h1>3.11</h1>

**1.syncronized**
<ul>syncronized可以获得两种锁，对象锁和类锁，也同时有两种使用方式</ul>

	##修饰方法
	1.修饰静态方法，这样获得的就是类锁，所有该类的对象，需要获得锁的时候，都会等待并阻塞，也就是说，一个类有多个syncronized方法，一个线程通过其中一个方法占用了锁，另外线程也不能使用其余的syncronized方法，因为锁被占用了，当然，不需要锁的除外

	2.修饰普通方法，获得对象锁

	##修饰代码块
	代码块大概是这样的格式
		synchronized (xxxxx){
	        xxxxxxxxxxx     
	    }
	1.（）中是this，这样就获得了当前类的对象锁
	2.是xxx.class，获得某类的类锁 
	3.lock，无意义的锁，只是单纯为了实现同步，比如 private byte[] lock = new byte[0];

2.明日目标
<ul>1.java并发编程实践里，虽然不错，但是还是从第五章看比较好</ul>

<h1>3.12</h1>

1.并发编程思考			
<ul>1.同步容器</ul>

	为了让不同线程在访问同一容器时保持同步，就有了同步容器：Vector,HashTable等

	但会有问题，虽然容器是线程安全的，但是，外面对他的操作，并不一定安全。比如，“检查并添加”，先检查是否有某元素，检查是否为空，在进行添加操作之前，另一个线程有可能就进行检查操作，这样就可能有错

	解决办法倒是有，把整个操作变成原子操作，加上syncronized就可以，不过很影响并发性，因为加了一把大锁
<ul>2.并发容器</ul>

	为了解决前面的并发性问题，有了新的容器，并发性容器，主要有concurentHashmap,queue等等


2.concurrentHahMap
<ul>1.7</ul>
	
	jdk1.7时，concurrentHashMap底层是通过分段锁来实现,hashmap想实现同步，最垃圾的办法就是对map加锁，限制他的并发量，但是这样效率真的很垃圾，所以用了concurrentHashMap

	该类认为，可以把锁的粒度变小，不用每次都锁全表，Cmap内部有两个静态内部类HashEntry 和 Segment。

	HashEntry就是用来存一个键值对的，封装键值的对象，整体的数据可以分为N个段，每段就是一个Segment（继承了可重入类），而每一个Segment又有很多个hashBucket（桶），桶上是由链表组成的HashEntry。
	
	https://uule.iteye.com/blog/1513976  示例图在这上面

	Cmap默认是16个Segment，每一段都有自己的锁，只有用到这一段，才会阻塞，所以可以同时有16个并发，效率会提高很多，而且由于hashmmap扩容的机制（这里不是很懂???），使得写操作不会影响到读操作，而且读操作之间不需要同步（为啥？？？）
	


<h1>3.13</h1>
<ul>1.正则：http://deerchao.net/tutorials/regex/regex-1.htm    .....................https://c.runoob.com/front-end/854?optionGlobl=global</ul>


<h1>3.14</h1>

1.activemq连接
<ul></ul>
<ul></ul>

2.收获心得
<ul>1.logback配置在</ul>
<ul></ul>

3.hashmap底层
<ul>1.大致实现：hashmap由数组和链表组成，最外层是数组，代表了不同的hash值，叫做桶（bucket），每个桶上面都可以有一个链表，用来处理hash冲突</ul>
<ul>2.put操作：</ul>
	
	1.首先看key是不是null，是null就默认插入table[0],如果已有key为null，就替换
	2.key不为空，就是正常插入。根据hashcode值计算对应的hash，放到对应的table[i]上，如果存在相同的key，而且hashcode值一样，则替换，不一样，就插在桶的最前面，旧数据放在他后面(所以，新插入的数据会更快被找到)
	
<ul>3.get/remove操作：先算出hash值（h & (length-1)），找到所在的桶，从链表遍历，用key的equals()方法来匹配</ul>
<ul>4.扩容操作：</ul>

	hashmap在初始化的时候，就有一个capacity容量，还有一个负载因子，理论上，负载因子越小，冲突碰撞的几率越小。在此之上，有一个极限阈值 = capacity * 负载因子。

	每当hashmap中的元素数达到了极限阈值，就触发resize函数，容量扩大一倍，并把原有元素移到扩容之后的数组上去，重新计算hash，这个过程叫 rehash

5.计算hash值

		//方法一： 
		static final int hash(Object key) { //jdk1.8 & jdk1.7 
		int h; 
		// h = key.hashCode() 为第一步 取hashCode值 
		// h ^ (h >>> 16) 为第二步 高位参与运算 
		return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); 
		} 
		//方法二： 
		static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 
		return h & (length-1); //第三步 取模运算 
		}

<ul>5.有一段话很好： </ul>

	那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 < 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。

<ul>6.上述都是jdk1.7,1.8中有所改动</ul>

	1.jdk1.8中，hashmap由数组，链表还有红黑树组成


<h1>3.16</h1>

1.java变量的引用和内存管理
<ul>1.分类</ul>

	###按照位置分
	1.成员变量（也就是类的普通变量）：保存在内存的堆上
	2.静态成员变量（类的静态变量）：保存在方法区
	3.局部变量（比如方法中的变量，代码块中变量）：保存在虚拟机栈，跟着方法一起入栈

	###按照类型分
	1.基本数据类型
	2.引用类型

<ul>2.作为参数被引用</ul>
	
	###java
	java 需要从内存角度来理解，变量被方法调用，其实就是跟着方法一起，压入了虚拟机栈，变量本来是在类里，也就是在堆上，怎么可以自己本身压进栈呢？所以对于基本数据，虚拟机拷贝了一份过来，而引用类型，则是拷贝一份引用过来。

	因此基本数据类型，方法里改变啥的不影响外面；而引用类型，带进来的虽然是一个引用的副本，但好歹也是对该对象的引用，在这里头更改，也是会有影响的啊！！！

	但是注意哦，比如，传进来个Person p , 你在里头写 p = new Person()，这样就是不同的情况了，在这里，你的这个引用指向了另一个对象，和外面那个引用，没多大关系了，而String 类型，底层是final 的char数组，是不可变的

	### Python
	python里面可没有什么基础数据类型啥的，一切都是对象！！

	传进参数，就是传进了一个引用，这个就涉及命名空间了


<h1>3.17</h1>

**1.数据库事务**
<ul>1.事务的ACID特性</ul>

	1.Atomicity（原子性）：操作是原子的，要么不做，要么做全套
	2.Consistency （一致性）：事务会让数据库从一致性状态到另一个一致性状态，比如A给B转账，两人都有100，A给B十块，但是A减了，B还没加，数据库就出错停止了，这样A有90，B还是100，加起来190，数量就不对了，这就是不一致
	3.Isolation （隔离性）：每个事务都应该是独立的，互相不会影响
	4.Durability （持续性）：事务一旦被提交，就永久生效的，不会说因为故障就失效

<ul>2.重点看看隔离性：共5类问题</ul>
	
	###读问题
	1.脏读：读取了另一个事务未提交的数据。
		比如A和B，B把数据减了100，但还没提交，A这时候读了，发现少了100，这时候如果B回滚了，或者又进行了另外的操作，A读到的数据就是错的，这就是脏读
	
	2.不可重复读：读取了另外一个事务提交的数据。
		换句话讲，就是说，同一个事务里，我两次读的数据，是不一致的，这是因为有另一个事务进行了修改并提交

	3.幻读：和不可重复读不一样，原本的数据没改，但是另一个事务给数据增加了新的项
		A读了两次，一次是最开始，另一次读，发现数据倒是没变，但是又多了新的一项数据，感觉出现了幻觉

	###更新问题
	1.第一类更新：A事务撤销时，把已经提交的B事务的更新数据也撤销了
	2..第二类丢失更新：A事务查询后提交，提交前B修改并提交了，但是A这里不知道，A提交就把B弄没了

<ul>隔离级别</ul>

	read uncommited：读未提交，啥都解决不了，不安全、
	read commited：读已提交，规定了该事务提交后，数据才能被读取，这样就防止了脏读，但是不可重复读还存在
	Repeatable read：可重复读，但是防止不了幻读
	Serializable：串行化，什么问题都解决了，但是并发性很差
	
<ul>各个问题的危害</ul>
	
	1.脏读，这个很好理解，我读了个数据，突然另一个事务又反悔了，数据又回滚了，那我这里读的数据就是错的，问题很大

	2.不可重复读，这个就很难说，两次读到的数据不一样，第二次读到的是更新过的，乍一听没有问题，很符合逻辑，但别忘了，这可是在同一个事务！！！！不同的事务里，读到最新数据当然是对的，但是同一事务中，我操作还没做完呢，你突然就改了，那我之前做的所有不就是没用了？？？所以要避免

<h1>3.18</h1>

1.乐观锁和悲观锁
<ul>悲观锁：就像一个悲观的人，每次拿到数据，都觉得另外的线程或者事务会更改数据，所以要加锁，比如java 的syncronized和重入锁就是悲观锁</ul>
<ul>乐观锁：像一个乐观的人，不认为别人会更改数据</ul>

	既然不加锁，怎么保证数据安全并一致？？
	1.版本号：
		每份数据都有一个版本号，对数据修改之后，会给版本号加1 ，假设A事务和B事务同一时间都读到版本号，等于1，A修改了数据，版本号变成2，并提交，这时候版本号就是2。但是B这时候也修改数据完毕了，也把版本号变成2，他去一比对，发现不对，版本号已经是2了，所以就重新再来一遍，重新读取版本号并修改数据
	2.CAS算法？？？（这个不太懂）贴个链接：https://blog.csdn.net/qq_34337272/article/details/81072874

<ul>适用场合：</ul>

	乐观锁适用于写操作比较少的，而读操作比较多的场合，因为乐观锁没有锁，所以减少了开销，但是如果写操作很多，也就是说重复操作的次数也会增加，那么可能会得不偿失，这时候就要用悲观锁

<ul>乐观锁和悲观锁在具体实现方面？？？比如mysql用的是啥，mybatis用的是啥？？？</ul>


<h1>3.19</h1>

1.win下注册服务


2.mysql锁机制
<ul>锁的种类</ul>
	
	###按照锁的范围
	1.表锁
	2.行锁
	3.页锁
	
	###锁的性质
	1.共享锁（S锁）/ 表共享读锁
	2.排它锁（X锁）/ 表独占写锁

	###从程序员角度看（抽象的，其实并不存在）
	1.悲观锁
	2.乐观锁
	
<ul>表，行，页锁</ul>

	1.表级锁，对整个表进行锁定，所以相应的，不同事务间冲突的几率也会大一些，但是这样操作简单，开销小，是MyISAM的默认锁，Innodb也可以支持
	
	2.行级锁，锁的粒度小，所以冲突也小，但是比较麻烦，开销比较大，是Innodb的默认锁

	3.页级锁，粒度介于行，表之间，一次锁一组相邻的数据，另外参考前面的锁


<ul>MyISAM的锁</ul>

	MyISAM默认是表级锁，为什么呢？？因为MyISAM的查询快，写的慢，刚好对应表级锁，锁住整张表方便了读，写的时候会阻塞，很慢，所以用表级锁

	MyISAM读写都会加锁，读是表共享读锁，写是表独占写锁。共享读锁是锁定读权限，允许不同的事务同时读，但是此时不能写；独占写锁开启时，会阻塞另外的读和写操作。

	MyISAM不会发生死锁，因为一次性就锁定了所有用到的表

	表锁中，select自动加了读锁，update,insert,delete等自动加写锁

<ul>InnoDB的锁</ul>

	InnoDB默认是行级锁，也支持表级锁，有很多误解认为行级锁是锁记录，但其实不是，锁的是索引。要么直接锁主键索引，要么先锁普通索引，再锁相对应的主键索引。由于这样的设置，所以可能会产生死锁，比如一个先锁普通再锁主键，一个先主键再普通，就会互相等待

	什么时候会触发表锁？？因为innodb用到索引默认是表锁，但如果没有走索引呢？？数据库不就找不到相关的行了？？所以只能用表锁。同理像 %xxxx% 这种用法，也是会锁全表的，因为走不了索引。这也是查询会慢的原因之一

	和MyISAM不太一样，InnoDB查询时不会有任何锁，在写时才会有锁，可以是共享锁，也可以是排它锁。更加需要注意了，锁住之后，不是意味着另外事务不能对数据操作了，而是说，不能在添加新的锁，不能再通过锁，来锁定他。像select这种，不走锁的，就一直可以查询

	select不加锁，修改加排它锁。显式加共享锁：lock in share mode，加排它锁for update
	
<ul>对比图链接</ul>

	https://blog.csdn.net/fath_kevin/article/details/81322565

	美团博客https://tech.meituan.com/2014/08/20/innodb-lock.html

	网易博客https://blog.csdn.net/qq_30336433/article/details/82014813

	http://www.hollischuang.com/archives/914

<ul>注意点：innodb默认，每行命令都是要提交的</ul>


<h1>3.20--3.24</h1>

**1.工作收获**
<ul>1.OKHttp访问https时候需要证书，找到了相关方法跳过ssl验证（在公司电脑）</ul>
<ul>2.UUID.randomUUID().toString() 可以生成随机id</ul>
<ul>3.springboot 里实现拦截器HandlerInterceptor，有preHandler，postModel，after方法，最后在xml中注册</ul>
<ul>4.字符串判空，有StringUtils.isBlank()或者isEmpty()，不过二者不一样，empty要求没有任何字符，完全为空或者null，而blank包括empty，还可以是空格，换行符之类的，范围稍大一点</ul>

	StringUtils.isBlank(" ") = true
	StringUtils.isBlank("        ") = true
	StringUtils.isBlank("\t \n \f \r") = true   
	###\b是单词边界符
	StringUtils.isBlank("\b") = false   

<ul>5.比如说网页上某些数据要统计后回显，但是不可以是每次加载都要计算，应该是算一次就要存下来，可以设置新的字段之类的</ul>
<ul>6.多种情况下，可以用switch case，但是case的值只能是基础类型或者final类型的字符串</ul>
<ul>7.java枚举中有多个值，是用构造器的参数位置来确定位置的</ul>
<ul>8.在一个项目中，有多个地方报错，可以用isError类型的boolean变量来设置</ul>
<ul>9.maven打成maven包，install，右键run</ul>

**2.该思考的**
<ul>1.seo是啥？还有原理？</ul>
<ul>2.java 的bson和document?</ul>
<ul>3.安全方面的跨站xss，sql注入？</ul>
<ul>4.spring用到了哪些设计模式</ul>


<h1>3.25</h1>
<ul>CopyOnWriteArrayList每次写的时候，都会拷贝一份新的，在这个地方修改，这时候不阻碍读操作，但是读到的都是旧数据，而且源码中写操作是加了重入锁的，所以只能同时有一个操作在写</ul>

1.Executor框架学习
<ul>整体结构</ul>

	Executor
		|____ExecutorService
					|____ScheduledExecutorService
					|____ThreadPoolExecutor
								|___xxxxx
								|___xxxx
								|___xxx
								|___xxxx

	Futrue:异步计算结果？？这个不是很懂

<ul>2.jdk5以前，多线程Thread是任务单元和执行单元结合在一起，Executor框架中，分为任务（Runnable,callable之类），还有执行者（Executor之类）</ul>
<ul>3.Executor和ExecutorService的主要区别：ExecutorService是Executor的拓展接口，增加了一些shutdown之类的方法，还有submit，会返回future类型，可以被executor执行</ul>
<ul>4.线程池</ul>

	newFixedThreadPool:定长
	newSingleThreadExecutor：单线程
	newScheduledThreadPool：定时
	newCachedThreadPool：缓存，线程用过之后，有可能被回收再用一次，前提是没有另外的空闲的能用

2.**明日目标**
<ul>1.收藏书签看一下，还有工作再次整理下，以前的也在看一下</ul>
<ul>2.重入锁？？？</ul>
<ul>3.concurrentHashmap???</ul>
<ul>4.java 反射？？</ul>
<ul></ul>



<h1>3.26</h1>

1.Java反射
<ul>反射的大白话概念</ul>

	说起反射，可以先来理解一下正射
	Cat cat = new Cat();
	这其实就是一个正射，在new 的时候，已经import了该类，这就是在知道的前提下，获得该类

	而反射不一样，提前是不知道类的路径的，是在用到的时候才加载的，才知道的
	Class clz= Class.forName("com.example.demo.test");
<ul>相关操作</ul>、
	
	###获得类
	Class.forName("com.example.demo.test") 
	###获得方法
	Method setMethod = clz.getMethod("setValue", int.class);
	###获得实例对象（要执行方法必须先要获得实例对象）
	clz.getConstructor() 
	###方法执行
	setMethod.invoke(obj,14);
	
	还有很多
<ul>相关链接：http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</ul>



<ul>https://www.cnblogs.com/hapjin/p/7450309.html</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
