<h1>3.1</h1>(1,2,3)

**1.http权威指南心得**
<ul>1.http流程：先通过url ，拿到域名，端口，通过DNS得到IP地址，然后发出请求报文，这是应用层，到了传输层，通过TCP分成一块一块的IP分组，到了网络层，再用IP找到对应主机，服务器再同样返回响应报文（response）</ul>

	###英文名词
	URI:Uniform Resouce Identifier(统一资源标识符)
	URL:XXX XXX Locator
	TCP:Transmission Control Protocol
	IP:Internet Protocol
	SSL:Secure Socket Layer

	###web中间层
	1.代理（proxy）:客户端和服务端的中间实体
	2.缓存（cache）:一种特殊的代理，访问到直接返回缓存的内容
	3.网关（gateway）:也是一种中间实体，用来转换协议 eg : HTTP to FTP
	4.隧道（tunnel）：也是一个中间层，封装数据（两可以对非http数据），进行盲转发，可以突破防火墙
	5.agent代理：本质上就是一个用来标识的字段，可以辨别是什么东西访问

<ul>2.URL的格式：（最通常）协议：// host / xx资源路径，还有 ; ? & # 分别知道含义用途即可，（http请求时不带#，服务端返回的就是整个资源，拿到之后显示才是会找到相关# 名字的内容）</ul>
<ul>3.不安全字符需要转义，通常是 "%+十六进制"，比~字符，十六进制是"0x7E"，所以在URL中就是 "%7E"'，还有些需要保留，比如 % 会作为转义字符来保留，但是真的需要 % 该意思的时候，就直接转义</ul>

	###请求报文格式
	GET URL HTTP/1.0
	headers
	body

	###响应报文格式
	HTTP/1.0 200 OK(提示消息)
	headers
	body

	###注意点
		1.请求报文中可以没有body，很多都是没有
		2.请求报文和响应报文的协议版本可以不一致，一个是1.0，一个是1.1
		3.说是纯文本，但本质上是ASCII文本
	
<ul>4.首部字段的语法："字段名"：+空格+"值"+"\r\n"，各种首部字段不再赘述</ul>
<ul>5.http和https的区别之一就是，https在http和tcp中间插入了一层加密层（ssl或者TLS）</ul>
<ul>6.http和socket都是底层用TCP/IP协议，但是一个是应用层协议，另一个是封装的APIc</ul>
<ul>7.对于http双峰特征的理解：http主要是请求和响应，请求进行时，流出方向的包很少或者说是没有，响应时候同理，所以确认的ack分组找不到大分组来捎带</ul>
<ul></ul>
<ul></ul>

2.入职谨记
<ul>1.每周末都要写周报</ul>
<ul>2.定期有学习会</ul>


3.小知识点
<ul>3.CRLF：是回车加换行，也就是\r\n ，CR是回车 \r ，LF是换行 \n</ul>


4.http过程中的延时
	
	###http本身的延时
	1.解析ip地址，域名的时候，有延时
	2.建立tcp新连接会有延时
	3.服务端从tcp读数据，并处理，有延时
	4.回送响应，有延时
	总结：这些都是硬件速度，网络或者服务器的负载造成的

	###TCP协议本身造成的延时
	1.tcp的握手延时，第一次SYN，第二次SYN+ACK，第三次直接ACK+数据，可以节约时间，再者，这第三次，因为http的交换数据不多，很有可能这一次就直接传完，所以为了这么点数据就握一次手，很浪费
	2.TCP有一个确认机制，会回送ack分组，这个分组通常很小，所以有一个延迟确认算法，该确认的小分组先缓存下来，等到有大分组带它，才发送，但是http主要是请求和响应，请求进行时，流出方向的包很少或者说是没有，响应时候同理，所以确认的ack分组找不到大分组来捎带，所以会一直等着，有很大延时，因此可以修改或者禁用延迟算法
	3.tcp有个慢启动，新建立的连接，因为害怕会造成过载和拥塞，会采用指数级增长的发送，第一次发一个，成功就2个，在成功就4个，所以可想而知，新的连接都挺慢，所以会有延时，这时候可以重用已有，现有的连接，避免
	4.tcp接口是可以封装任意大小的数据的，所以即使很小，也会被封装发送，这样很浪费，所以使用了Nagle算法，小分组先缓存，等到后面的小分组加起来凑成个大的再发，只有当另外的分组都发完并确认了，才会发凑不到规模的小分组，这样一来，小分组等不到另外小分组时候，就有延时，另一方面还会和延时算法有关系，这里在等待确认分组时，也会受到延时算法的影响，所以有时候建议关闭，不过要保证，装的都是大分组
	5.time_wait导致在2MSL时间内，不能重复端口号（理由在下面），一台客户机一台服务器，能变的四元组只有源端口号，假设有60000个可用，2msl=120s，那就是每秒最多500次，如果超出就会端口耗尽，解决方法，就增加负载，或者用虚拟ip等，总之四元组有更多组合，不需要只能在6w个端口里选

5.time_wait的真正产生原因
<ul>time_wait是四次挥手最后的状态</ul>
<ul>1.第一个原因早先提过了，防止最后一次ack包丢失，导致服务端FIN包一直重传</ul>
<ul>2.第二个，假设发完ack就直接关闭，然后立即建立一条新的连接（同样的四元组，因此TCP分不出来），因为是立即，所以线路中还有些旧的连接的数据，新的连接并分不出啦，会当成新的传上去，这样就会有问题，所以设置2MSL的目的还有一个，防止该时间内重新创建一个相同四元组的连接</ul>



<h1>3.2</h1>(4,5)

**1.http处理多个资源连接**
<ul>1.</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

**2.http服务器该做的事(Apache,Nginx,Tomcat)**
<ul>1.接受客户端连接（识别客户端主机名，反向DNS用ip得到，或者ident协议）</ul>
<ul>2.接受请求报文（解析首部，方法等等，还有如果有主体，用content-length读取主体）</ul>
<ul>3.处理请求</ul>
<ul>4.访问对应的资源（这里会做相应的映射，比如很多setting配置会做的目录配置）</ul>
<ul>5.构造响应（涉及状态码，MIME类型，这个类型转换是有表的，还有关于主体的content-length）</ul>
<ul>6.发送响应</ul>
<ul>7.记录日志（很多服务器都有的日志配置）</ul>

**3.补充**
<ul>1.复用I/O这种服务器，只有在一个状态变化时才处理，否则就处于连接列表，就是异步，有事情做才做，不会专注等待一个连接</ul>


<h1>3.3-3.6</h1>

<h3>SeimiCrawler</h3>
<ul>重要的对象</ul>

	1.Request
	2.Response
	3.SeimiQueue接口
	4.CrawlerCache
	5.CrawlerModel
	6.SeimiProcessor
	7.SeimiDownloader接口

<ul>2.重要的都在纸上，这里写不了</ul>

1.IDEA使用
<ul>1.调试跳过相关类，比如String类，logger类，在setting的Debugger.stepping中设置，调试用F8就可以</ul>
<ul>2.查看当前类的继承与被继承关系，Navigate.type hierarcy</ul>

2.chrome代理插件switchyOmega
<ul>1.设置不同url通配符下的不同规则</ul>

3.win下安装服务
<ul>1.可以把mysql，mongodb安装成服务，弄成安装自启</ul>
<ul>2.net start xxxx，这个命令要在管理员权限下</ul>

4.maven操作
<ul>总：IDEA是在lifecycle里执行的</ul>
<ul>1.clean</ul>
<ul>2.</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>												

5.今日工作心得										
<ul>1.spring 标红，不要直接 alt + enter ，容易莫名其妙加上依赖，反而会错</ul>
<ul></ul>
<ul></ul>
slf4j
<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
