<h1>3.1</h1>(1,2,3)

**1.http权威指南心得**
<ul>1.http流程：先通过url ，拿到域名，端口，通过DNS得到IP地址，然后发出请求报文，这是应用层，到了传输层，通过TCP分成一块一块的IP分组，到了网络层，再用IP找到对应主机，服务器再同样返回响应报文（response）</ul>

	###英文名词
	URI:Uniform Resouce Identifier(统一资源标识符)
	URL:XXX XXX Locator
	TCP:Transmission Control Protocol
	IP:Internet Protocol
	SSL:Secure Socket Layer

	###web中间层
	1.代理（proxy）:客户端和服务端的中间实体
	2.缓存（cache）:一种特殊的代理，访问到直接返回缓存的内容
	3.网关（gateway）:也是一种中间实体，用来转换协议 eg : HTTP to FTP
	4.隧道（tunnel）：也是一个中间层，封装数据（两可以对非http数据），进行盲转发，可以突破防火墙
	5.agent代理：本质上就是一个用来标识的字段，可以辨别是什么东西访问

<ul>2.URL的格式：（最通常）协议：// host / xx资源路径，还有 ; ? & # 分别知道含义用途即可，（http请求时不带#，服务端返回的就是整个资源，拿到之后显示才是会找到相关# 名字的内容）</ul>
<ul>3.不安全字符需要转义，通常是 "%+十六进制"，比~字符，十六进制是"0x7E"，所以在URL中就是 "%7E"'，还有些需要保留，比如 % 会作为转义字符来保留，但是真的需要 % 该意思的时候，就直接转义</ul>

	###请求报文格式
	GET URL HTTP/1.0
	headers
	body

	###响应报文格式
	HTTP/1.0 200 OK(提示消息)
	headers
	body

	###注意点
		1.请求报文中可以没有body，很多都是没有
		2.请求报文和响应报文的协议版本可以不一致，一个是1.0，一个是1.1
		3.说是纯文本，但本质上是ASCII文本
	
<ul>4.首部字段的语法："字段名"：+空格+"值"+"\r\n"，各种首部字段不再赘述</ul>
<ul>5.http和https的区别之一就是，https在http和tcp中间插入了一层加密层（ssl或者TLS）</ul>
<ul>6.http和socket都是底层用TCP/IP协议，但是一个是应用层协议，另一个是封装的APIc</ul>
<ul>7.对于http双峰特征的理解：http主要是请求和响应，请求进行时，流出方向的包很少或者说是没有，响应时候同理，所以确认的ack分组找不到大分组来捎带</ul>
<ul></ul>
<ul></ul>

2.入职谨记
<ul>1.每周末都要写周报</ul>
<ul>2.定期有学习会</ul>


3.小知识点
<ul>3.CRLF：是回车加换行，也就是\r\n ，CR是回车 \r ，LF是换行 \n</ul>


4.http过程中的延时
	
	###http本身的延时
	1.解析ip地址，域名的时候，有延时
	2.建立tcp新连接会有延时
	3.服务端从tcp读数据，并处理，有延时
	4.回送响应，有延时
	总结：这些都是硬件速度，网络或者服务器的负载造成的

	###TCP协议本身造成的延时
	1.tcp的握手延时，第一次SYN，第二次SYN+ACK，第三次直接ACK+数据，可以节约时间，再者，这第三次，因为http的交换数据不多，很有可能这一次就直接传完，所以为了这么点数据就握一次手，很浪费
	2.TCP有一个确认机制，会回送ack分组，这个分组通常很小，所以有一个延迟确认算法，该确认的小分组先缓存下来，等到有大分组带它，才发送，但是http主要是请求和响应，请求进行时，流出方向的包很少或者说是没有，响应时候同理，所以确认的ack分组找不到大分组来捎带，所以会一直等着，有很大延时，因此可以修改或者禁用延迟算法
	3.tcp有个慢启动，新建立的连接，因为害怕会造成过载和拥塞，会采用指数级增长的发送，第一次发一个，成功就2个，在成功就4个，所以可想而知，新的连接都挺慢，所以会有延时，这时候可以重用已有，现有的连接，避免
	4.tcp接口是可以封装任意大小的数据的，所以即使很小，也会被封装发送，这样很浪费，所以使用了Nagle算法，小分组先缓存，等到后面的小分组加起来凑成个大的再发，只有当另外的分组都发完并确认了，才会发凑不到规模的小分组，这样一来，小分组等不到另外小分组时候，就有延时，另一方面还会和延时算法有关系，这里在等待确认分组时，也会受到延时算法的影响，所以有时候建议关闭，不过要保证，装的都是大分组
	5.time_wait导致在2MSL时间内，不能重复端口号（理由在下面），一台客户机一台服务器，能变的四元组只有源端口号，假设有60000个可用，2msl=120s，那就是每秒最多500次，如果超出就会端口耗尽，解决方法，就增加负载，或者用虚拟ip等，总之四元组有更多组合，不需要只能在6w个端口里选

5.time_wait的真正产生原因
<ul>time_wait是四次挥手最后的状态</ul>
<ul>1.第一个原因早先提过了，防止最后一次ack包丢失，导致服务端FIN包一直重传</ul>
<ul>2.第二个，假设发完ack就直接关闭，然后立即建立一条新的连接（同样的四元组，因此TCP分不出来），因为是立即，所以线路中还有些旧的连接的数据，新的连接并分不出啦，会当成新的传上去，这样就会有问题，所以设置2MSL的目的还有一个，防止该时间内重新创建一个相同四元组的连接</ul>



<h1>3.2</h1>(4,5)

**1.http处理多个资源连接**
<ul>1.</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

**2.http服务器该做的事(Apache,Nginx,Tomcat)**
<ul>1.接受客户端连接（识别客户端主机名，反向DNS用ip得到，或者ident协议）</ul>
<ul>2.接受请求报文（解析首部，方法等等，还有如果有主体，用content-length读取主体）</ul>
<ul>3.处理请求</ul>
<ul>4.访问对应的资源（这里会做相应的映射，比如很多setting配置会做的目录配置）</ul>
<ul>5.构造响应（涉及状态码，MIME类型，这个类型转换是有表的，还有关于主体的content-length）</ul>
<ul>6.发送响应</ul>
<ul>7.记录日志（很多服务器都有的日志配置）</ul>

**3.补充**
<ul>1.复用I/O这种服务器，只有在一个状态变化时才处理，否则就处于连接列表，就是异步，有事情做才做，不会专注等待一个连接</ul>


<h1>3.3-3.6</h1>

<h3>SeimiCrawler</h3>
<ul>重要的对象</ul>

	1.Request
	2.Response
	3.SeimiQueue接口
	4.CrawlerCache
	5.CrawlerModel
	6.SeimiProcessor
	7.SeimiDownloader接口

<ul>2.重要的都在纸上，这里写不了</ul>

1.IDEA使用
<ul>1.调试跳过相关类，比如String类，logger类，在setting的Debugger.stepping中设置，调试用F8就可以</ul>
<ul>2.查看当前类的继承与被继承关系，Navigate.type hierarcy</ul>

<h1>3.9</h1>

	最近心态有点问题，的确，找到了工作是件很高兴的事情，但是我真的不能因此就变得很怠惰，只在安恒的这一年一定要好好把握，学到更多的东西，以后才有安身立命的本钱。


<h1>3.10</h1>

**1.activeMQ学习**
<ul>1.概念</ul>
	
	1.MOM:(Message-oriented middleware)面向消息中间件，就是在消息发送和消息接收的中间层，可以实现异步啊，松耦合之类的
	2.JMS:(Java Message Service)用Java实现的MOM的规范

<ul>2.消息传递主要分两种：P2P ，还有Pub/Sub</ul>
	
	P2P:换句话说，就是多对多，中间有个队列，生产者一直生产，消费者一直消费，但是注意，一个消息，只能给一个消费者来消费

	订阅模式：这个就和群发邮件一样，生产者在队列中注册，消费者也注册，一旦生产者发布了内容，队列就推送给所有的消费者，在这里，一份消息会发给所有的消费者，和P2P不一样

<ul>3.通用流程</ul>
	
	- 获取连接工厂
	- 使用连接工厂创建连接      ### Connection
	- 启动连接       ### Connection.start
	- 从连接创建会话     ### Session
	- 获取 Destination    ### Destination就是待存或待取的队列
	- 创建 Producer
		- 创建 Producer
		- 创建 message
	- 创建 Consumer，
		- 创建 Consumer
		- 注册消息监听器（可选）
	- 发送或接收 message
	- 关闭资源（connection, session, producer, consumer 等)
	
	
**2.同步和互斥？？线程同步？**
<ul>首先要明白，操作系统中的同步和编程语言的多线程同步不是一个概念</ul>
	
	###操作系统角度
	操作系统中分为同步和互斥两个概念，
	互斥就是同时刻下，该资源只能被独占，线程之间互相排斥，是无序的，谁也不知道该任务执行完，下个是谁来使用资源
	同步就是，多个任务按照相应的时间顺序来执行，比如A和B，B要打印A的数据，在A做完之前，B不能动，这也是一种变相的互斥，但他是有序的

	###编程语言角度
	一门编程语言的多线程，是分为同步和异步概念
	线程同步，就是说，按照一定顺序执行，这样就不会造成数据的紊乱，让线程变成串行运行
	异步就不一样，在一个线程做完之前，另一个线程也可以做，就会造成数据的脏读之类的


<h1>3.11</h1>

**1.syncronized**
<ul>syncronized可以获得两种锁，对象锁和类锁，也同时有两种使用方式</ul>

	##修饰方法
	1.修饰静态方法，这样获得的就是类锁，所有该类的对象，需要获得锁的时候，都会等待并阻塞，也就是说，一个类有多个syncronized方法，一个线程通过其中一个方法占用了锁，另外线程也不能使用其余的syncronized方法，因为锁被占用了，当然，不需要锁的除外

	2.修饰普通方法，获得对象锁

	##修饰代码块
	代码块大概是这样的格式
		synchronized (xxxxx){
	        xxxxxxxxxxx     
	    }
	1.（）中是this，这样就获得了当前类的对象锁
	2.是xxx.class，获得某类的类锁 
	3.lock，无意义的锁，只是单纯为了实现同步，比如 private byte[] lock = new byte[0];

2.明日目标
<ul>1.java并发编程实践里，虽然不错，但是还是从第五章看比较好</ul>

<h1>3.12</h1>

1.并发编程思考			
<ul>1.同步容器</ul>

	为了让不同线程在访问同一容器时保持同步，就有了同步容器：Vector,HashTable等

	但会有问题，虽然容器是线程安全的，但是，外面对他的操作，并不一定安全。比如，“检查并添加”，先检查是否有某元素，检查是否为空，在进行添加操作之前，另一个线程有可能就进行检查操作，这样就可能有错

	解决办法倒是有，把整个操作变成原子操作，加上syncronized就可以，不过很影响并发性，因为加了一把大锁
<ul>2.并发容器</ul>

	为了解决前面的并发性问题，有了新的容器，并发性容器，主要有concurentHashmap,queue等等
<ul></ul>

2.concurrentHahMap
<ul>1.7</ul>
	
	jdk1.7时，concurrentHashMap底层是通过分段锁来实现,hashmap想实现同步，最垃圾的办法就是对map加锁，限制他的并发量，但是这样效率真的很垃圾，所以用了concurrentHashMap

	该类认为，可以把锁的粒度变小，不用每次都锁全表，Cmap内部有两个静态内部类HashEntry 和 Segment。

	HashEntry就是用来存一个键值对的，封装键值的对象，整体的数据可以分为N个段，每段就是一个Segment（继承了可重入类），而每一个Segment又有很多个hashBucket（桶），桶上是由链表组成的HashEntry。
	
	https://uule.iteye.com/blog/1513976  示例图在这上面

	Cmap默认是16个Segment，每一段都有自己的锁，只有用到这一段，才会阻塞，所以可以同时有16个并发，效率会提高很多，而且由于hashmmap扩容的机制（这里不是很懂???），使得写操作不会影响到读操作，而且读操作之间不需要同步（为啥？？？）
	
	
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>



<h1></h1>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
