<h1>8.1</h1>

1.刷题所得
<ul>1.Linux wget用法</ul>

	最普通 wget xxxx
	-O 重命名 / -c 继续下载，断电续存 / -b 后台下载，想看进度可以tail -f wget.log
	-A 指定下载格式 / -r 递归下载(指向的地址也会被下载)


	###想要批量下载
	1.for () 
		do 
	  url
		done
	2.wget xxx{1..100}.html  这样就是1-100
	3.把要下载的url写进txt里，一个一行，直接wget -i xx.txt
		
<ul>2.tcp/udp的具体协议</ul>

	### TCP
	http:80 / https:443
	ftp:21
	smtp:25/pop3:110 本以为邮件这种，及时性不强的应该是UDP，结果却是TCP
	telnet:23

	### UDP
	dns:53  只能说大部分是udp
	snmp:163
	TFTP:69

	### 补充复习各个osi层的协议
<ul>3.mysql</ul>

	MySQL里我了解到的，innodb是用的B+树，但是题目里做到的，大部分引擎用的是B树索引

	只有Memoery引擎显式的支持hash索引，而且hash索引只保存hash值和行指针

	MyISAM 存储引擎支持空间索引，可以用于地理数据存储

	全文索引用的是MATCH AGAINST，而不是普通的 WHERE

<ul>4.linux 各种查找的区别</ul>

	whereis:用于程序名的查找
	locate:相当于 find -name，但是更快，因为不是真的去查找相关目录和文件，而是去/var/lib/mlocate/mlocate.db这个数据库去找
	which:查找命令
	find:就不说了
	type:判断是内部命令还是外部命令，但是通常也会返回所在目录
<ul>5.java</ul>

	1.导包时，导入同名包，会编译不通过
	2.静态只能调静态，非静态可以调静态，但是静态不能调非静态
	3.一个引用对象设置为null ，那么任何它的方法调用都会是空指针异常
<ul>6.多线程</ul>

	1.说的官方一点，进程是资源分配基本单位，线城是cpu调用基本单位
	2.一个线程里可以创建销毁一个新的线程
	3.线程用户模式和内核模式下同步方式不同
	4.银行家算法是避免死锁，不是预防死锁？？为啥？

<h1>8.2</h1>

1.刷题
<ul>1.用1*3的瓷砖密铺3*20的地板有几种方式？</ul>

	1*3，当然只有一种，2*3也是一种，3*3可以横着竖着。
	接下来思考下，我第一个竖着放，剩下(n-1)*3，横着放，这些个横着的位置只能横着填满，相当于占了3个位置，那就是(n-3)*3
	所以得到状态方式 f(n) = f(n-1)+f(n-3)

<ul>2.哈夫曼编码</ul>

	首先统计所有字符出现频率，并排序，依次合并最小的两个，小的在左边，最后再编号，左0右1
<ul>3.判断是否符合第几趟快排：简便方法，把数先自己排好，第N次排序，那么就有N个数是在正确的位置，只会多，不会少</ul>
<ul>4.java类加载</ul>
<ul>5.tcp三次握手connect和accpet</ul>

<ul>6.假设某分时系统采用时间片轮转法，进程A，B，C，D需要运行的时间分别为20ms，10ms，15ms，5ms，时间片选用5ms，则平均周转时间是：</ul>
<ul></ul>
<ul></ul>

2.突然想到的
<ul>1.手写代码,手写aop,ioc，手写读写锁</ul>
<ul>2.设计题，首先别忘了，万物皆可缓存，设计一个安全接口</ul>
<ul></ul>
<ul></ul>

3.ConcurrentHashmap
<ul>1.概述：用cas和sycronized来实现。既线程安全，又保证并发</ul>
<ul>2.最关键的成员变量：sizeCTL,transferIndex(搬运下标)，当然，都是volitie的</ul>

	sizectl<0:说明有别的线程在操作，要么初始化，要么扩容，处于乐观锁考虑，就出让线程抢占权
	transferIndex：每个线程过来帮忙搬运的时候，根据这个内存可见的下标，取自己的步长任务，默认16

<ul>3.put</ul>

	1.先判断是否已经初始化，没有就去初始化
	2.算下标
	3.看下标是否为空，空就插入，不为空就拿出来再判断
	4.判断这个取出来的头结点，如果hash值为MOVED=-1，那就说明在扩容，就去帮忙，不是MOVED，那就加锁sycronized，进行插入
	5.插入完判断，链表>8，变树或者扩容(元素小于64)
	6.全部弄完后判断阈值，是够扩容，阈值就是sizectl=0.75N
<ul></ul>
<ul></ul>
<ul></ul>

4.变种背包问题
<ul>1.题目：给一个背包容量，和一个物品重量列表，问，不超过重量的前提下，有几种方法，啥都不放也算</ul>

<h1></h1>

1.网易笔试
<ul>1.一个成绩列表，现在给一个成绩，快速找出小于等于它的数量</ul>

	我自己的做法，时间复杂度过高，先是对成绩排序，从后面遍历，找到的第一个等于的就是它的下标了，唯一的优化就是前面的不用找了，但是最差情况还是要N的遍历，所以时间超了

	###大神做法
	用O(n)的桶排序，只要事先做一个遍历，存下每个成绩的人数就好了

<ul>2.给一个数组，首尾是相连的，问移动元素，能不能做到每一个元素，他们相邻之和总是大于它本身</ul>

	我实在是没辙
	
	###大神做法
	首先从小到大排序，那就是a(1),a(2)...a(n-2),a(n-1),a(n)，仔细观察，现在除了a(n)，另外所有元素，它身边都有比自己大的，那现在来分析 a(n)。先判断 a(1)+a(n-1)，不行的话，就交换 n 和 n-1 ，a(n)身边是a(n-1)+a(n-2)，这个还不行的话，就是不行了，可以就是可以

<ul>3.给一堆数，其中两两相加是奇数，就可以交换，相加为偶就不交换，求任意交换后，字典序最小的排列</ul>

	我自己毫无头绪

	###大神做法
	若全部奇数，全部偶数，加起来肯定是偶数，就不换。假若有奇数，可以发现，用奇数作为桥梁，两个偶数可以随意交换，用偶数做桥梁，两个奇数可以任意交换，一奇一偶本来就可以随便换，所以实际上，一旦有奇数，整个数组就可以任意交换，那就直接字典序排序就行

<ul>4.给一堆数，假设有一种操作，查询数组中大于等于K的数，并把这些数-1，返回减的次数</ul>

	我自己的思路，按照题目写下去，但是通过 0 %

	###大神思路
	利用桶排序


2.JTA事务
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

3.今日的总结
<ul>1.涉及排序的题目，一旦时间复杂度过高，就考虑桶排序</ul>
<ul>2.仔细审题，找规律</ul>
<ul>3.暴力破解的时候，考虑下回溯法</ul>
<ul>4.计算日期差，时间差的时候，还是先全部换算成分钟，小时，提案，统一单位比较容易</ul>


<h1>8.4</h1>

1.广度遍历训练
<ul>1.矩阵中有0有1，1代表阻塞，0代表可通行，方向可以是八个方向，求左上角到右上角的最短距离，不通就是-1</ul>

	有点像层序遍历的思想，用一个queue来做，一层就是一次八个方向，能通的就放进队列尾部，一轮count+1，终止条件是到了左下角。

	###注意点
	1.由于对一个点，要有八个方向的操作，单独弄出一个函数不太行，可以设一个列表，是八个方向+1-1操作，到时候一个点去遍历就好，一份代码搞八次。

	2.考虑特殊情况，左上角和右下角不为1，就直接返回不可能
	3.这种各个方向的遍历，为了防止死循环倒回去，已经用过的值，设为阻塞

	##代码
	def shortestPathBinaryMatrix(self, grid):
		###左下角和右下角特殊
        if grid[0][0]==1 or grid[-1][-1]==1:
            return -1
		###八个方向的，准备遍历
        direct = [[-1,0],[0,1],[1,0],[0,-1],[-1,-1],[-1,1],[1,1],[1,-1]]
		###起始的左上角下标
        queue = [[0,0]]
        path = 1
        while(queue):
            size = len(queue)
            path+=1
            for i in range(size):
                cur = queue.pop(0)
                for dir in direct:
                    row = cur[0]+dir[0]
                    col = cur[1]+dir[1]
					####判断边界
                    if row<0 or row>=len(grid) or col<0 or col>=len(grid[0]) or grid[row][col]==1:
                        continue
                    if row==len(grid)-1 and col==len(grid[0])-1 and grid[row][col]==0:
                        return path
                    queue.append([row,col])
					###已经弄过的，设为1
                    grid[row][col]=1
		###能走的都走了，还是没有，那就是不通
        return -1

<ul>2.树的左下角的值，也就是最后一行的最左值：层序遍历</ul>
<ul>3.给一个正整数，让它等于多个完全平方数的和，求最少几个，若不能等于就返回-1</ul>

	这道题，难就难在，把看起来无关的东西，思想上转化成广度遍历。在这里，一个元素就是[n,count]，N是目标和，每一轮去减去完全平方，做类似层序遍历的操作，入队出队，直接找到了，就是最少的数，就直接返回

	###注意点
	这个和那啥搜索题目一样，用过的 N 值要记录，否则死循环



广度遍历用queue来做，一般适用于


<h1>8.5</h1>

1.**前面的没解决的**
<ul>1.子数组最大和，最长连续子数组，动态规划</ul>
<ul>2.7/30/4，打家劫舍3</ul>
<ul>3.分布式session（负载）</ul>
<ul></ul>

2.**杂**
<ul>1.mysql</ul>

	hash索引只存key和行指针
	全文索引innodb也支持，myisam也支持，不用where，用的是MATCH AGAINST
	MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。
<ul>2.char型变量中能不能存储一个中文汉字？</ul>

	当然可以，char变量占两个字节，两字节16位，就是65536个汉字，不过这些都是常用的。中文太多了，所以还有三个字节的，也有四个字节的

	不过也不好说，java是unicode编码形式，具体的实现还有很多，比如gbk,utf8,utf16，就比如gbk是2字节，utf8是三字节，utf16是4字节

	###链接
	https://blog.csdn.net/yaomingyang/article/details/79374209
<ul>3.java线程的状态</ul>

	创建态：new 
	就绪态runnable: Thread.start()
	运行态running: run
	阻塞态:Thread.sleep()  wait()  join()
	死亡态
<ul>4.sleep和wait的区别</ul>

	###
	sleep是Thread的静态方法，是让当前线程休眠，出让cpu，但是不释放锁。wait是干脆释放锁，并把当前线程放进等待池中，等待被唤醒

	###sleep 和 yield
	sleep使用后，进入阻塞状态，给了更小优先级线程机会。但是yield短暂的出让cpu，让当前线程变成就绪状态，也就是还可以参与竞争，低优先级的还是没有机会

3.**设计一个安全的接口**
<ul>1.token的彻底理解</ul>

	之前一直糊涂的，其实只是一个签名的过程

	token最常用的就是JWT，分为头部，负载，签名，当客户端首次登陆成功，服务端就利用私钥生成一个token，头部是运用的加密算法，负载是时间戳，用户id等自定义的东西，签名是根据这些并利用私钥生成的签名。这些作为token发给客户端，存在localstorage中。以后客户端做啥，都带上token，服务端拿到就用公钥解密，看解密出的东西和负载是不是一样。

	###本质上就是对签名的理解
	加密是用公钥加密，私钥解密。签名是私钥加密，公钥解密。目的是校验是不是原来的东西
	
	###题外话
	cookie使用的时候，一般用session-cookie的机制，cookie中有sessionID,看看有没有就行。每次都查询数据库不太好。所以用缓存吧

<ul>2.利用token实现较为安全的接口</ul>

	1.token签名
	2.签名中引入时间戳。比如某一个token的时间戳是123，有黑客抓到token，一模一样的请求，由于时间戳参与签名计算，所以时间戳不能更改，当时间戳和当前的差距过大，就认为是过期的，需要重新验证
	3.又或者，由于负载中有自定义信息，完全可以是ip，设备id，可以限制它的访问频率和访问ip
	4.对敏感数据加密，公钥私钥可以存在负载里
	
	##和token无关
	直接客户端和服务端约定好一个公私钥匙，用于签名
<ul>3.总结：签名是为了保证数据不被篡改，加密才是保证保密性</ul>
<ul>4.链接：https://www.jianshu.com/p/12db60a7062b</ul>
<ul>5.拒绝重复提交</ul>

	1.基于时间戳，比较60s的差距
	2.（nonce）每次客户端请求时，都随机生成一个字符串，可以是ip，设备id，mac地址等做个hash,也可以是时间戳等，用签名的方式来保证他不被篡改。每次都存储，如果出现一样的，就是非法请求，但是这样这个存储的集合会越来越大。可以一天清理一次
	3.结合时间戳和nonce，只有当超过60s的请求，我们才存储，这样量就小了


从阿里的面试题来看为什么ThreadLocal属于并发精髓。
2、为什么Spring里要用ThreadLocal？
3、探究ThreadLocal的源码实现。
4、ThreadLocal居然有内存泄露！为什么？

<h1>8.6</h1>

1.**多线程练习**
<ul>1.线程创建</ul>

	###Thread类
	1.继承Thread,作为子类重写它的run方法
	2.匿名类
		new Thread(){
            @Override
            public void run() {
                super.run();
            }
        }.start();

	###实现runnable，再包装进Thread里
<ul>2.两个线程交替执行：抢同一个object锁，synchronized代码块把操作包起来，然后先唤醒等待锁的线程notify，再wait出让锁
</ul>
<ul>3.三个线程交替执行（交替打印ABC）</ul>

	###synchronized 加 wait/notify
	设置三个对象锁。三个线程，每一个都设置好pre,cur，必须同时拿到这两个锁，才可以执行。
	synchronized(pre)
		synchronized(cur)
			xxxx
			cur.notify //唤醒等待cur的线程，逻辑上只会是next下一个
		//这里做完了，就释放了cur，next就拿到了
		
		//这里手里还拿着pre,要释放，不过为了最终程序能停下，判断是不是到了终止条件
		if (终止)
			pre.notify  //这里先唤醒要用pre的线程
		else
			pre.wait  //出让锁，让自己再继续等待，如果不做判断，出让之后就会一直等待
		
	ps：小问题，这样写可能会死锁，所以三个线程开启时，中间有停顿，thread.sleep
	
	###只用Lock
	三个线程共用一个count，每一个线程lock.lock拿到锁，就判断做不做，做或不做，最终都unlock，可以设置成可重入锁的公平锁，就能保证同一个线程不会一直拿到锁

	###Lock+Condition
	condition对象这么创建 lock.newCondition.
	打比方
	Condition A = lock.newCondition();
    Condition B = lock.newCondition();
    Condition C = lock.newCondition();
	A.await(),就是A场景释放锁并等待，下次就可以A.signal唤醒它

	所以可以这样做，大家都第一时间抢锁，抢到判断是不是自己，不是就按照场景出让,比如要打印A的线程拿到了，结果不该打印A，就A.await()。如果要打印，打印完之后 B.signal()就唤醒了B

	###信号量Semaphore
	Semaphore A = new Semaphore(1);
	Semaphore B = new Semaphore(0);
	Semaphore C = new Semaphore(0);
	设置三个信号量，A.acquire()就是-1，release就是+1，一开始A是1，就A-1，打印A，让B+1，然后B也卡在信号量，+1了就可以-1了，打印B，C+1，就这个逻辑
	
	A.acquire();
    System.out.print("A");
    B.release();


<ul>4.线程池操作</ul>

	ExecutorService executorService = Executors.newFixedThreadPool(maxPoolSize);
	while(true){
                if (queue.size()>0){
                    int active = executor.getActiveCount();
                    if(active<maxPoolSize){
                        executor.execute(new ValidateProcessor(queue.poll(),blankKeyWords));
                    }else{
                        //线程池满
                        logger.info(" 线程池满，等待中");
                        Thread.sleep(200);
                    }
                }else {
                    logger.warn("Queue is empty!");
                    break;
                }
     }
<ul>5.交替执行链接：https://blog.csdn.net/xiaokang123456kao/article/details/77331878</ul>

2.做题训练
<ul>1.一个手机有9个键，上面有各种字母，比如2是"abc"，现在给出一个字符串"234"，返回所有可能的结果列表(力扣17)</ul>

	###单纯的递归
	设置一个类变量[],去递归，符合就加入，但是答案错误，力扣运行错误

	###回溯法
	把res结果列表也传进去，用回溯，终极目标是返回res，中间的时候，比如是2，就a传进去，返回res，再把这个res和b传进去，最终返回res 
	
<h1>8.7</h1>

1.做题集训
<ul>1.ip地址的复原</ul>

	用回溯法，需要注意的就是ip地址的特性，4段地址，0~255,可以一个单独的0，但是不能01。用递归，传入res，符合就加进去，然后返回res，上一层拿到res再丢进去。

	def foo2(self,s,res,index,temp):
        if index==4:
            if len(s)==0:
                res.append(temp[:-1]) #删掉最后的 .
            return res
        if len(s)==0:
            return res
        if s and s[0]=="0":
            return self.foo2(s[1:],res,index+1,temp+s[0]+".")
        res = self.foo2(s[1:],res,index+1,temp+s[0]+".")
        res = self.foo2(s[2:],res,index+1,temp+s[0:2]+".")
        if int(s[0:3])>0 and int(s[0:3])<=255:
            res = self.foo2(s[3:],res,index+1,temp+s[0:3]+".")
        return res

	###回溯总结
	最外层其实就是一次的顺序，每一种情况递归进去就好了。需要的是结果集合，就每次递归返回集合，需要的是某个路径啥的，传进去的时候是地址传递，所以记得不符合就从路径中删除
<ul>2.最长回文子序列</ul>
<ul>3.最长回文子串</ul>

2.redis项目和其他
<ul>1.redis与高并发(读写分离，主从复制)</ul>

	redis是单线程，但是可以处理高并发，是因为使用了非阻塞的多路复用，是epoll实现的

	单机redis qps大概十万，可以使用主从复制，master负责写，slave负责读，支持水平扩展。redis采用异步复制，做复制的时候，不会影响master写的操作，复制的时候，也不会影响slave自己的读操作，但是在复制完之后，会加载新数据，这段时间会block

	具体一点，slave连上master，如果是重连，就只发这段时间缺的，如果是第一次连，就master新开一个线程，去生成一个RDB的快照文件，发给slave，slave收到就 先写进本地磁盘，然后加载进内存/当然了，主从之间是有心跳的
<ul>2.redis单线程为啥这么快</ul>
	
	1.基于内存读写
	2.单线程，实际上操作基本也只有读/写/开/关，操作具有原子性，不需要锁，就算有复合操作，也是连接端用代码同步好
	3.减少了线程切换的消耗
	4.数据结构很多使用了hashmap，而且数据的粒度非常小
	
<ul>3.应对高并发的策略</ul>

	1.缓存
	2.页面静态化
	3.延迟发布，先存进队列
<ul>4.redis事务/事件/watch</ul>

	MULTI开启事务，之后的所有语句，都返回queued，也就是加入了队列。如果有错的语句，在老版本中，当EXEC执行时，将会忽略错误的，执行正确的，现在的版本是，有错的，就全部丢弃。

	watch就是监听某个值，比如watch name。那么在事务中，另一个事务exec提交了，并更改了name，那么当前事务就失效，如果另一个只是加入队列而不是exec，就可以正常走。watch必须和multi搭配使用，而且必须在multi之前

	DISCARD就是丢弃事务和当前队列中的语句

	###总结
	watch，就是乐观锁

	###重点
	redis没有回滚，事务中语句错就是错，全部丢了。因为redis报错只可能是语法错误，而事务回滚这个东西，只会解决线程安全出现的问题，根本上解决不了程序员出的错。所以干脆不回滚
<ul>qps/tps/Nginx：多进程单线程模型 
Memcached：单进程多线程模型</ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
1.客户端在签名的时候，用的私钥哪里来的，是客户端第一次用账号密码验证通过时，服务端给的吗
2.服务端验证token时，对签名解签，再和负载里的东西对比是吧


<h1>8.8</h1>

1.**mysql为什么使用自增id作为主键**
<ul>1.这里会用到的知识点</ul>

	###聚集索引
	就是索引顺序和实际数据排列顺序一致的索引，一张表只有一个聚集索引。所以大部分时候，主键就是他的聚集索引，通过聚集索引，可以找到所有的数据行数据。非聚集索引也可以称之为辅助索引，只存了一行中的某些字段数据，和一个指向主键的指针，所以会进行二次查找

	如果表没有主键，就会找第一个不含null值的唯一索引，如果还没有，innodb还有一个隐含的自己生成的字段ROWID作为主键，也是自增的(引申一下，innodb行级锁，是因为走了索引，不走索引，就是表级锁，3月日记中有)

	###B+树
	所有数据都在树的叶子节点上，为了查找啥的方便，其实是有序排列的，而且是双向连接的。每一个叶子节点也不是直接就是数据，而是一个内存页，页上的数据有序排序

<ul>2.原因</ul>

	基于上面，可以发现，数据是按照顺序存储的，所以数据库也希望，新来的数据是有序的，这样就可以直接插在后面，而不是散乱的随便插入，十分影响效率。只要按照顺序，存取效率都会提高。当顺序插入后发现一个页满了，或者是接近满了，就会开辟新的页

	由此也可以得出，为什么删除一条数据后，前面的自增id不会自动补上，因为自动补上会牵扯到很多数据的移动，消耗太大，所以还是用逻辑删除

2.**智力题**
<ul>1.给3L，5L的桶，怎么取4L的水</ul>

	3L的装满，放进5L里，5L的还剩2L空间，3L的再装满，把5L的填满，3L的里面还有1L，把5L倒掉，1L存进来，3L打满再装进来，就是4L
<ul>2.两根不均匀的香m,n，都是一小时，怎么凑出15分钟</ul>

	m先两头一起烧，n跟着烧，M烧完了，n还有半小时的量，n再两头烧，就是15分钟

3.**synchronized底层**
<ul>1.底层原理</ul>

	synchronized修饰代码块，javap转成字节码之后，发现，在进入代码块时，调用了monitorEnter,结束时调用了monitorExit，其实monitor就是每个对象都有的一个对象锁，拿到后计数器+1，释放就-1，所以synchronized也是个可重入锁，因为使用了计数器这种东西

	monitor是对象头中指针所指向的monitor对象，每个对象都会有，所以每个对象都能作为锁，类锁就是类的monitor，对象锁就是对象的monitor

	而修饰方法就有点不一样，没有使用monitorEnter这种JVM命令，而是方法表结构中有一个标志位ACC_SYNCHRONIZED ，有了这个标志，JVM就知道这是个同步方法

<ul>2.虚拟机对锁的优化</ul>

	###为啥要优化
	monitor的重量级锁，是依靠操作系统的mutex lock互斥锁来做的，而操作系统线程切换需要从用户态到内核态，频繁切换成本高，效率低，所以进行优化，让他不需要一上来就是重量级锁

	###优化内容
	锁的状态分为了4中，无锁，偏向锁，轻量锁，重量锁，锁的重度一步步上升，而且只可以从小到大，不可以从大到小

	###偏向锁
	使用场景是，从头到尾只有一个线程在不断的获取锁，拿到锁，释放锁，拿到锁，释放锁，明明没有线程安全问题，也不存在竞争，却一直把cpu从用户态唤醒到内核态，浪费资源。所以首先第一个线程拿锁，先给他偏向锁，在对象头中标记锁的拥有者，以后其他来了，判断是拥有者（判断方法是cas修改拥有者，修改成功，就进入，失败说明其他线程来了），直接进入代码块，不需要同步

	###轻量级锁
	偏向锁遇到了其他的线程，不行了，就变成轻量锁。
	轻量锁的设计思想是，绝大部分的锁竞争，都是错开的，哪有这么巧的，当然这是经验性的数据。
	所以当一个线程来拿锁，会先复制一份锁记录到栈中，cas的去修改对象的mark word值，修改成功，说明拿到锁了，修改失败，说明有其他的线程也在竞争，尝试性自旋锁，如果自旋还不行，那就升级成重量锁

	本质是为了减少使用操作系统互斥量的次数

	
<ul>3.synchronized和重入锁的联系与区别</ul>

	##同
	1.都是可重入锁

	##异
	1.层面不一样，一个是JVM层面，一个是jdk
	2.ReentrantLock功能更强大，比如公平锁，比如锁可以绑定condition条件


<ul>4.自旋锁</ul>

	首先竞争锁，竞争失败按照道理会阻塞，但是先不，而是进行无意义的循环，一直重复竞争锁，实在不行那只能阻塞了。

	如果自旋状态时拿到锁，那就皆大欢喜，因为挂起线程/恢复线程的操作都需要转入内核态中完成，用户态到内核态切换，又要浪费资源

4.分布式session
<ul>1.session的共享复制：比如多个tomcat之间的共享复制</ul>
<ul>2.session的广播</ul>
<ul>3.粘性session，你第一次到的哪，强制规定你以后都要去那里</ul>
<ul>4.缓存，万物皆可缓存</ul>


<h1>8.9</h1>

1.做题
<ul>1.N个人报数，报偶数的出列，报完一轮后累加报数，从剩下的继续，求出列顺序</ul>

	比如1~6，出列顺序就是2，4，6，3，5，1
	我是这样做的，准备两个列表，一个按照顺序装满，一个空着。
	while 循环，i=1报数递增，每次报数都pop，当是偶数就出列，奇数就pop同时加入另一个queue，当第一个queue弄完，就交换队列，继续while，直到两个都是空


<h1>8.10</h1>

1.动态规划训练	
<ul>1.最长递增序列（以前做过）</ul>

	设置dp数组，dp[n] 表示以第n个元素结尾的递增序列的最大长度。
	dp[0] = 1，从1遍历，里面再从0开始遍历，找到符合递增的最长的长度，把相应dp[k] = dp[m]+1
<ul>2.最长数对链长度，给出[[1,2], [2,3], [3,4]]，要求第一个元素小于前一个对的第二个元素，才可以接上去，求最长长度，注意不一定按顺序，可能[[3,4]，[1,2], [2,3]]</ul>

	###动态规划
	既然不一定按照顺序，就按照第一个元素排序
	然后就是和最长递增序列一样的思路

	###贪心
	按照第二个元素排序，每次都找符合要求的，第二个元素最小的加进来就可以
<ul>3.摆动序列</ul>

	###复杂版
	和上面的最长递增序列一样

	###复杂度o(n)
	可以换个思路，最长的摆动序列长度，其实就是整个序列的波动次数，一直递增，或者一直递减，都不会影响，只要记录下转折的次数就好了

	设置两个dp数组，up,down,起始都是1
	从下标1开始遍历，当i>i-1，说明向上了，up[i]=down[i-1]+1,down[i]还是延续i-1,下降亦然,相同则都延续上一个,最后返回两个数组的最后一个的较大值即可,就是波动转折的次数,复杂度N
<ul>4.最长公共子序列</ul>

	##动态规划
	一般一个参数的,就是一维dp数组，两个参数的，就是二维dp数组，这里就是二维dp数组,dp[i][j]，代表前i个和前j个公共的最长值，写出状态方程

	dp[i][j] = dp[i-1][j-1]+1   if s1[i]==s2[j]
	dp[i][j] = max(dp[i-1][j],dp[i][j-1])  不等于
<ul>5.01背包重新写</ul>
<ul>6.分割相同和的子数组/加上正负号</ul>

2.找规律问题，比如报数


<h1>8.11</h1>

1.日期操作(以前由于思路不对，又繁琐，还出错)
<ul>1.给两个年月日，计算相差多少天</ul>
<ul>2.给一个起始年月日，和一个天数N，计算N天后的日期</ul>
<ul></ul>
<ul></ul>

2.杂
<ul>1.昨天的sorted</ul>

3.做题
<ul>1.约瑟夫环，一群人报数，报到M时出列，剩下的人接着报，循环着来，求出列顺序</ul>

	高大上的数学算法我就不考虑了，直接使用循环数组来做


<h1>8.12</h1>

1.**做题**
<ul>1.加密密文</ul>
<ul>2.一排发奖金（本质是力扣题，困难之分糖果）</ul>

	一排孩子，每个孩子都有一个评分，要满足两个条件，一是每个孩子最少1个糖，二是，相邻孩子中，评分高的必须糖多一点。注意，这里的题中，评分相同孩子没有要求糖一样多

	从左向右遍历，只检查一点，右边评分高的，就比前一个孩子糖果+1，一遍弄完后，从左到右方向上都对了，但是会有这种情况，左边的比右边的大，没有考虑进去，这时候再从右到左，当左边的评分大于右边，而且左边的糖还比右边少或者等于，就让左边的变成后面的+1。

	前面左到右排好的不会动，因为后一次的判断条件里没有他，非相邻的也不碍事
<ul>3.树</ul>


<h1>8.13</h1>

1.代码题
<ul>1.python sort与sorted:sort是原址操作，sorted有返回值</ul>
<ul>2.java 的排序：ArrayList的sort需要传入comparable，Arrays.sort是原址排序，不过只能用于数组</ul>
<ul>3.N个任务，每次批量处理M个任务，返回每个任务的累加值</ul>

	写一个函数，就是处理M个任务，参数是index，就是从第几个任务开始。里面用ExecutorCompletionService，传入线程池和阻塞队列，之后调用take()就可以获取最先结束的一个Callable，然后调用get

	Callable的call方法不带参，可以自己实现callable接口，里面重写构造方法

	cas的api是UnSafe下的，Unsafe.getUnsafe().compareAndSwapInt(xxxx)
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>


2.activemq
<ul>1.消费者不消费，服务相当于停了</ul>
	
	一般情况下，activemq的消息是持久化的，没有持久化，就是存在内存中的，当消息堆积过多，内存不够，会写入临时文件，腾出内存。但是同样是写进磁盘，非持久化的写进临时文件和持久化的写入不一样，持久化的在重启之后，会从文件中恢复数据，写入临时文件的重启了就是删除了

	配置中，比如设置了2G的持久化大小限制，超过2G，生产者阻塞，消费者连接正常，而且消费也正常，消费出空间后，生产者继续

	设置2G临时文件大小，超过2G，生产者阻塞，消费者显示连接正常，但是消费，就一直在那挂着，服务相当于挂了。应该是activemq的坑

	###解决
	重启activemq，但是会数据丢失，或者使用持久化，额外多消耗一些时间而已
	
<ul>2.消费不均匀，一个一直跑，一个基本不跑</ul>

	activemq有预取机制，就是一个prefetch的配置，一次取数据的过程，队列会一次性推给消费者 N 个消息（配置好的，默认1000），这些消息当然还是存在服务端的，因为没有被确认，所以没有被删除，但是他们实际上已经处于“已分配，未消费”的状态，如果那个消费者挂了，当然可以重新分配，但是如果没挂，又不挂又不消费，消息就会堆积。

	当堆积的消息到了prefetch值时，就不会再向这个消费者发送消息。而相应的，一个消费者存了很多数据不消费，其他消费者就没事干了

	与此同时，由于消息的堆积，如果没有开启持久化，而内存又告急，就会存入临时文件，然后就是假死
<ul>3.链接：https://blog.csdn.net/u010310183/article/details/51690876</ul>
<ul>4.https://blog.csdn.net/u010310183/article/details/51683141</ul>

3.Linux操作
<ul>1.查看目录下最大的文件：</ul>

	du -ah/sh | sort -nr | head -n 10
	-a all
	-s 当前目录
	-h 人看的
	-n 按照字符顺序
	-r 逆序

	###查看目录下文件大小
	du --max-depth=1 -h 看一层
<ul>2.查看目录下最近修改的</ul>

	-mtime就是按天算	

	查找最近30分钟修改的当前目录下的.php文件
	find . -name '*.php' -mmin -30

	查找最近24小时修改的当前目录下的.php文件
	find . -name '*.php' -mtime 0

	查找最近24小时修改的当前目录下的.php文件，并列出详细信息
	find . -name '*.inc' -mtime 0 -ls

	查找当前目录下，最近24-48小时修改过的常规文件。
	find . -type f -mtime 1

	查找当前目录下，最近1天前修改过的常规文件。
	find . -type f -mtime +1

<ul>3.查看端口并杀死进程</ul>

	###查看端口状态
	netstat 
	-t tcp/-u udp
	-p 显示端口具体状态
	-l 仅列出在监听的端口
	-n 拒绝显示别名
	可以配合grep使用

	###
	lsof -i:端口号 查看占用端口的进程
	
	kill -9 $(lsof -i:端口号 -t)
<ul>4.查看进程</ul>
<ul>5.查看文件的第几行</ul>

	###看头尾
	head -5 xxx 看xxx的前五行
	tail -5
	tail -f 动态看

	###随便看
	sed -n '5,10p' /etc/passwd  看5-10行

<ul>6.读取查看超过内存文件</ul>

	cat xxx|more
<ul>思科？？</ul>


<h1>8.14</h1>

1.做题
<ul>1.二叉树中找俩数，和为目标值</ul>

	###自己的想法
	第一反应递归。但是不太好写。本来想带着目标值，一层层减下去，return的时候就是左右的bool值，但是失败了，题目规定是俩数。
	
	那就另写一个函数，判断树中是否有某值，外层遍历树，每个节点都调一次函数，事实上我就是这么写的，然后注意点细节，比如那个foo函数，要从root开始找，而且不能是外层进来的那个值，比如就一个root=1，要找2，1重复两次不就也是吗，这样就错了

	###较好的方法
	遍历树，不管是搜索树还是普通树，拿到值组成列表，排序，然后就变成查找二数和题目了
<ul>2.一个特殊的二叉树，要么0个子树，要么2个都有，而且根节点肯定小于等于子节点，节点值可以相等，求第二小的值</ul>

	仔细分析，根节点肯定是最小的，那么第二小的只能是它下面的了，分别左右递归下去，找到的第一个大于根的，就是该分支子树的最小值了，两者取小就行

 	def findSecondMinimumValue1(self, root):
	    if root:
            if self.minV == 0:
                self.minV = root.val
            if root.val > self.minV:
                return root.val
            left = self.findSecondMinimumValue(root.left)
            right = self.findSecondMinimumValue(root.right)
            if left!=-1 and right!=-1:
                return min(left, right)
            elif left!=1:
                return left
            elif right!=-1:
                return right
            else:
                return -1
        else:
            return -1

<ul>3.打家劫舍3，间隔遍历</ul>
<ul>4.保持城市天际线</ul>


<h1>8.15</h1>

1.做题
<ul>1.二叉树寻路（大佬思路无敌，究极位运算）</ul>
<ul>2.分割字符串</ul>
<ul>3.不同的二叉搜索树个数</ul>

	给一个n ,求以 1~n 为节点的二叉搜索树能有几个

	解：动态规划
	n=1 当然就一个
	n=2 两个互换位置，2种
	n=3 1，2，3三个数轮流做头结点，剩下的做左右结点，比如1做头，23只能是右节点，23排列是2种，那以1为头的就两种
	以此类推

	def numTrees(self, n: int) -> int:
        dp = [0 for _ in range(n+1)]
        dp[0] = 1
        dp[1] = 1
        if n>=2:
            dp[2] = 2
            for i in range(3,n+1):
                for j in range(i):
                    dp[i] += dp[j-0]*dp[i-j-1]
        print(dp)
        return dp[n]


2.做题之回溯训练
<ul>1.组合总和，给一个数的列表，和一个目标值，找出所有和为目标值的组合，同一个数可以重复利用</ul>

	总结出回溯法套路

	1.首先定义出dfs框架

	def dfs(res,temp,nums,target,level):
	res是返回的结果，不一定要返回
	temp：中途的path，如果最后符合，再加入res,python由于浅复制，可以在加的时候，temp+[]，就是一个新的了
	nums：数组列表
	target：目标值，一般可以用过一个之后，target-num[i]
	level:就是用到的下标

	2.dfs的一般逻辑
		首先定义结束条件，一般是target等于0
		然后开始搜索{

			for {
				temp.append(i)
				dfs(下一层)
				返回之后，发现不行或者是完事儿
				temp.pop(i)
				由于外面是for，还会有下一次
			}
		}

	本题代码
	def dfs(self,res,temp,nums,target,level):
        if target==0:
            res.append(temp+[])
            return
        for i in range(level,len(nums)):
            temp.append(nums[i])
            if target-nums[i]>=0:
                self.dfs(res,temp,nums,target-nums[i],i)
            temp.pop()
<ul>2.所有可能的子集，包括空集</ul>

	def dfs2(self,res,temp,nums,level):
        if level==len(nums):
            return
        for i in range(level,len(nums)):
            temp.append(nums[i])
            if temp not in res:
                res.append(temp+[])
            self.dfs2(res,temp,nums,i+1)
            temp.pop()

	###讲解
	参数中，由于没有目标值，那就没有
	结束条件，当level=len(nums)，是超出了数组，所以结束
	搜索方面，for循环肯定要的，然后是temp的push和pop，中间是下一层
<ul>3.生成合法的所有括号组合，输入一个整数n ,返回n 对括号的所有组合</ul>

	根据上面的套路，我首先写下了dfs方法
	def dfs(res,temp,level,n) 这里没有目标值，但是有n的边界值
	然后是结束条件
	level = n*2
	然后是搜索
	for i in range(level,n*2):
		temp+="("
		下一层
		temp-="("
		temp+=")"
		下一层
		temp-=")"
	其中一个判断条件就是当前字符串合法吗，所以又要加一个判断的函数
	结果超时
	
	###优化版
	def dfs(res,temp,n,left,right) 这里直接就把合法与否写进来了，level也不要了
	结束条件 len(temp)==n*2
	搜索代码
	if left<n:
         dfs(res,temp+"(",left+1,right,n)
    if right<left:
         dfs(res,temp+")",left,right+1,n)
	
	为什么这里没有退一步这种操作？因为这里的判断条件已经把所有的合法的可能都写进去了，成立就直接加进去了，不用退回来，主要是条件写的太好了
		
<ul>4.组合之和2，就是上面第一题的修改，这次改成，每个数都只能用一次：只改了一个地方，i+1，下标用完加了1</ul>

3.其他小细节
<ul>1.一个列表，list+[]就是一个新的了</ul>

	[1]+[] = [1]
	[[1],[2]] + [] = [[1],[2]]
	[[1],[2]] + [[]] = [[1],[2],[]]


<h1>8.16</h1>

1.做题
<ul>1.N皇后，困难题，看了题解才写出来，但还是超时</ul>
<ul>2.一个整数N，求各个位上都不相同的N位数，比如N=2，11，22，33就不行，有91个是[0,100）的范围</ul>

	###被秀了，自己想的是回溯
	1.def dfs(res,temp,n,level) ，这里的res不是一个列表结果了，而是一个数，所以需要返回。所以到达边界，return res,平时下一层的时候，也要res = foo(),在最后，也要return res
	2.结束条件，level==n
	3.搜索
	     for i in range(0,10):
            if i not in temp:
                temp.append(i)
                if temp[0]!=0:
                    res = self.dfs2(res + 1, temp, n, level + 1)
                temp.pop()
	超时，大大的超时

	###正确思路，dp
	由于第一位可以用10个数，然后他用了一个，第二位只能用9个数，第三位只能用8个数，以此类推。需要注意，0不能作为开头，所以当N>1时，第一位只能用9个，是9987654321的顺序
	
	状态方程 dp[i]=dp[i-1]+填满 i 位的所有可能，就是那个9*8*7*6的那个

<ul>3.组合之和3：给一个目标值N，和个数k，求和为N的K个数的所有组合，每个元素都是1~9，不能重复</ul>
	
	思路和前面的一样，但是会有重复，比如 123和132，那我们就规定，每次比如取了1，下一次就取比1大的，就避免了重复

<ul>4.一个二叉搜索树，每个节点值唯一，而且是正数，把每个节点的值都更新成整个树中大于等于它的值的和</ul>

	因为是搜索树，所以大于等于就是它的右子树的和包括它自身。我想到递归下去，会有重复的计算，能不能用dp，想了很久想不出来

	###正确思路
	因为是大于等于它的和，所以要先拿到整棵树右边的值，那就中序遍历，右根左，外面弄一个sum和，轮到一个节点，就累加，并赋值
	 if root:
            self.bstToGst(root.right)
            self.value += root.val
            root.val = self.value
            self.bstToGst(root.left)
            return root
     else:
            return None

<ul>5.给一个（）组成的字符串，可能合法可能不合法，现在可以任意添加，求让它变合法的最少次数：栈，别的不多说</ul>
<ul>6.给一个字符串列表，和一个模式，找出所有符合模式的字符串，比如aab模式，字符串'mee'就是符合的</ul>

	##我的想法
	用下标来代替字母。字母不同，很难去解决，但是可以转换。比如aab,就可以变成002，a是下标0，b是下标2，只要符合就选出来就行。

	复杂度有点高，遍历word是一次，找出下标又是一次循环，每个word都来一遍又是一次，所以是 o(n^3)

	###大神思路
	双映射表，用两个map来实现。
	m1, m2 = {}, {}
    for w, p in zip(word, pattern):
        if w not in m1: m1[w] = p
        if p not in m2: m2[p] = w
        if (m1[w], m2[p]) != (p, w):
            return False
	遍历嘛，两个都是新的，那就互相指着，如果一个是新的，另一个是老的，就会被检查出来，复杂度 o(2n)
<ul></ul>


2.杂
<ul>1.python join</ul>

	str = "-";
	seq = ("a", "b", "c"); # 字符串序列
	print str.join( seq );
	输出 a-b-c


<h1>8.18</h1>

1.分治法
<ul>1.最经典，快排</ul>

	先总结下分治的模板
	创建一个partition函数，参数一般是nums,l,r
	
	##快排讲解
	创建partition，参数nums,l,r,首先拿最后一个元素做标准，弄两个下标，一个i = start-1，一个从start开始，一旦比flag小，就i+1,并放在那个位置，全部做完了，start~i 就是小于等于flag的部分，i+1到最后是大于等于的，现在要让flag归位，就把i+1和end换位置，最后返回这一轮排好的下标

	在外面，拿到这一轮弄好的下标，然后再递归就好
<ul>2.最大子序列和分治法</ul>

	dp方法没啥好说的，就说分治的。
	首先写一个def partition，参数照常start,end。每次都求出四个值，左边最大的，右边最大的，包含中间值的左最大和右最大，比较即可

<ul>3.为运算表达式设计优先级，就是给一个算式的表达式，可以任意加括号，求所有可能的结果</ul>

	###我的失败笨拙思路
	既然是任意加括号，比如"2-1-1"，可以是2-(1-1)=2，也可以啥都不加，2-2-1=0，在所有可能加的地方都加上，结束条件是到了末尾，就把结果存下来，本质是回溯法，不过这个加很有学问，结果写不出来

	###正确思路
	分治法，遍历表达式，遇到一个运算符，cur = exp[:i-1] + exp[i+1:]，当exp全是数字，就结束

	def partition3(self,exp,start,end):
        if 不含运算符:
            return [int(exp[start:end+1])]
        else:
            res = []
            for i in range(start,end):
                if exp[i] in ["+","-","*"]:
                    pre = self.partition3(exp,start,i-1)
                    after = self.partition3(exp,i+1,end)
                    for m in pre:
                        for n in after:
                            if exp[i]=="+":
                                res.append(m+n)
                            if exp[i]=="-":
                                res.append(m-n)
                            if exp[i]=="*":
                                res.append(m*n)
            return res
<ul>4.无序数组中的第K个最大元素</ul>

	###第一种思路，topK

	###第二种，基于快速排序的分治法
	每一轮快速排序，都可以发现，有一个元素被放在了正确的位置，那么，如果被放在了k-1位置，那就可以确定是第K个元素，不然就向左或者向右

	ps:注意一下，我本来写的是，在外面求Index,while循环中判断，向左就再调用一次，但是发现，我写成了递归，总之很蠢，重复了很多子问题，所以超时，应该这么写

		l = 0
        r = len(nums)-1
        while True:
            index = self.partition4(nums,l,r)
            if index == k-1:
                print(nums[k-1])
                return nums[k-1]
            elif index > k-1:
                r = index-1
            else:
                l = index+1

2.做题
<ul>1.给4个数组，求四个数组中的某4个数，相加为0，这样的组合有几种</ul>

	###我的本来思路
	回溯，做的确能做，但是超时

	###正确
	首先看一个简单题，两数之和
	1.先排序，再双指针法
	2.暴力，遍历相加，复杂度n^2
	3.hash表法，遍历一次或者两次，把每次遍历的存进hash表，下次来查0-num 在不在表中

	这题四数之和同理，四个数组abcd，可以两两相加，把a+b存进去，差 -(c+d)



<h1>8.19</h1>

5.做题
<ul>1.汇总区间，给一个不重复的有序数组，是有序的，求覆盖的区间，比如[0,1,3,4]，就是0~1,3~4</ul>

	这道题是练手的，很简单，我们发现，由于是有序，那么遍历下来，只要下一个比前一个大1以上，就是新的区间的起点，就可以了

	维护起始下标和当前下标，移动即可
<ul>2.合并区间，给一个无序的数组列表，合并其中的区间</ul>

	###我自己的方法，还不错
	先根据每个区件的起始值排序，遍历一次，后一个起始值小于前一个的终止值，就合并，起始值和终止值重新设过。大于就不合并，前面的自成一个区间并提交，后面的作为新的区间，下标重置，唯一需要注意的就是最后一个值，不管咋样都要提交

		intervals.sort(key=lambda x:x[0])
        res = []
        start = intervals[0][0]
        end = intervals[0][1]
        for i in range(1,len(intervals)):
            if intervals[i][0]<=end:
                end = max(end,intervals[i][1])
            else:
                res.append([start,end])
                start = intervals[i][0]
                end = intervals[i][1]
            if i == len(intervals)-1:
                res.append([start,end])
        print(res)
<ul>3.求区间的交集，给两个断断续续的有序区间，然后求他们的交集</ul>
	###我自己的思路
	O(n^2)的复杂度，就是用第二个中的所有区间去靠第一个中的所有区间，顶多就是，当第二个中，头都比第一个中尾巴大，下次就不考虑它，结果写不出来，十分之丑陋

	###正确思路
	给出的A,B两个区别列表都是有序的，所以两者之间，终止点最小的，要么是A的尾巴，要么是B的尾巴，这里有一个注意点，最小的终止点所在的区间，只能和一个区间相交。因为如果和两个相交，那么那两个区间就是有重叠的，不符合题意

	这样就好做了，每次用最小的终止点在的区间去匹配另一个，弄好就pop

	###
	当然了，这样能过，但是并不是最优，最好pop之类的动作不要，用下标来代替，pop就是下标++
<ul>4.右区间，给一个无序的区间列表，返回起点大于选中区间终点的最近的区间的下标</ul>

	输入: [ [3,4], [2,3], [1,2] ]
	输出: [-1, 0, 1]
	3，4比4大的没了，就输出-1，有且最接近，就返回下标

	###暴力法（超时）
	###排序+hash（python的字典不是很好表示）
	###双数组+hash

	###排序+二分

		indexs = [i for i in range(len(intervals))]
        indexs.sort(key=lambda x:intervals[x][0])
        # print(indexs)
        def foo(target):
            if target > intervals[indexs[-1]][0]:
                return -1

            l, r = 0, len(indexs) - 1
            while l < r:
                mid = (l + r) >> 1
                if intervals[indexs[mid]][0] < target:
                    l = mid + 1
                else:
                    r = mid
            return indexs[l]

        res = [foo(intervals[i][1]) for i in range(len(intervals))]
        print(res)
        return res

<h1>8.20</h1>

1.做题
<ul>1.盛最多水的容器，11题，给一个数组，里面是栏杆的高度，求用这个容器装水，最多多大面积</ul>	

	###暴力，超时
	###双指针法
	一个从0，一个从最后，计算以他们为容器高度装水，然后移动下标。怎么移动呢，我们需要移动较短端的下标。证明很麻烦，可以这么思考，因为必须要移动，所以面积的长肯定是-1的，而面积由最短的来决定，移动长的一头，就算遇到更长的，还是根据短的算，所以移动长的一头，顶多持平，只有移动短的才行	
<ul>2.第62题，有一个m*n的矩阵，一个人从0，0到右下角，只能向右或向下移动，请问有几种走法</ul>

	可能以前做过，有点印象，动态规划

	右下角上面一格，到目标，只有一种，左边一格到目标，也是一种，而目标的左上角一格，就有两种，我们发现，当前位置到目标的走法，是下方一格和右方一格的和，因为只有两个方向可以移动。

	那么就可以从右下角开始向上动态规划。这里有越界的问题，可以在创建dp数组时，行和列都+1，置为0即可，初始目标点为1

<ul>3.最长回文子序列，序列嘛，就是不用连续的，比如bbbab，它的最长回文子序列就是bbbb，返回长度4</ul>

	###正确思路
	设s为字符串，s[i]=s[j]时，这两个就是符合的，现在设置dp二维数组，dp[i][j]表示，i~j 的最大长度。

	s[i]=s[j],dp[i][j]=dp[i+1][j-1]+2
	s[i]!=s[j],dp[i][j]=max(dp[i+1][j],dp[i][j-1])
	
	初始值，dp[i][i]=1，毕竟一个字符自身就是一个回文的

1.回文/压缩字符串


<h1>8.21</h1>

1.做题
<ul>1.一串无序的数，都在0~n-1上，现在你只能让0和为n的数进行交换，使他们变成有序</ul>

	###我写了个快排，交换的操作用0来做，但是没过

	###正确思路
	有序，且是0~n-1,说明array[i] = i，下标和值是一样的，那么，先把0和i位置上的数交换，然后再让0和 i 本身换，就ok了
<ul>2.下一个字典序。给一个int数组，里面有一些排列，求出它的下一个符合字典序的排列</ul>
	
	比如
	1,2,3 → 1,3,2
	3,2,1 → 1,2,3
	1,1,5 → 1,5,1

	#思路
	当数组是降序的时候，是不可能有更大的排序了，这时候题目规定返回升序的，也就是循环回来了。我们可以这样，从后往前走，当后往前是升序的，说明这段内没有最大的，继续，遇到了第一个不符合的，就把后面最接近的大于它的，进行交换，后面扫描过的由于倒着看是升序，所以顺着看是降序，这时候反过来即可

	###实现细节上还是有很多问题的
	向后找，找第一个不大于它的值，并交换它前一个，说明白了好像也没啥，那没事儿了
<ul>3.最长回文子序列</ul>

	动态规划，dp二维数组，dp[i][j]代表i到j的最大长度
	状态转移方程：
	if s[i]==s[j]  dp[i][j] = dp[i+1][j-1]+2
	if s[i]!=s[j]  dp[i][j] = max(dp[i+1][j],dp[i][j-1])

	看题目啊，这个是要看i+1的，所以后面的要先处理好，所以从后开始遍历
<ul>4.朋友圈问题，并查集</ul>

	首先设置一个初始数组，全都是-1，代表自己就是一个独立的朋友圈，然后遍历他们的关系，比如1和2有关系，就认为1是祖先，把2的值加给1，2本身变成他的祖先1

	比如本来123是 -1，-1，-1，现在12有关秀，变成-2，1，-1，后面的一样操作，只不过要记住，每次有关系时，都要找到他们的祖先再操作。到了最后，只要比较多少个小于0，就有多少个朋友圈，而且绝对值就是朋友圈大小，-1就是一个，-2就是俩
<ul>5.判断素数</ul>

	###最丑陋
	暴力法

	###初次优化
	假设一个数不是素数，那么至少有俩因数，一个<=sqrt(num)，一个>=sqrt(num)，那么从2遍历到sqrt(num)取整就好，除一除看行不行

	###再优化
	我们继续分析，其实质数还有一个特点，就是它总是等于 6x-1 或者 6x+1，其中 x 是大于等于1的自然数。

    如何论证这个结论呢，其实不难。首先 6x 肯定不是质数，因为它能被 6 整除；其次 6x+2 肯定也不是质数，因为它还能被2整除；依次类推，6x+3 肯定能被 3 整除；6x+4 肯定能被 2 整除。那么，就只有 6x+1 和 6x+5 (即等同于6x-1) 可能是质数了。所以循环的步长可以设为 6，然后每次只判断 6 两侧的数即可。

	if (num <= 3) {
        return num > 1;
    }
    // 不在6的倍数两侧的一定不是质数
    if (num % 6 != 1 && num % 6 != 5) {
        return false;
    }
    int sqrt = (int) Math.sqrt(num);
    for (int i = 5; i <= sqrt; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) {
            return false;
        }
    }
    return true;


<h1>8.22</h1>

1.做题
<ul>1.困难85，一个二维矩阵，里面都是0和1，求最大的1的矩形面积</ul>

	困难题，一开始做的时候想到了用动态规划，但是失败了，看了题解，最好的方法的确是动态规划，但不是一般人能想到的，把我恶心坏了

	###除开暴力版的，较为好的方法，O(m*m*n)
	可以这么思考这个问题，单独计算每一行的长度，从二维数组后面遍历，向上找，面积就是过程中的长宽相乘
<ul>2.迪杰特斯拉</ul>
<ul></ul>

2.回顾
<ul>1.面试</ul>

	1.seo暗链，预警之后怎么处理暗链？
	2.技术难点，查询优化，并发，中间件

	消息队列，不可重复读，消息乱序？消息丢失？重复消息？
	比如，中间件收到，投递者不晓得，又发了一次，消息重复了，消费者怎么解决
	不同消息队列的区别
	消息队列投递模型：投递一次，至少投递一次，准确只投递一次
	p2p/订阅

	双11的订单支付是用消息队列做的，技术难点是啥？除了削峰还有啥？如何保证用户操作有序

	mysql优化，表大小？

	反爬虫？

	缓存被击穿？除了我提的这个，还有吗


<h1>8.23</h1>

1.activemq再复习
<ul>1.消息处理方式机制</ul>
	
	###推 拉
	根据prefetchsize的设置，activemq分为推和拉两种形式，pull拉就是只有在消费者提出pull请求的时候，才会从broker发送一条，push则是会在消费者不饱满的时候，一次性分配prefetchsize条数据给该消费者，存在uncomsumeQueue里，也就是已分配，未消费队列里
	
	主动同步和监听者
	###同步，receive
	调用receive方法，如果pre的值=0，则代表消费者使用pull拉的消费方式，会从broker一条一条来。如果pre>0，说明有uncomsumeQueue,已经给他分配了点消息，直接从这个队列里取就行。另外还有一条未确认队列，里面都是已经发送，但没有确认的消息，每次receive，都会清空它，因为调用receive说明上一条已经ok了啊

	只有在pre=0，且uncomsumeQueue为空，才会pull

	###监听者，messagelistener
	这个模式规定，pre必须大于0，并且只有当发送ack确认了一条，才回去拿下一条。但这是没有开启optimizeACK的情况下，optimizeACK下面会说


2.做题
<ul>1.连续子序列乘积和最大</ul>


<h1>8.24</h1>

1.mq
<ul>1.optimizeACK</ul>

	前面说过，Listener监听模式，要一条确认之后，才会取下一条，但是这样太浪费网络传输了，所以有了optimizeACK，一个可优化的确认机制，说白了就是延迟确认

	comsumer消费了一条，不立即确认，而是当积累了n条确认，再一次性确认，与此同时还是可以取消息的。毕竟只有当用完一条，才会下一条。
	而在broker一边，有两种情况，1.迟迟收不到积累的确认，超过了设置的timeout，会自动确认n-1条，因为既然取走了第n条，说明前面的都用好了。2.当未确认unACK的数量到了prefetch*0.65，也会自动确认
<ul>2.慢消费者</ul>

	prefetch提高了push消息的效率，optimizeACK提高了ACK的效率，生产消息快，消费快，当然ok，如果消费者慢呢

	消费者慢，消息得不到确认（开启延迟确认的前提下），就会积压
	1.当broker内存占用太多，就会写入临时文件，这样就会产生磁盘IO
	2.消息积压，生产者就会减慢生产速度，慢消费者当然无所谓，但是快消费者会被影响，拉低整个系统效率
	3.写入临时文件，开启持久化的，消息消耗完就会恢复，而没有开启持久化的，就会宕机
	4.如果是订阅模式，所有消费者确认才会删除，一个不确认，消息就删除不了

	###解决
	1.关闭延迟确认，这样就一条一条来，一旦有消费，就立马能腾出内存
	2.减小prefetch，broker一次性给一个消费者分配这么多，消费不完也不给别人，就会积压，设置成1，积压就只有一个
	3.上面的优化机制，在慢消费时，都是累赘
	4.关闭慢消费者

<ul>3.消息乱序</ul>

	###乱序
	单消费者不会有乱序问题，因为都是一条一条来的，不可能，只有可能是多消费者，本来顺序是abc，消费者1拿了a，但是卡，来的慢了点，另一个消费者拿了b，网速快，就提前处理了，就会出现问题
	
	1.独有消费者
	Exclusive Consumer，指定一个queue是独占Exclusive的，那么它发送时，所有的消息都会只选择同一个消费者。单单是这样，会觉得小题大做，如果只有一个消费者也是一样效果，但是如果该消费者挂了呢？Exclusive Consumer就是在多个消费者中找个独占了，如果挂了，会换新的，不影响系统

	通常这样的，类似于一个主从结构，master消费，其他看着，master挂了，zookeeper选个新的，但是如果这时候原master恢复了，就有两个master了，这就是zookeeper脑裂问题。

	2.消息分组
	JMS消息属性JMXGroupID，规定了同一id的，只能到同一消费者就行了，只要在message对象上设置属性即可，顺便也做到了负载均衡

	3.在后端，存储已使用的最大id，比如用了2，你来了4，不符合，就缓存，直到来了3

<ul>4.消息重复/消息丢失</ul>

	###丢失
	不会丢失，有持久化，有确认机制，没确认的不会被删除，就算broker挂了，也有持久化，所以不会丢

	###重复
	这个有
	1.比如延迟确认，我明明消费了，但是还没确认，这时候我消费者挂了，broker就把消息分配给了别人，这就重复了
	2.还是延迟确认，我明明消费了，但我立马挂了，我恢复之后，又收到了一次

	###解决重复
	1.消息唯一标识入库
	2.布隆过滤器
	3.等等

2.做题
<ul>1.给一个数组，和为K的连续子数组有几个</ul>

	###O(n^2)
	遍历两遍，一遍是起始，一遍是末尾，就覆盖了所有，sum累加，如果等于k，就计数+1

	###基于hash表
	设sum(j)=0到j的和，那么i到j的和就是sum(j)-sum(i)，现在只遍历一遍数组，并行sum的累加，并加到hash表里，如果加的时候，表中已经存在 sum-k，说明减一减，是sum(j)-sum(i)是存在的，就count+1


<h1>8.25</h1>

1.做题
<ul>1.正则表达式匹配</ul>
<ul>2.比较版本号</ul>

	给两个字符串，一串数字用 . 分隔，就是那种常见的版本号，求前者大还是后者大

	两个字符串，split(".")，算好长度，遍历前面的，如果前面的大小就确定，当然OK，如果不行，短的补0，再进行比较，或者从一开始就短的补全，另外的话，队列就ok

<ul>3.每一位上的平方和，不断的去做，如果能够结果=1，就true,否则false</ul>

	比如 19 
	1*1+9*9 = 82
	8*8+2*2 = 68
	6*6+8*8 = 100
	1*1 = 1
	所以最终结果是1，就是true

	其实可以这么想，如果可以，那就会到1，如果不行，就会重复，回到某个值进行重复，那么只需要把用过的都存到hash表里，有重复就false

	p = lambda x:x*x
	def foo(i,res):
	    temp = {}
	    while True:
	        queue = []    //用来存每一位
	        while i > 0:
	            queue.append(i % 10)
	            i = i // 10
	        i = sum(map(p, queue))
	        if i==1:
	            return true
	        if i in temp:
	            return false
	        else:
	            temp[i] = 1
	

<h1>8.26</h1>

1.做题
<ul>1.全排列，求一个列表交换顺序之后的全部排列</ul>

	###剑指offer
	书里的方法是，每一个都和后面的交换
	回溯法的思想，dfs（res,nums,level）
	每次level+1，每次交换之后，递归完还要换回来

	def find(self,res,nums,level):
        if level==len(nums)-1:   //边界条件
            res.append(nums+[])

        for i in range(level,len(nums)):
            if i>level:  //这里就是要换
                nums[i],nums[level] = nums[level],nums[i]
                self.find(res,nums,level+1)
                nums[i], nums[level] = nums[level], nums[i]
            else:    //这里相当于不换，直接下一位
                self.find(res, nums, level + 1)

<ul>2.力扣238，求除自身以外的所有乘积</ul>

	比如[1,2,3,4]，返回[24,12,8,6]
	但是不能用除法，o(N)级别的复杂度

	可以左积*右积，从左往右来一遍，算出每个数左边的乘积，右边也来一遍，最后汇总乘一下，就是o(3n)

	
<ul>3一列高度不等的楼，站在某一楼，看不见自己楼，可以看到多少个楼
循环报数
归并排序</ul>


<h1>8.27</h1>

1.做题
<ul>1.归并排序</ul>
<ul></ul>
<ul></ul>

1.今日
<ul>分治法</ul>
<ul>区间的动态规划，还有昨天的几个笔试题</ul>
<ul>3.java处理输入输出</ul>
<ul>1.threadlocal</ul>
<ul>2.虚拟内存算法</ul>
<ul>3.中间人攻击/sendfile/buffer和cache/mmap/设计一个分布式，设计一个rpc框架</ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>


<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>