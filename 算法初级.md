---
<h1>初级第一章</h1>

1.时间复杂度

	忽略常数级的操作，比如交换一次，比较一次，只关乎数据的长度，也就是N

	而且只取最高次，且忽略系数


2.在两个数组中找重复的元素

	##
	o(m*n)，这就是遍历第一个，去第二个中遍历匹配

	##
	o(m*logn)，遍历第一个数组，在第二个用二分

	##
	o(m+n),弄两个指针，都指在两个数组的0位置，每次移动更小的那一个


3.将字符串或者数组的两部分交换

	12345 67 变成 67 12345

	12345逆序，67逆序，整体再逆序，就不用额外空间，空间复杂度1

	垃圾做法就是整一个等长的新数组，67填进去，12345再填进去

4.对数器

	就是一种验证算法正确与否的方法，先写出一种可能不优雅，但是绝对正确的犯法，然后提出自己的想法，当自己的想法和正确做法在不同随机数据下都一样时，说明正确。

	可以用来检验贪心算法

5.贪心算法举例，一段时间内安排尽可能多的课

	1.最先开始的，错
	2.时间最短的，错
	3.最早结束的，对

6.排序算法回顾

	#冒泡
	for(end--)
		for(start++)
	
	比较两个数，如果前一个比后一个大，就交换，也就是每一轮都把一个最大数放在最后面

	平均复杂度 n^2 ，最好最坏都是n^2，顶多就是，最好情况下已经排好序，不用交换，最坏情况逆序，每个都要交换，只是交换次数的区别，比较都要比较的

	#选择
	for(start++)
	每次都从后面的选一个最小的，放在 cur 当前位置

	平均复杂度 n^2，没有最好最坏之分，为了找出最小的，必须要全部比较过，但是最小的就是第一个，就不用交换了，也就是交换次数的问题

	#插入
	每次将当前数，插在左边的，适合他的位置。
	
	外部从 1 遍历，内部往回倒，如果前一个更大，就交换，直到前一个小为止。也就是，每一轮都定下一个位置，且左边的一定是已经排好序的

	平均复杂度n^2，最好是N，已经排好序，最坏N^2，逆序

	#归并
	把一个序列，拆成最小的单位，进行归并。平均复杂度 nlogn，最好最坏都这样，但是会有交换次数的不同，空间复杂度是n
	public static void differ(int[] array,int l,int r){
        if(l==r){
            return;
        }
        int mid = l+((r-l)>>1);
        differ(array,l,mid);
        differ(array,mid+1,r);
        merge(array,l,mid,r);
    }
    public static void merge(int[] array,int left,int mid,int right){
		//辅助数组
        int[] helper = new int[right-left+1];
        int i = 0;
		//其实这里就是两个指针，哪个小就移动哪个
        int p1 = left;
        int p2 = mid+1;
        while(p1<=mid && p2<=right){
            helper[i++] = array[p1]>array[p2] ? array[p2++] : array[p1++];
        }
		//如果有没用完的，就在这里用了
        while (p1<=mid){
            helper[i++] = array[p1++];
        }
        while (p2<=right){
            helper[i++] = array[p2++];
        }
        for (int j=0;j<helper.length;j++){
            array[left+j] = helper[j];
        }
    }

7.递归

	先写最底下的情况，然后写逻辑




---
<h1>初级第二章</h1>

1.求小和(归并的应用)

	问题：把数列中每个元素左边小于自身的元素加起来，{1， 2， 3}，结果就是1+1+2=4

	暴力是n^2，在这里可以应用归并排序，differ和merge思想不变，就是在归并时，比较下前后指针的大小，左小就加上，在merge返回每一次的res
	res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;


2.技术在前偶数在后

	用额外很简单，不多说，不用的话，就和快排思想一样，前后双指针，进行交换等等，但是不能保证原先顺序

	因为快排本身不稳定，实际上是有方法的，但是牵扯论文级别，叫做快排稳定性讨论，01stabler sort，比较困难。

	或者可以，首先遍历，遇到一个偶数，向后继续找，遇到的第一个奇数提上来，然后，后面整体向后移动一个


3.堆排序

	堆一般是用数组来做，左孩子是2i+1，右孩子是2i+2，所以父亲是(i-1)//2

	主要两个操作，insert和adjust，一个往上，一个往下

	insert就是一直找父节点，直到换不了为止，adjust就是反向，向下

---
<h1>初级第三章</h1>

1.java的array sort怎么实现

	小于64个，就是默认插入排序，因为常数级操作少，而且N不大，大于64个，用归并排序或者快速排序。

	基本类型就是快排，自己的类就是归并，因为快排不稳定，基本类型也不在意稳定性

2.求排序后的最大差值

	给一个无序数组，求排序后的相邻两数最大差值，要求复杂度o(n)

	因为复杂度N，所以只能用桶排序。数字可能是正数可能是负数，还可能范围特别大，所以不能直接用范围内的每一个数字做桶。

	解：先遍历一遍，能知道数的范围，也就是最大和最小。总共有N个数，就把范围分成N+1份，这样就肯定有一个桶是空的，也就保证了，肯定有两个非相邻桶，他们之间的差值大于桶粒度，而同一个桶内都是小于等于桶粒度的。 遍历所有桶，上一个桶最大的和这一桶最小的，差值就是答案

	###实现上的技巧
	弄三个数组，一个存在的boolean数组，一个min和max数组，每次遍历到一个数字，算出该属于哪个桶，exits[i]=true，然后更新对应的最大最小值。

	桶id = (now-min)*len/(max-min)


3.数组实现栈和队列

	##栈
	很简单，维护一个index，每次add就index++，index就代表这次要插入到的位置，当index=size，说明满了，要pop就index--

	##队列
	我原本的实现方法，只弄front和rear，都从头开始，rear+1%len==front说明满了，rear==front说明空了

	结果发现可以更简单，更容易理解。三个变量，start,end,size，start和end都只管++，然后倒回来，根据size来变化

4.队列，栈

	###队列实现栈
	两个队列，一个往里头加，pop的时候，把a中的元素倒到b中，只剩下一个pop就行了

	两个队列中，设置一个为cur，加的时候往cur加，pop的时候，把cur里的倒出来，再把另一个设为cur

	###栈实现队列
	两个栈，先往里面加，再倒到另一个里面，就是反过来的了，此时pop就可以

	也是设置cur，往cur里面加，pop的时候，更改cur


	###O(1)的getMin
	新建一个栈，存当前最小，压栈的时候，同步压入当前最小的，就ok


5.实现一个RandomPool

	1.hash表功能都要有
	2.可以o(1)的返回随机一个数，等概率随机

	弄两个map和一个index变量，一个map存储1:A，另一个存储 A：1，这样做是为了能够remove(a)指定元素。

	每次加入元素，就index++，当要删除时，remove(a)假设是删除了第3个元素，查出来把它删掉，然后把最后一位的，也就是Index-1位的填上来，然后Index--，这样在0~index中还是随机等概率的


---
<h1>初级第四章</h1>

1.转圈打印矩阵

	去想下标转一圈，很困难，换种思路，我们用左上角和右下角，也就是有四个数，r1,c1,r2,c2，c1到c2，r1到r2，然后减回去，是可以实现的。这就是一圈

	然后外面把两个坐标缩一下就行

2.之字形打印矩阵

	和上题思想一样，考虑一个点怎么之字形移动很困难。可以控制两个点，都从0，0开始，一个向右，一个向下，他们之间的路径就是之字形的

	单独写一个函数，传入两点下标，打印只见路径，比较容易实现


3.判断回文链表

	##额外空间 N
	这个方法是必须要想到的，可以新建一个栈，把链表遍历一次存进去，再遍历一次，一边遍历一边弹出栈，一旦不一样就不是

	##额外空间，改良版
	上一个方法，额外空间是N，现在改良，用快慢指针，找到中点，把之后的值存进栈，然后链表从头遍历，看是不是一样

	额外空间是0.5N，这里会有奇偶问题，奇数，中点落在一半的地方，没问题，偶数时中点落在中间两个的左边一个，但是我们是一直弹栈比较，所以比如123321，存的是321，弹出是123，3还是用到了，不影响

	###不使用额外空间
	还是快慢指针，找到中点，然后从后面开始，把后面的逆序，让中点指向null，下一个开始逆序。

	逆序很容易，pre，cur.还有next，弄完之后，pre指向最后一个，现在我们有head和tail，两个开始next遍历。条件是head!=null and tail!=null

	奇偶在这里没关系，如果是偶数，中点指向null，下一个却指向中点，当弄到这两个时，下一步是不符合条件的，毕竟指向null，所以没事	


4.快排核心思想partition

	partition的作用就是，给出一个flag/pivot，把小于等于他的放在左边，大于的放在右边。
	
	经典快排，就是以最后一个为flag，改成指定元素也很简单，把指定的和最后换一下位置就可以。设置一个begin，是起始-1，遇到符合就++，交换元素，弄完之后，再把最后一个的标杆和begin++换一下


5.把单向链表，小的放前面，大的放后面

	##有额外空间
	搞一个node数组，然后partition排序就行

	##无额外空间
	弄6个空node，分别指向small,equals,big的头尾，遍历原链表，遍历到一个就断开那个，然后接到小中大上去，最后把它们串起来
	

6.复制随机链表
	
	#有额外空间
	搞一个map，n1和n1"，这样一一去对应，新建一个链表，遍历原来的，一模一样去复制就好

	##改进，不用map
	遍历第一遍数组，复制一个n"，接在原来的每个n后面。
	遍历第二遍，把random关系也整上，取相应的n"节点，直接用Next就行
	再遍历一次，把新的拿出来

7.链表成环

	##hashset法，不多说

	##看结尾法，最后一个不一样的，肯定没交点

	###快慢指针

	快的走两步，慢的走一步，fast走到null就没环，两个指针相遇就有环，然后停下。

	其中一个继续走，一个回到head一起走，再次相遇就是起始点

8.链表处理常见操作

	1.逆序，pre,cur,next
	2.快慢指针,while(fast.next!=null && slow.next!=null)
	
	
9.布隆过滤器

	大概的之前都学过，补充下。

	一个Int是四字节，一字节(Bytes/B)就是8位(bit)，所以一个 int[100]，就是100*4*8个bit。一般我们定位，就是N //32，就找到了在第几个数字上，n%32，就知道在哪一位bit二进制上。

	主要重点就是 M Bit数目的多少，和 K 个hash函数的选用，有公式

![](img/boolom.png)



---
<h1>初级第五章</h1>

1.一致性hash

	其实在实现上，不用真的整出个环，假设前端有个hash函数，那么再前端就保存排好序的节点数组，比如{1，200，500}，找到第一个大于当前Hash的，就是相应节点了。如果比他们都大，就第一个喽。

	而在后端，增加节点，只需要通知下一个，迁移数据，删除也是只需要把数据交付给下一个

	##节点不均衡
	##本来均衡了，加上之后又不均衡了
	虚拟节点，比如现在有3个机器，每个机器给它整一万个虚拟节点，三万个都写在环上，就可以弄一个长度三万的排序数组来做。加机器，就再整一万个，基本都是均衡的。

	虚拟节点容易造，假设原本ip是192.0.0.1，加个xxx-1，hash一下就是一个，xxx-2就又是第二个

	##不用真的模拟一个环


2.快速找到中位数，随时可用

	每次查找都要排序，最少都是nlogn的复杂度，不可以。

	新建两个堆，左边大顶堆，右边小顶堆，查中位数就是左边最大和右边最小的平均值，或者是其中一个。

	add第一次的时候，默认加在左边大顶堆，后面加的和它比较，如果更大，就放在右边，如果更小，还是加在左边，每次加完检查一个两边的size差值，大于1就调整一下，把多的那个的顶，加到另一边，一直维持size差值1以内

3.Comparator

	核心就是conpare方法，参数o1,o2,返回值负数，说明o1在前面，正数说明在后面


4.切木头，堆，哈夫曼树，最小代价

	##题目
	给一个数组，里面是木条的长度，切分一个60长度的木头，代价是它的长度也就是60，求切成目标长度的最小代价

	举例，60的木头切成10，20，30，可以先弄成10，50，花费60，然后50弄成20，30，代价是50，总共110。但是一开始弄成30，30，然后30弄成10，20，总代价就是90

	##解
	目标是10，20，30，那就把这三个放在一个最小堆，每次拿出两个结合，再扔回堆。比如拿出10，20，变成30放回，堆中就是30.30，拿出时就是30，30，最后只剩一个60，结束

	##思想
	就是哈夫曼树，两个最小的结合，再挂回去，这个过程一般用堆来实现。可以实现一个最小归并代价

	##可以用于多路归并排序中，最优归并策略选取


5.一些任务，有花费和收入，只能做K次任务，给N的初始资金，求最大收入

	选第一个任务，肯定要选花费小于初始资金的，从里面选出赚最多的，做完之后，手里钱又多了，又要选钱足够，赚最多的，模拟过程非常困难

	新建两个堆，一个小顶堆，根据花费排序，一个大顶堆，根据赚的多少排序。现在有N的钱，就把小顶堆小于初始资金的poll，都加入右边的大顶堆，选的时候，就从大顶堆poll


6.二叉树遍历

	##先序
	用一个栈，把head放进去
	while(stack不空):
		cur = stack.pop()
		压右
		压左

	##中序，左根右
	先一路把左节点存进stack
	while(cur!=null):
		stack.push(cur)
		cur = cur.left

	左边的都进来了，然后弹出 cur = stack.pop()处理
	如果cur的右边不为空，就压进去再来
	合并一下就是
	while(stack!=null or cur!=null)
		if(cur!=null)
			stack.push(cur)
			cur = cur.left  //这一步一直下去，最左边全部
		else
			cur = stack.pop()  //到这里，左边满了，看右边
			if cur.right!=null:
				cur = cur.right  //有右边，添加，并从这里重复

	##后序，左右根
	左右根，其实就是根右左的压栈版，搞出根右左，压栈，弹出时就是左右根，而根右左很简单，先序的时候，改一下压栈顺序即可
		

7.找出下一个后继节点，按照中序顺序

	先中序排出来，再找肯定不现实。

	给出一个节点，观察，当他有右子树时，根据左中右，后继节点肯定是他右子树的最左节点。当他没有右子树时，从当前往上走，找到的第一个，以当前为左子树的Parent，就是后继

8.找出局部最小

	局部最小，就是小于相邻元素。所以第一个小于第二个，他就是，最后一个小于倒数第二个，他也是，题目要求返回一个就可以

	首先检查首尾是不是，不是的话，说明arr[0]>arr[1]，arr[n]>arr[n-1]，所以中间肯定有，然后看mid位置，Mid是的话，就返回，不是，看哪一边形成盆地范围，就缩小范围



9.并查集

	主要解决两个问题 union ，isSameSet?

	首先设置一个初始数组，全都是-1，代表自己就是一个独立的朋友圈，然后遍历他们的关系，比如1和2有关系，就认为1是祖先，把2的值加给1，2本身变成他的祖先1

	比如本来123是 -1，-1，-1，现在12有关秀，变成-2，1，-1，后面的一样操作，只不过要记住，每次有关系时，都要找到他们的祖先再操作。到了最后，只要比较多少个小于0，就有多少个朋友圈，而且绝对值就是朋友圈大小，-1就是一个，-2就是俩


---
<h1>算法初级第六章</h1>

1.前缀树

	比如字符串abc，就拆成a,b,c，每一个都是一个树节点，就是a->b->c，走到a,再去走到b，每个节点都有三个属性，pass,end,next[]，分别是经过它的数量，以它做终点的数量，下一跳有哪些

	###应用
	假设一个场景，一篇文章，统计某个单词出现的次数，可以把每个单词都存进hash，也可以用前缀树，显然前缀树更好。比如abc，从a进去，等到c，返回他的end即可，而且，当我们需要查询，以ab为开头的次数时，只要遍历到ab，返回b的pass即可，非常简单，还可以自己定制

	复杂度也很低，是字符串的长度。

	insert时，遍历str，pass++，next[]添加，到终点end++
	查询时，遍历，中间字母就查不到，就是0，不然返回end
	delete，先查有没有，有就遍历，当前位置--pass，如果等于0，就结束，不然到尾，end--
	

2.图的遍历

	##BFS
	广度遍历，就是把每一轮的节点都放进栈里，每次拿出的都是同一距离的

	##DFS
	for(node next:cur.next){
		print(cur)
		foo(next)
	}	

3.DFS

	视频给出的是用栈做的，当栈不空，就pop，如果没有下一个，就结束了如果有next，就把刚才pop的放回来，这个要用来倒回来的时候，去其他节点。原来的放回来，再把下面的放进来，直接break,就是只放一个Next. 此外用过的不用了

	不管BFS或者DFS，都有一个东西，用一个东西表示，用过的就不用了。

	DFS中一般用递归来做，也就是回溯法。大概的框架是这样的
	func(root):
		for i in root.next:
			foo(i)

	这样就已经深度遍历了，但是一般有额外的条件
	1.比如找一个特定搭配(N数和为target)，在上面的就是所有的搭配都回溯，这时候就要参数加上长度等边界值，函数中加上结束条件
	2.返回的是特定答案，参数就是res，一般在终止条件中res.add，那么中间的过程就是temp
	3.主体中for，里面的递归，符合条件就temp.add，丢进递归，出来之后，就把temp.pop
	4.一般temp.add的操作都是在主体for中的，不在终止条件中，相应的最初始的调用，也要把第一个节点安排好

	##不用递归
	弄一个辅助栈，不用递归。首先把第一个加进栈，然后while不空，里面不停的pop，如果pop的节点没有Next，pop就pop了，如果有下一个，就把弹出的加回来，再把下一个加上，break


4.拓扑算法

	假设B需要在A后面实现，C要在B后面实现，类似这种先后关系，现在更加复杂，需要得到一个正确的顺序，就需要用到拓扑排序，这种排序并不唯一
	
	一个图，每个点都有自己的出度入度，首先找到入度0的，把它弄出来，从图中删除。顺便把它影响到的出度入度也删除，然后继续找下一个入度的，这样删除的顺序就是拓扑排序。实现上可以弄一个zeroQueue，事先存一个，后面一旦有入度0的就加入队列。

	拓扑排序不允许有环，所以遇到入度最终不能变成0的，说明有环。可以用在检测环存在，找出先后顺序的题目中
	

5.最小生成树的Kruskal算法

	优先选边。搞一个堆，把所有的边存进，每次拿出最小的，涉及的点，弄成并查集，如果每次拿出的边对应的两个点，都不在一个集合内说明OK，不然就跳过。

6.Prim算法

	选的是点。从某个点出发，把已经弄过的点存在set里，整个集合涉及的边放进堆里，每次拿出最小边，如果不能拓展新的点，就跳过

7.上面的实现总结

	图，总的是一个gragh，里面是一个hashset存边，一个hashmap存（key,node）

	边edge，里面是权值value，和from,to两个Node

	node里面，首先是权值value，然后有nexts[],edges[]这个边数组是以它做from的，另外可能还加上In，out出度入度之类

	上面，选最小边，都是用的堆，K算法中，判断是否有环，用的是并查集
收藏12/9


---
<h1>算法初级第七章</h1>

1.暴力递归，和动态规划

	###递归
	1.一个大的问题，分成小的问题
	2.有终止条件
	3.中间的结果不保存
	4.递归的主体，对上面已经产生的递归结果，有处理

	###动态规划
	1.写出暴力递归，基本就能弄出动态规划版本
	2.把中间结果记录下来，这就产生了缓存版本的升级递归
	
2.做题技巧

	###暴力递归
	首先写出暴力递归。这个其实也不太好写。
	写一个大的函数，是一个大的情况，然后考虑终止条件。
	然后考虑，结果要的是什么，可能某一步，他有两种走向。总结下一概两种，1.本轮返回的，就是这两种走向结果已经得到之后，处理之后的结果，比如两个res中更大的一个  2.每一个并不返回什么，而是在最后终止条件中处理，那么就不用想这么多，在最终搞一下就行

	关于参数，一般是一个index下标，一个是已有的Pre值，如果不用dp数组，单纯的hashset缓存，也可以用字符串的pre来存

	###尝试画一下递归树
	画出来，就能明白，如果hashset缓存，存的是什么，而且dp数组，从哪里开始。

	##缓存
	暴力整体不变，搞一个hashset，存下中间的结果，如果遇到就返回，不用递归了，整体代码不变

	##dp
	写出暴力递归之后，看参数，如果两个参数就能确定值，就弄成dp二维数组，具体看需要几个值确定。

	比如背包，参数中index，和pre就可以，弄成二维数组，index取0-len，因为index==Len是终止条件，pre取到背包最大值，在打了也没有意义。但是按照模板，本来应该是pre取0-sum

	然后看终止条件，一般可以确定最后一个，或者最后一行，接下来找主体的逻辑，把拼图拼好，需要啥操作就行
	

3.背包问题

	#递归版本
	1.首先是参数，物品列表，价值列表，当前第i个，已经cost的体积，背包体积，五个参数
	2.然后是终止条件，cost超过bag，就返回minValue，i=length，就超过列表大小了，就返回0
	3.主题逻辑，当前第i个选或不选，分别递归，取max

	#dp版本
	1.确定影响结果的是哪些变量，在这里是i，cost，所以dp数组是二维的，行是i，0到length，列是cost，0到bag
	2.接下来看已经确定的是什么，我们需要求得是什么，发现i=length的时候都是0，这是已经确定的，求的是dp[0][0]，意思是从第0个开始，已有cost是0
	3.看递归版本的主体逻辑，发现dp[i][j]和dp[i+1][j]和dp[i+1][j+arr[i]]有关。


4.给一个数组和一个target，返回数组中任意之和是否能等于target

	差不多
	

5.最短路径和

	##递归
	1.参数：二维数组，横纵坐标
	2.终止条件：横纵坐标到了终点，就返回当前位置值
	3.分情况：因为只能向右向下，所以边上的单独处理，一般情况，当前值+min(向下，向右)

	##动态规划
	1.参数:只有二维数组
	2.影响结果的只有横纵坐标，所以dp数组二维，长度是横纵。
	3.已经确定的是终点，还有和终点相关的最后一行和最后一列，递推先算出这些，准备工作完毕
	4.分析递归版本，发现i,j位置的只和下面的和右边的有关，就从下面开始两个for循环，知道dp[0][0]为止
	5.需要返回的结果就是，递归函数的最开始状态


	
明天把做的题目加上
	


---
<h1>算法初级第八章</h1>
	
1.接雨水，给一个数组，问能接到多少水，边界不算

	这种问题可以转化成，每一格位置上，可以接到多少水

	##辅助数组
	每一格上的水，分别取决于它左右两边的最大值，在这两个中，又是取小的。如果这个小的比当前小，当然存不住水，大就存它们的差值。这个问题就转化成，求左右两边的最大值。可以n的复杂度去找，但是没必要

	我们采用辅助数组，从左到右一遍，大的就存下，小的就存下前面的大的。这就是left数组，再右到左一遍，弄出一个right数组，然后解决问题，从1遍历到n-1，每次求当前位置的水，加起来。

	##不用辅助数组
	设置两个指针，还有保存两个变量leftMax，rightmax，初始就是第一个和最后一个。然后准备移动两个指针，比较leftMax，rightmax，可以发现，因为有大的那个兜底，所以水量肯定取决于小的那个，那么靠近小的那一边的水量就可以确定，然后指针移动收缩，更新max，当左右一样，就都处理


2.最大子数组和

	老题。设置两个变量，cur，max，遍历数组，cur不断去加，是正数就保留，负数就置0，因为前面负数的肯定用不上，在这中间，每次都更新max


3.想要保留顺序的交换两个字符串的位置，而且不用额外空间

	比如 abcde 变成 deabc ,先把abc逆序，再把de逆序，再整体逆序

	需要抽象出来的只有reverse（start,stop）

	##
	这里可以出很多题目，比如 判断一个str是不是另一个的移位，可以转化成是不是 两倍str的子串，判断是不是子串，需要用到KMP


4.滑动窗口最大值

	滑动窗口，找出每一轮窗口中的最大值，如果是常规遍历去找，就是o(nk)的复杂度，k是窗口大小。

	每次找出最大的，其实可以用堆来做，那就是 nlogk

	双端队列，里面只能存从大到小的，来一个新的大的，就把老的丢下去，相等的也丢，头元素就是当前的最大。移动窗口时，前面的后移，就检查要失效的是不是头元素，是就弹出。后面的后移时，就按照正常来。队列里存的其实就是下标。

	##单调栈
	其实也是按照一个顺序来存，记住这个就够了
	

5.最小字典序

	取本身字典序最小，这个不可以，比如 b 和 ba ，b更加小，但是bba比bab大，所以不成立。

	正确的策略，str1和str2，组成1+2和2+1,哪个小，就在前面。

	可以自己写排序，这个就是比较方法，也可以array.sort，自己写比较器


---
<h1>算法初级终章</h1>

1.KMP算法

	##本质
	其实就是一个判断A是不是包含B的操作，返回如果有，B的开头位置

	
<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>
<ul></ul>

<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>

<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>

<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>

<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>


<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>

<ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul><ul></ul>
<ul></ul>